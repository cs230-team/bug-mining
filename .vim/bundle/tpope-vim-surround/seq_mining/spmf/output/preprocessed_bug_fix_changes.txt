public -1 boolean -1 equals(Object -1 obj) -1 { -1 if -1 (!(obj -1 instanceof -1 ShapeList)) -1 { -1 return -1 false; -1 } -1 ---- -1 ---return -1 ---super.equals(obj); -1 ++++ -1 +++ShapeList -1 +++that -1 +++= -1 +++(ShapeList) -1 +++obj; -1 ++++ -1 +++int -1 +++listSize -1 +++= -1 +++size(); -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++listSize; -1 +++i++) -1 +++{ -1 ++++ -1 +++if -1 +++(!ShapeUtilities.equal((Shape) -1 +++get(i), -1 +++(Shape) -1 +++that.get(i))) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++true; -1 } -1 -2
public -1 StandardToolTipTagFragmentGenerator() -1 { -1 * -1 @return -1 The -1 formatted -1 HTML -1 area -1 tag -1 attribute(s). -1 */ -1 public -1 String -1 generateToolTipFragment(String -1 toolTipText) -1 { -1 ---- -1 ---return -1 ---" -1 ---title=\"" -1 ---+ -1 ---toolTipText -1 ++++ -1 +++return -1 +++" -1 +++title=\"" -1 ++++ -1 +++ImageMapUtilities.htmlEscape(toolTipText) -1 + -1 "\" -1 alt=\"\""; -1 } -1 -2
public -1 TimeSeries -1 createCopy(RegularTimePeriod -1 start, -1 RegularTimePeriod -1 end) -1 endIndex -1 = -1 -(endIndex -1 + -1 1); -1 // -1 this -1 is -1 first -1 item -1 AFTER -1 end -1 period -1 endIndex -1 = -1 endIndex -1 - -1 1; -1 // -1 so -1 this -1 is -1 last -1 item -1 BEFORE -1 end -1 } -1 ---- -1 ---if -1 ---(endIndex -1 ---< -1 ---0) -1 ---{ -1 ++++ -1 +++if -1 +++((endIndex -1 +++< -1 +++0) -1 +++|| -1 +++(endIndex -1 +++< -1 +++startIndex)) -1 +++{ -1 emptyRange -1 = -1 true; -1 } -1 if -1 (emptyRange) -1 { -1 -2
public -1 Week(Date -1 time) -1 { -1 */ -1 public -1 Week(Date -1 time, -1 TimeZone -1 zone) -1 { -1 // -1 defer -1 argument -1 checking... -1 ---- -1 ---this(time, -1 ---RegularTimePeriod.DEFAULT_TIME_ZONE, -1 ---Locale.getDefault()); -1 ++++ -1 +++this(time, -1 +++zone, -1 +++Locale.getDefault()); -1 } -1 /** -1 -2
private -1 void -1 updateBounds(TimePeriod -1 period, -1 int -1 index) -1 { -1 } -1 if -1 (this.maxMiddleIndex -1 >= -1 0) -1 { -1 ---- -1 ---long -1 ---s -1 ---= -1 ---getDataItem(this.minMiddleIndex).getPeriod().getStart() -1 ++++ -1 +++long -1 +++s -1 +++= -1 +++getDataItem(this.maxMiddleIndex).getPeriod().getStart() -1 .getTime(); -1 ---- -1 ---long -1 ---e -1 ---= -1 ---getDataItem(this.minMiddleIndex).getPeriod().getEnd() -1 ++++ -1 +++long -1 +++e -1 +++= -1 +++getDataItem(this.maxMiddleIndex).getPeriod().getEnd() -1 .getTime(); -1 long -1 maxMiddle -1 = -1 s -1 + -1 (e -1 - -1 s) -1 / -1 2; -1 if -1 (middle -1 > -1 maxMiddle) -1 { -1 -2
public -1 XYDataItem -1 addOrUpdate(Number -1 x, -1 Number -1 y) -1 { -1 if -1 (x -1 == -1 null) -1 { -1 throw -1 new -1 IllegalArgumentException("Null -1 'x' -1 argument."); -1 } -1 ++++ -1 +++if -1 +++(this.allowDuplicateXValues) -1 +++{ -1 ++++ -1 +++add(x, -1 +++y); -1 ++++ -1 +++return -1 +++null; -1 ++++ -1 +++} -1 // -1 if -1 we -1 get -1 to -1 here, -1 we -1 know -1 that -1 duplicate -1 X -1 values -1 are -1 not -1 permitted -1 XYDataItem -1 overwritten -1 = -1 null; -1 int -1 index -1 = -1 indexOf(x); -1 ---- -1 ---if -1 ---(index -1 --->= -1 ---0 -1 ---&& -1 ---!this.allowDuplicateXValues) -1 ---{ -1 ++++ -1 +++if -1 +++(index -1 +++>= -1 +++0) -1 +++{ -1 XYDataItem -1 existing -1 = -1 (XYDataItem) -1 this.data.get(index); -1 try -1 { -1 overwritten -1 = -1 (XYDataItem) -1 existing.clone(); -1 -2
public -1 TimeSeries -1 createCopy(int -1 start, -1 int -1 end) -1 throw -1 new -1 IllegalArgumentException("Requires -1 start -1 <= -1 end."); -1 } -1 TimeSeries -1 copy -1 = -1 (TimeSeries) -1 super.clone(); -1 ++++ -1 +++copy.minY -1 +++= -1 +++Double.NaN; -1 ++++ -1 +++copy.maxY -1 +++= -1 +++Double.NaN; -1 copy.data -1 = -1 new -1 java.util.ArrayList(); -1 if -1 (this.data.size() -1 > -1 0) -1 { -1 for -1 (int -1 index -1 = -1 start; -1 index -1 <= -1 end; -1 index++) -1 { -1 -2
public -1 Range -1 getDataRange(ValueAxis -1 axis) -1 { -1 } -1 } -1 ++++ -1 +++if -1 +++(r -1 +++!= -1 +++null) -1 +++{ -1 Collection -1 c -1 = -1 r.getAnnotations(); -1 Iterator -1 i -1 = -1 c.iterator(); -1 while -1 (i.hasNext()) -1 { -1 @@ -1 -4498,6 -1 +4499,7 -1 @@ -1 public -1 Range -1 getDataRange(ValueAxis -1 axis) -1 { -1 includedAnnotations.add(a); -1 } -1 } -1 ++++ -1 +++} -1 } -1 } -1 -2
public -1 static -1 Range -1 iterateDomainBounds(XYDataset -1 dataset, -1 for -1 (int -1 series -1 = -1 0; -1 series -1 < -1 seriesCount; -1 series++) -1 { -1 int -1 itemCount -1 = -1 dataset.getItemCount(series); -1 for -1 (int -1 item -1 = -1 0; -1 item -1 < -1 itemCount; -1 item++) -1 { -1 ++++ -1 +++double -1 +++value -1 +++= -1 +++intervalXYData.getXValue(series, -1 +++item); -1 lvalue -1 = -1 intervalXYData.getStartXValue(series, -1 item); -1 uvalue -1 = -1 intervalXYData.getEndXValue(series, -1 item); -1 ++++ -1 +++if -1 +++(!Double.isNaN(value)) -1 +++{ -1 ++++ -1 +++minimum -1 +++= -1 +++Math.min(minimum, -1 +++value); -1 ++++ -1 +++maximum -1 +++= -1 +++Math.max(maximum, -1 +++value); -1 ++++ -1 +++} -1 if -1 (!Double.isNaN(lvalue)) -1 { -1 minimum -1 = -1 Math.min(minimum, -1 lvalue); -1 ++++ -1 +++maximum -1 +++= -1 +++Math.max(maximum, -1 +++lvalue); -1 } -1 if -1 (!Double.isNaN(uvalue)) -1 { -1 ++++ -1 +++minimum -1 +++= -1 +++Math.min(minimum, -1 +++uvalue); -1 maximum -1 = -1 Math.max(maximum, -1 uvalue); -1 } -1 } -1 @@ -1 -1239,12 -1 +1246,19 -1 @@ -1 public -1 static -1 Range -1 iterateRangeBounds(XYDataset -1 dataset, -1 for -1 (int -1 series -1 = -1 0; -1 series -1 < -1 seriesCount; -1 series++) -1 { -1 int -1 itemCount -1 = -1 dataset.getItemCount(series); -1 for -1 (int -1 item -1 = -1 0; -1 item -1 < -1 itemCount; -1 item++) -1 { -1 ++++ -1 +++double -1 +++value -1 +++= -1 +++ixyd.getYValue(series, -1 +++item); -1 double -1 lvalue -1 = -1 ixyd.getStartYValue(series, -1 item); -1 double -1 uvalue -1 = -1 ixyd.getEndYValue(series, -1 item); -1 ++++ -1 +++if -1 +++(!Double.isNaN(value)) -1 +++{ -1 ++++ -1 +++minimum -1 +++= -1 +++Math.min(minimum, -1 +++value); -1 ++++ -1 +++maximum -1 +++= -1 +++Math.max(maximum, -1 +++value); -1 ++++ -1 +++} -1 if -1 (!Double.isNaN(lvalue)) -1 { -1 minimum -1 = -1 Math.min(minimum, -1 lvalue); -1 ++++ -1 +++maximum -1 +++= -1 +++Math.max(maximum, -1 +++lvalue); -1 } -1 if -1 (!Double.isNaN(uvalue)) -1 { -1 ++++ -1 +++minimum -1 +++= -1 +++Math.min(minimum, -1 +++uvalue); -1 maximum -1 = -1 Math.max(maximum, -1 uvalue); -1 } -1 } -1 -2
public -1 LegendItemCollection -1 getLegendItems() -1 { -1 } -1 int -1 index -1 = -1 this.plot.getIndexOf(this); -1 CategoryDataset -1 dataset -1 = -1 this.plot.getDataset(index); -1 ---- -1 ---if -1 ---(dataset -1 ---!= -1 ---null) -1 ---{ -1 ++++ -1 +++if -1 +++(dataset -1 +++== -1 +++null) -1 +++{ -1 return -1 result; -1 } -1 int -1 seriesCount -1 = -1 dataset.getRowCount(); -1 -2
public -1 MultiplePiePlot() -1 { -1 */ -1 public -1 MultiplePiePlot(CategoryDataset -1 dataset) -1 { -1 super(); -1 ---- -1 ---this.dataset -1 ---= -1 ---dataset; -1 ++++ -1 +++setDataset(dataset); -1 PiePlot -1 piePlot -1 = -1 new -1 PiePlot(null); -1 this.pieChart -1 = -1 new -1 JFreeChart(piePlot); -1 this.pieChart.removeLegend(); -1 -2
public -1 static -1 boolean -1 equal(GeneralPath -1 p1, -1 GeneralPath -1 p2) -1 { -1 return -1 false; -1 } -1 PathIterator -1 iterator1 -1 = -1 p1.getPathIterator(null); -1 ---- -1 ---PathIterator -1 ---iterator2 -1 ---= -1 ---p1.getPathIterator(null); -1 ++++ -1 +++PathIterator -1 +++iterator2 -1 +++= -1 +++p2.getPathIterator(null); -1 double[] -1 d1 -1 = -1 new -1 double[6]; -1 double[] -1 d2 -1 = -1 new -1 double[6]; -1 boolean -1 done -1 = -1 iterator1.isDone() -1 && -1 iterator2.isDone(); -1 -2
protected -1 Size2D -1 arrangeFF(BlockContainer -1 container, -1 Graphics2D -1 g2, -1 h[3] -1 = -1 h[2]; -1 if -1 (this.rightBlock -1 != -1 null) -1 { -1 RectangleConstraint -1 c4 -1 = -1 new -1 RectangleConstraint(0.0, -1 ---- -1 ---new -1 ---Range(0.0, -1 ---constraint.getWidth() -1 ---- -1 ---w[2]), -1 ++++ -1 +++new -1 +++Range(0.0, -1 +++Math.max(constraint.getWidth() -1 +++- -1 +++w[2], -1 +++0.0)), -1 LengthConstraintType.RANGE, -1 h[2], -1 null, -1 LengthConstraintType.FIXED); -1 Size2D -1 size -1 = -1 this.rightBlock.arrange(g2, -1 c4); -1 -2
private -1 void -1 rebuildIndex -1 () -1 { -1 public -1 void -1 removeValue(int -1 index) -1 { -1 this.keys.remove(index); -1 this.values.remove(index); -1 ---- -1 ---if -1 ---(index -1 ---< -1 ---this.keys.size()) -1 ---{ -1 rebuildIndex(); -1 ---- -1 ---} -1 } -1 /** -1 * -1 Removes -1 a -1 value -1 from -1 the -1 collection. -1 * -1 * -1 @param -1 key -1 the -1 item -1 key -1 (<code>null</code> -1 not -1 permitted). -1 * -1 * -1 @throws -1 IllegalArgumentException -1 if -1 <code>key</code> -1 is -1 * -1 <code>null</code>. -1 * -1 @throws -1 UnknownKeyException -1 if -1 <code>key</code> -1 is -1 not -1 recognised. -1 */ -1 public -1 void -1 removeValue(Comparable -1 key) -1 { -1 int -1 index -1 = -1 getIndex(key); -1 if -1 (index -1 < -1 0) -1 { -1 ---- -1 ---return; -1 ++++ -1 +++throw -1 +++new -1 +++UnknownKeyException("The -1 +++key -1 +++(" -1 ++++ -1 +++key -1 ++++ -1 ++++ -1 +++") -1 +++is -1 +++not -1 +++recognised."); -1 } -1 removeValue(index); -1 } -1 /** -1 * -1 Clears -1 all -1 values -1 from -1 the -1 collection. -1 * -1 * -1 @since -1 1.0.2 -1 */ -1 ------ -1 ---a/source/org/jfree/data/DefaultKeyedValues2D.java -1 ++++++ -1 +++b/source/org/jfree/data/DefaultKeyedValues2D.java -1 @@ -1 -454,12 -1 +454,21 -1 @@ -1 public -1 void -1 removeColumn(int -1 columnIndex) -1 { -1 public -1 void -1 removeColumn(Comparable -1 columnKey) -1 { -1 ++++ -1 +++if -1 +++(columnKey -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Null -1 +++'columnKey' -1 +++argument."); -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(!this.columnKeys.contains(columnKey)) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++UnknownKeyException("Unknown -1 +++key: -1 +++" -1 ++++ -1 +++columnKey); -1 ++++ -1 +++} -1 Iterator -1 iterator -1 = -1 this.rows.iterator(); -1 while -1 (iterator.hasNext()) -1 { -1 DefaultKeyedValues -1 rowData -1 = -1 (DefaultKeyedValues) -1 iterator.next(); -1 ++++ -1 +++int -1 +++index -1 +++= -1 +++rowData.getIndex(columnKey); -1 ++++ -1 +++if -1 +++(index -1 +++>= -1 +++0) -1 +++{ -1 rowData.removeValue(columnKey); -1 ++++ -1 +++} -1 } -1 this.columnKeys.remove(columnKey); -1 } -1 /** -1 * -1 Clears -1 all -1 the -1 data -1 and -1 associated -1 keys. -1 */ -1 -2
public -1 boolean -1 removeDomainMarker(int -1 index, -1 Marker -1 marker, -1 Layer -1 layer, -1 markers -1 = -1 (ArrayList) -1 this.backgroundDomainMarkers.get(new -1 Integer( -1 index)); -1 } -1 ++++ -1 +++if -1 +++(markers -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 boolean -1 removed -1 = -1 markers.remove(marker); -1 if -1 (removed -1 && -1 notify) -1 { -1 fireChangeEvent(); -1 @@ -1 -2445,6 -1 +2448,9 -1 @@ -1 public -1 boolean -1 removeRangeMarker(int -1 index, -1 Marker -1 marker, -1 Layer -1 layer, -1 markers -1 = -1 (ArrayList) -1 this.backgroundRangeMarkers.get(new -1 Integer( -1 index)); -1 } -1 ++++ -1 +++if -1 +++(markers -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 boolean -1 removed -1 = -1 markers.remove(marker); -1 if -1 (removed -1 && -1 notify) -1 { -1 fireChangeEvent(); -1 ------ -1 ---a/source/org/jfree/chart/plot/XYPlot.java -1 ++++++ -1 +++b/source/org/jfree/chart/plot/XYPlot.java -1 @@ -1 -2290,6 -1 +2290,9 -1 @@ -1 public -1 boolean -1 removeDomainMarker(int -1 index, -1 Marker -1 marker, -1 Layer -1 layer, -1 markers -1 = -1 (ArrayList) -1 this.backgroundDomainMarkers.get(new -1 Integer( -1 index)); -1 } -1 ++++ -1 +++if -1 +++(markers -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 boolean -1 removed -1 = -1 markers.remove(marker); -1 if -1 (removed -1 && -1 notify) -1 { -1 fireChangeEvent(); -1 @@ -1 -2526,6 -1 +2529,9 -1 @@ -1 public -1 boolean -1 removeRangeMarker(int -1 index, -1 Marker -1 marker, -1 Layer -1 layer, -1 markers -1 = -1 (ArrayList) -1 this.backgroundRangeMarkers.get(new -1 Integer( -1 index)); -1 } -1 ++++ -1 +++if -1 +++(markers -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 boolean -1 removed -1 = -1 markers.remove(marker); -1 if -1 (removed -1 && -1 notify) -1 { -1 fireChangeEvent(); -1 -2
public -1 void -1 add(BoxAndWhiskerItem -1 item, -1 Comparable -1 rowKey, -1 && -1 this.minimumRangeValueColumn -1 == -1 c)) -1 { -1 updateBounds(); -1 } -1 ++++ -1 +++else -1 +++{ -1 double -1 minval -1 = -1 Double.NaN; -1 if -1 (item.getMinOutlier() -1 != -1 null) -1 { -1 @@ -1 -185,6 -1 +186,7 -1 @@ -1 else -1 if -1 (minval -1 < -1 this.minimumRangeValue) -1 { -1 this.minimumRangeValueRow -1 = -1 r; -1 this.minimumRangeValueColumn -1 = -1 c; -1 } -1 ++++ -1 +++} -1 this.rangeBounds -1 = -1 new -1 Range(this.minimumRangeValue, -1 this.maximumRangeValue); -1 @@ -1 -738,7 -1 +740,44 -1 @@ -1 public -1 List -1 getOutliers(Comparable -1 rowKey, -1 Comparable -1 columnKey) -1 { -1 */ -1 private -1 void -1 updateBounds() -1 { -1 this.minimumRangeValue -1 = -1 Double.NaN; -1 ++++ -1 +++this.minimumRangeValueRow -1 +++= -1 +++-1; -1 ++++ -1 +++this.minimumRangeValueColumn -1 +++= -1 +++-1; -1 this.maximumRangeValue -1 = -1 Double.NaN; -1 ++++ -1 +++this.maximumRangeValueRow -1 +++= -1 +++-1; -1 ++++ -1 +++this.maximumRangeValueColumn -1 +++= -1 +++-1; -1 ++++ -1 +++int -1 +++rowCount -1 +++= -1 +++getRowCount(); -1 ++++ -1 +++int -1 +++columnCount -1 +++= -1 +++getColumnCount(); -1 ++++ -1 +++for -1 +++(int -1 +++r -1 +++= -1 +++0; -1 +++r -1 +++< -1 +++rowCount; -1 +++r++) -1 +++{ -1 ++++ -1 +++for -1 +++(int -1 +++c -1 +++= -1 +++0; -1 +++c -1 +++< -1 +++columnCount; -1 +++c++) -1 +++{ -1 ++++ -1 +++BoxAndWhiskerItem -1 +++item -1 +++= -1 +++getItem(r, -1 +++c); -1 ++++ -1 +++if -1 +++(item -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++Number -1 +++min -1 +++= -1 +++item.getMinOutlier(); -1 ++++ -1 +++if -1 +++(min -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++double -1 +++minv -1 +++= -1 +++min.doubleValue(); -1 ++++ -1 +++if -1 +++(!Double.isNaN(minv)) -1 +++{ -1 ++++ -1 +++if -1 +++(minv -1 +++< -1 +++this.minimumRangeValue -1 +++|| -1 +++Double.isNaN( -1 ++++ -1 +++this.minimumRangeValue)) -1 +++{ -1 ++++ -1 +++this.minimumRangeValue -1 +++= -1 +++minv; -1 ++++ -1 +++this.minimumRangeValueRow -1 +++= -1 +++r; -1 ++++ -1 +++this.minimumRangeValueColumn -1 +++= -1 +++c; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++Number -1 +++max -1 +++= -1 +++item.getMaxOutlier(); -1 ++++ -1 +++if -1 +++(max -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++double -1 +++maxv -1 +++= -1 +++max.doubleValue(); -1 ++++ -1 +++if -1 +++(!Double.isNaN(maxv)) -1 +++{ -1 ++++ -1 +++if -1 +++(maxv -1 +++> -1 +++this.maximumRangeValue -1 +++|| -1 +++Double.isNaN( -1 ++++ -1 +++this.maximumRangeValue)) -1 +++{ -1 ++++ -1 +++this.maximumRangeValue -1 +++= -1 +++maxv; -1 ++++ -1 +++this.maximumRangeValueRow -1 +++= -1 +++r; -1 ++++ -1 +++this.maximumRangeValueColumn -1 +++= -1 +++c; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++} -1 } -1 /** -1 -2
public -1 void -1 setExplodePercent(Comparable -1 key, -1 double -1 percent) -1 { -1 * -1 @return -1 The -1 percent. -1 */ -1 public -1 double -1 getMaximumExplodePercent() -1 { -1 ++++ -1 +++if -1 +++(this.dataset -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++return -1 +++0.0; -1 ++++ -1 +++} -1 double -1 result -1 = -1 0.0; -1 Iterator -1 iterator -1 = -1 this.dataset.getKeys().iterator(); -1 while -1 (iterator.hasNext()) -1 { -1 @@ -1 -2048,8 -1 +2051,10 -1 @@ -1 public -1 PiePlotState -1 initialise(Graphics2D -1 g2, -1 Rectangle2D -1 plotArea, -1 PiePlotState -1 state -1 = -1 new -1 PiePlotState(info); -1 state.setPassesRequired(2); -1 ++++ -1 +++if -1 +++(this.dataset -1 +++!= -1 +++null) -1 +++{ -1 state.setTotal(DatasetUtilities.calculatePieDatasetTotal( -1 plot.getDataset())); -1 ++++ -1 +++} -1 state.setLatestAngle(plot.getStartAngle()); -1 return -1 state; -1 -2
public -1 DefaultIntervalCategoryDataset(Comparable[] -1 seriesKeys, -1 } -1 else -1 { -1 ---- -1 ---this.seriesKeys -1 ---= -1 ---null; -1 ---- -1 ---this.categoryKeys -1 ---= -1 ---null; -1 ++++ -1 +++this.seriesKeys -1 +++= -1 +++new -1 +++Comparable[0]; -1 ++++ -1 +++this.categoryKeys -1 +++= -1 +++new -1 +++Comparable[0]; -1 } -1 } -1 @@ -1 -335,7 -1 +335,7 -1 @@ -1 public -1 void -1 setCategoryKeys(Comparable[] -1 categoryKeys) -1 { -1 if -1 (categoryKeys -1 == -1 null) -1 { -1 throw -1 new -1 IllegalArgumentException("Null -1 'categoryKeys' -1 argument."); -1 } -1 ---- -1 ---if -1 ---(categoryKeys.length -1 ---!= -1 ---this.startData[0].length) -1 ---{ -1 ++++ -1 +++if -1 +++(categoryKeys.length -1 +++!= -1 +++getCategoryCount()) -1 +++{ -1 throw -1 new -1 IllegalArgumentException( -1 "The -1 number -1 of -1 categories -1 does -1 not -1 match -1 the -1 data."); -1 } -1 -2
public -1 void -1 delete(int -1 start, -1 int -1 end) -1 { -1 * -1 subclasses -1 may -1 differ. -1 */ -1 public -1 Object -1 clone() -1 throws -1 CloneNotSupportedException -1 { -1 ---- -1 ---Object -1 ---clone -1 ---= -1 ---createCopy(0, -1 ---getItemCount() -1 ---- -1 ---1); -1 ++++ -1 +++TimeSeries -1 +++clone -1 +++= -1 +++(TimeSeries) -1 +++super.clone(); -1 ++++ -1 +++clone.data -1 +++= -1 +++(List) -1 +++ObjectUtilities.deepClone(this.data); -1 return -1 clone; -1 } -1 -2
public -1 ValueMarker(double -1 value, -1 Paint -1 paint, -1 Stroke -1 stroke) -1 { -1 */ -1 public -1 ValueMarker(double -1 value, -1 Paint -1 paint, -1 Stroke -1 stroke, -1 Paint -1 outlinePaint, -1 Stroke -1 outlineStroke, -1 float -1 alpha) -1 { -1 ---- -1 ---super(paint, -1 ---stroke, -1 ---paint, -1 ---stroke, -1 ---alpha); -1 ++++ -1 +++super(paint, -1 +++stroke, -1 +++outlinePaint, -1 +++outlineStroke, -1 +++alpha); -1 this.value -1 = -1 value; -1 } -1 -2
public -1 void -1 setDomainAxes(CategoryAxis[] -1 axes) -1 { -1 * -1 @since -1 1.0.3 -1 */ -1 public -1 int -1 getDomainAxisIndex(CategoryAxis -1 axis) -1 { -1 ++++ -1 +++if -1 +++(axis -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Null -1 +++'axis' -1 +++argument."); -1 ++++ -1 +++} -1 return -1 this.domainAxes.indexOf(axis); -1 } -1 @@ -1 -970,6 -1 +973,9 -1 @@ -1 public -1 void -1 setRangeAxes(ValueAxis[] -1 axes) -1 { -1 * -1 @since -1 1.0.7 -1 */ -1 public -1 int -1 getRangeAxisIndex(ValueAxis -1 axis) -1 { -1 ++++ -1 +++if -1 +++(axis -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Null -1 +++'axis' -1 +++argument."); -1 ++++ -1 +++} -1 int -1 result -1 = -1 this.rangeAxes.indexOf(axis); -1 if -1 (result -1 < -1 0) -1 { -1 // -1 try -1 the -1 parent -1 plot -1 Plot -1 parent -1 = -1 getParent(); -1 -2
public -1 Object -1 getObject(Comparable -1 rowKey, -1 Comparable -1 columnKey) -1 { -1 throw -1 new -1 UnknownKeyException("Column -1 key -1 (" -1 + -1 columnKey -1 + -1 ") -1 not -1 recognised."); -1 } -1 ---- -1 ---if -1 ---(row -1 --->= -1 ---0) -1 ---{ -1 KeyedObjects -1 rowData -1 = -1 (KeyedObjects) -1 this.rows.get(row); -1 ---- -1 ---return -1 ---rowData.getObject(columnKey); -1 ++++ -1 +++int -1 +++index -1 +++= -1 +++rowData.getIndex(columnKey); -1 ++++ -1 +++if -1 +++(index -1 +++>= -1 +++0) -1 +++{ -1 ++++ -1 +++return -1 +++rowData.getObject(index); -1 } -1 else -1 { -1 return -1 null; -1 @@ -1 -315,8 -1 +316,29 -1 @@ -1 public -1 void -1 removeObject(Comparable -1 rowKey, -1 Comparable -1 columnKey) -1 { -1 } -1 // -1 2. -1 check -1 whether -1 the -1 column -1 is -1 now -1 empty. -1 ++++ -1 +++allNull -1 +++= -1 +++true; -1 ++++ -1 +++for -1 +++(int -1 +++item -1 +++= -1 +++0, -1 +++itemCount -1 +++= -1 +++this.rows.size(); -1 +++item -1 +++< -1 +++itemCount; -1 ++++ -1 +++item++) -1 +++{ -1 ++++ -1 +++row -1 +++= -1 +++(KeyedObjects) -1 +++this.rows.get(item); -1 ++++ -1 +++int -1 +++columnIndex -1 +++= -1 +++row.getIndex(columnKey); -1 ++++ -1 +++if -1 +++(columnIndex -1 +++>= -1 +++0 -1 +++&& -1 +++row.getObject(columnIndex) -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++allNull -1 +++= -1 +++false; -1 ++++ -1 +++break; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(allNull) -1 +++{ -1 ++++ -1 +++for -1 +++(int -1 +++item -1 +++= -1 +++0, -1 +++itemCount -1 +++= -1 +++this.rows.size(); -1 +++item -1 +++< -1 +++itemCount; -1 ++++ -1 +++item++) -1 +++{ -1 ++++ -1 +++row -1 +++= -1 +++(KeyedObjects) -1 +++this.rows.get(item); -1 ++++ -1 +++int -1 +++columnIndex -1 +++= -1 +++row.getIndex(columnKey); -1 ++++ -1 +++if -1 +++(columnIndex -1 +++>= -1 +++0) -1 +++{ -1 ++++ -1 +++row.removeValue(columnIndex); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++this.columnKeys.remove(columnKey); -1 ++++ -1 +++} -1 } -1 /** -1 @@ -1 -342,6 -1 +364,10 -1 @@ -1 public -1 void -1 removeRow(int -1 rowIndex) -1 { -1 */ -1 public -1 void -1 removeRow(Comparable -1 rowKey) -1 { -1 int -1 index -1 = -1 getRowIndex(rowKey); -1 ++++ -1 +++if -1 +++(index -1 +++< -1 +++0) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++UnknownKeyException("Row -1 +++key -1 +++(" -1 ++++ -1 +++rowKey -1 ++++ -1 ++++ -1 +++") -1 +++not -1 +++recognised."); -1 ++++ -1 +++} -1 removeRow(index); -1 } -1 @@ -1 -375,7 -1 +401,10 -1 @@ -1 public -1 void -1 removeColumn(Comparable -1 columnKey) -1 { -1 Iterator -1 iterator -1 = -1 this.rows.iterator(); -1 while -1 (iterator.hasNext()) -1 { -1 KeyedObjects -1 rowData -1 = -1 (KeyedObjects) -1 iterator.next(); -1 ---- -1 ---rowData.removeValue(columnKey); -1 ++++ -1 +++int -1 +++i -1 +++= -1 +++rowData.getIndex(columnKey); -1 ++++ -1 +++if -1 +++(i -1 +++>= -1 +++0) -1 +++{ -1 ++++ -1 +++rowData.removeValue(i); -1 ++++ -1 +++} -1 } -1 this.columnKeys.remove(columnKey); -1 } -1 -2
else -1 if -1 (edge -1 == -1 RectangleEdge.RIGHT) -1 { -1 } -1 if -1 (plotState -1 != -1 null -1 && -1 hotspot -1 != -1 null) -1 { -1 ChartRenderingInfo -1 owner -1 = -1 plotState.getOwner(); -1 ++++ -1 +++if -1 +++(owner -1 +++!= -1 +++null) -1 +++{ -1 EntityCollection -1 entities -1 = -1 owner.getEntityCollection(); -1 if -1 (entities -1 != -1 null) -1 { -1 entities.add(new -1 AxisLabelEntity(this, -1 hotspot, -1 this.labelToolTip, -1 this.labelURL)); -1 } -1 ++++ -1 +++} -1 } -1 return -1 state; -1 -2
protected -1 void -1 drawHorizontalItem(Graphics2D -1 g2, -1 // -1 BAR -1 X -1 Number -1 meanValue -1 = -1 dataset.getMeanValue(row, -1 column); -1 ++++ -1 +++if -1 +++(meanValue -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++return; -1 ++++ -1 +++} -1 double -1 value -1 = -1 meanValue.doubleValue(); -1 double -1 base -1 = -1 0.0; -1 @@ -1 -312,7 -1 +315,9 -1 @@ -1 else -1 if -1 (lclip -1 <= -1 0.0) -1 { -1 // -1 cases -1 5, -1 6, -1 7 -1 and -1 8 -1 } -1 // -1 standard -1 deviation -1 lines -1 ---- -1 ---double -1 ---valueDelta -1 ---= -1 ---dataset.getStdDevValue(row, -1 ---column).doubleValue(); -1 ++++ -1 +++Number -1 +++n -1 +++= -1 +++dataset.getStdDevValue(row, -1 +++column); -1 ++++ -1 +++if -1 +++(n -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++double -1 +++valueDelta -1 +++= -1 +++n.doubleValue(); -1 double -1 highVal -1 = -1 rangeAxis.valueToJava2D(meanValue.doubleValue() -1 + -1 valueDelta, -1 dataArea, -1 yAxisLocation); -1 double -1 lowVal -1 = -1 rangeAxis.valueToJava2D(meanValue.doubleValue() -1 @@ -1 -341,6 -1 +346,7 -1 @@ -1 else -1 if -1 (lclip -1 <= -1 0.0) -1 { -1 // -1 cases -1 5, -1 6, -1 7 -1 and -1 8 -1 line -1 = -1 new -1 Line2D.Double(lowVal, -1 rectY -1 + -1 rectHeight -1 * -1 0.25, -1 lowVal, -1 rectY -1 + -1 rectHeight -1 * -1 0.75); -1 g2.draw(line); -1 ++++ -1 +++} -1 CategoryItemLabelGenerator -1 generator -1 = -1 getItemLabelGenerator(row, -1 column); -1 @@ -1 -400,6 -1 +406,9 -1 @@ -1 protected -1 void -1 drawVerticalItem(Graphics2D -1 g2, -1 // -1 BAR -1 Y -1 Number -1 meanValue -1 = -1 dataset.getMeanValue(row, -1 column); -1 ++++ -1 +++if -1 +++(meanValue -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++return; -1 ++++ -1 +++} -1 double -1 value -1 = -1 meanValue.doubleValue(); -1 double -1 base -1 = -1 0.0; -1 @@ -1 -456,7 -1 +465,9 -1 @@ -1 else -1 if -1 (lclip -1 <= -1 0.0) -1 { -1 // -1 cases -1 5, -1 6, -1 7 -1 and -1 8 -1 } -1 // -1 standard -1 deviation -1 lines -1 ---- -1 ---double -1 ---valueDelta -1 ---= -1 ---dataset.getStdDevValue(row, -1 ---column).doubleValue(); -1 ++++ -1 +++Number -1 +++n -1 +++= -1 +++dataset.getStdDevValue(row, -1 +++column); -1 ++++ -1 +++if -1 +++(n -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++double -1 +++valueDelta -1 +++= -1 +++n.doubleValue(); -1 double -1 highVal -1 = -1 rangeAxis.valueToJava2D(meanValue.doubleValue() -1 + -1 valueDelta, -1 dataArea, -1 yAxisLocation); -1 double -1 lowVal -1 = -1 rangeAxis.valueToJava2D(meanValue.doubleValue() -1 @@ -1 -484,6 -1 +495,7 -1 @@ -1 else -1 if -1 (lclip -1 <= -1 0.0) -1 { -1 // -1 cases -1 5, -1 6, -1 7 -1 and -1 8 -1 line -1 = -1 new -1 Line2D.Double(rectX -1 + -1 rectWidth -1 / -1 2.0d -1 - -1 5.0d, -1 lowVal, -1 rectX -1 + -1 rectWidth -1 / -1 2.0d -1 + -1 5.0d, -1 lowVal); -1 g2.draw(line); -1 ++++ -1 +++} -1 CategoryItemLabelGenerator -1 generator -1 = -1 getItemLabelGenerator(row, -1 column); -1 -2
public -1 void -1 drawItem(Graphics2D -1 g2, -1 CategoryItemRendererState -1 state, -1 * -1 * -1 @since -1 1.0.7 -1 */ -1 ++++ -1 +++public -1 +++boolean -1 +++equals(Object -1 +++obj) -1 +++{ -1 ++++ -1 +++if -1 +++(obj -1 +++== -1 +++this) -1 +++{ -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(!(obj -1 +++instanceof -1 +++MinMaxCategoryRenderer)) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++MinMaxCategoryRenderer -1 +++that -1 +++= -1 +++(MinMaxCategoryRenderer) -1 +++obj; -1 ++++ -1 +++if -1 +++(this.plotLines -1 +++!= -1 +++that.plotLines) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(!PaintUtilities.equal(this.groupPaint, -1 +++that.groupPaint)) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(!this.groupStroke.equals(that.groupStroke)) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++super.equals(obj); -1 ++++ -1 +++} -1 /** -1 * -1 Returns -1 an -1 icon. -1 -2
public -1 double -1 getUpperBound() -1 { -1 public -1 Paint -1 getPaint(double -1 value) -1 { -1 double -1 v -1 = -1 Math.max(value, -1 this.lowerBound); -1 v -1 = -1 Math.min(v, -1 this.upperBound); -1 ---- -1 ---int -1 ---g -1 ---= -1 ---(int) -1 ---((value -1 ---- -1 ---this.lowerBound) -1 ---/ -1 ---(this.upperBound -1 ++++ -1 +++int -1 +++g -1 +++= -1 +++(int) -1 +++((v -1 +++- -1 +++this.lowerBound) -1 +++/ -1 +++(this.upperBound -1 - -1 this.lowerBound) -1 * -1 255.0); -1 return -1 new -1 Color(g, -1 g, -1 g); -1 } -1 -2
public -1 void -1 enterScope(NodeTraversal -1 t) -1 { -1 reachingUses -1 = -1 new -1 MaybeReachingVariableUse(cfg, -1 t.getScope(), -1 compiler); -1 reachingUses.analyze(); -1 for -1 (Candidate -1 c -1 : -1 candidates) -1 { -1 ---- -1 ---if -1 ---(c.canInline()) -1 ---{ -1 ++++ -1 +++if -1 +++(c.canInline(t.getScope())) -1 +++{ -1 c.inlineVariable(); -1 // -1 If -1 definition -1 c -1 has -1 dependencies, -1 then -1 inlining -1 it -1 may -1 have -1 @@ -1 -277,7 -1 +277,7 -1 @@ -1 private -1 Node -1 getDefCfgNode() -1 { -1 return -1 defMetadata.node; -1 } -1 ---- -1 ---private -1 ---boolean -1 ---canInline() -1 ---{ -1 ++++ -1 +++private -1 +++boolean -1 +++canInline(final -1 +++Scope -1 +++scope) -1 +++{ -1 // -1 Cannot -1 inline -1 a -1 parameter. -1 if -1 (getDefCfgNode().isFunction()) -1 { -1 return -1 false; -1 @@ -1 -372,6 -1 +372,12 -1 @@ -1 public -1 boolean -1 apply(Node -1 input) -1 { -1 case -1 Token.REGEXP: -1 case -1 Token.NEW: -1 return -1 true; -1 ++++ -1 +++case -1 +++Token.NAME: -1 ++++ -1 +++Var -1 +++var -1 +++= -1 +++scope.getOwnSlot(input.getString()); -1 ++++ -1 +++if -1 +++(var -1 +++!= -1 +++null -1 ++++ -1 +++&& -1 +++var.getParentNode().isCatch()) -1 +++{ -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 } -1 return -1 false; -1 } -1 -2
public -1 JSType -1 caseNumberType() -1 { -1 public -1 JSType -1 caseObjectType(ObjectType -1 type) -1 { -1 if -1 (value.equals("function")) -1 { -1 JSType -1 ctorType -1 = -1 getNativeType(U2U_CONSTRUCTOR_TYPE); -1 ---- -1 ---return -1 ---resultEqualsValue -1 ---&& -1 ---ctorType.isSubtype(type) -1 ---? -1 ---ctorType -1 ---: -1 ---null; -1 ++++ -1 +++if -1 +++(resultEqualsValue) -1 +++{ -1 // -1 Objects -1 are -1 restricted -1 to -1 "Function", -1 subtypes -1 are -1 left -1 ++++ -1 +++return -1 +++ctorType.getGreatestSubtype(type); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 // -1 Only -1 filter -1 out -1 subtypes -1 of -1 "function" -1 ++++ -1 +++return -1 +++type.isSubtype(ctorType) -1 +++? -1 +++null -1 +++: -1 +++type; -1 ++++ -1 +++} -1 } -1 return -1 matchesExpectation("object") -1 ? -1 type -1 : -1 null; -1 } -1 -2
private -1 boolean -1 isInlinableObject(List<Reference> -1 refs) -1 { -1 // -1 Deleting -1 a -1 property -1 has -1 different -1 semantics -1 from -1 deleting -1 // -1 a -1 variable, -1 so -1 deleted -1 properties -1 should -1 not -1 be -1 inlined. -1 ++++ -1 +++if -1 +++(gramps.isDelProp()) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 // -1 NOTE(nicksantos): -1 This -1 pass's -1 object-splitting -1 algorithm -1 has -1 // -1 a -1 blind -1 spot. -1 It -1 assumes -1 that -1 if -1 a -1 property -1 isn't -1 defined -1 on -1 an -1 -2
boolean -1 expectCanAssignToPropertyOf(NodeTraversal -1 t, -1 Node -1 n, -1 JSType -1 rightType, -1 JSType -1 leftType, -1 Node -1 owner, -1 String -1 propName) -1 { -1 // -1 The -1 NoType -1 check -1 is -1 a -1 hack -1 to -1 make -1 typedefs -1 work -1 OK. -1 if -1 (!leftType.isNoType() -1 && -1 !rightType.canAssignTo(leftType)) -1 { -1 ---- -1 ---if -1 ---((leftType.isConstructor() -1 ---|| -1 ---leftType.isEnumType()) -1 ---&& -1 ---(rightType.isConstructor() -1 ---|| -1 ---rightType.isEnumType())) -1 ---{ -1 ---- -1 ---registerMismatch(rightType, -1 ---leftType, -1 ---null); -1 ---- -1 ---} -1 ---else -1 ---{ -1 // -1 Do -1 not -1 type-check -1 interface -1 methods, -1 because -1 we -1 expect -1 that -1 // -1 they -1 will -1 have -1 dummy -1 implementations -1 that -1 do -1 not -1 match -1 the -1 type -1 // -1 annotations. -1 @@ -1 -382,7 -1 +379,6 -1 @@ -1 boolean -1 expectCanAssignToPropertyOf(NodeTraversal -1 t, -1 Node -1 n, -1 JSType -1 rightType, -1 "assignment -1 to -1 property -1 " -1 + -1 propName -1 + -1 " -1 of -1 " -1 + -1 getReadableJSTypeName(owner, -1 true), -1 rightType, -1 leftType); -1 ---- -1 ---} -1 return -1 false; -1 } -1 return -1 true; -1 @@ -1 -402,11 -1 +398,7 -1 @@ -1 boolean -1 expectCanAssignToPropertyOf(NodeTraversal -1 t, -1 Node -1 n, -1 JSType -1 rightType, -1 boolean -1 expectCanAssignTo(NodeTraversal -1 t, -1 Node -1 n, -1 JSType -1 rightType, -1 JSType -1 leftType, -1 String -1 msg) -1 { -1 if -1 (!rightType.canAssignTo(leftType)) -1 { -1 ---- -1 ---if -1 ---((leftType.isConstructor() -1 ---|| -1 ---leftType.isEnumType()) -1 ---&& -1 ---(rightType.isConstructor() -1 ---|| -1 ---rightType.isEnumType())) -1 ---{ -1 ---- -1 ---registerMismatch(rightType, -1 ---leftType, -1 ---null); -1 ---- -1 ---} -1 ---else -1 ---{ -1 mismatch(t, -1 n, -1 msg, -1 rightType, -1 leftType); -1 ---- -1 ---} -1 return -1 false; -1 } -1 return -1 true; -1 -2
private -1 void -1 checkInterfaceConflictProperties(NodeTraversal -1 t, -1 Node -1 n, -1 ObjectType -1 interfaceType) -1 { -1 ObjectType -1 implicitProto -1 = -1 interfaceType.getImplicitPrototype(); -1 Set<String> -1 currentPropertyNames; -1 ++++ -1 +++if -1 +++(implicitProto -1 +++== -1 +++null) -1 +++{ -1 // -1 This -1 can -1 be -1 the -1 case -1 if -1 interfaceType -1 is -1 proxy -1 to -1 a -1 non-existent -1 // -1 object -1 (which -1 is -1 a -1 bad -1 type -1 annotation, -1 but -1 shouldn't -1 crash). -1 ++++ -1 +++currentPropertyNames -1 +++= -1 +++ImmutableSet.of(); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 currentPropertyNames -1 = -1 implicitProto.getOwnPropertyNames(); -1 ++++ -1 +++} -1 for -1 (String -1 name -1 : -1 currentPropertyNames) -1 { -1 ObjectType -1 oType -1 = -1 properties.get(name); -1 if -1 (oType -1 != -1 null) -1 { -1 -2
private -1 void -1 removeUnreferencedFunctionArgs(Scope -1 fnScope) -1 { -1 // -1 is -1 removing -1 globals, -1 then -1 it's -1 OK -1 to -1 remove -1 unused -1 function -1 args. -1 // -1 // -1 See -1 http://code.google.com/p/closure-compiler/issues/detail?id=253 -1 ++++ -1 +++if -1 +++(!removeGlobals) -1 +++{ -1 ++++ -1 +++return; -1 ++++ -1 +++} -1 Node -1 function -1 = -1 fnScope.getRootNode(); -1 -2
JSType -1 resolveInternal(ErrorReporter -1 t, -1 StaticScope<JSType> -1 enclosing) -1 { -1 // -1 makes -1 more -1 sense. -1 Now, -1 resolution -1 via -1 registry -1 is -1 first -1 in -1 order -1 to -1 // -1 avoid -1 triggering -1 the -1 warnings -1 built -1 into -1 the -1 resolution -1 via -1 properties. -1 boolean -1 resolved -1 = -1 resolveViaRegistry(t, -1 enclosing); -1 ---- -1 ---if -1 ---(detectImplicitPrototypeCycle()) -1 ---{ -1 ++++ -1 +++if -1 +++(detectInheritanceCycle()) -1 +++{ -1 handleTypeCycle(t); -1 } -1 @@ -1 -199,7 -1 +199,7 -1 @@ -1 JSType -1 resolveInternal(ErrorReporter -1 t, -1 StaticScope<JSType> -1 enclosing) -1 { -1 } -1 resolveViaProperties(t, -1 enclosing); -1 ---- -1 ---if -1 ---(detectImplicitPrototypeCycle()) -1 ---{ -1 ++++ -1 +++if -1 +++(detectInheritanceCycle()) -1 +++{ -1 handleTypeCycle(t); -1 } -1 -2
private -1 boolean -1 canBeRedeclared(Node -1 n, -1 Scope -1 s) -1 { -1 Var -1 var -1 = -1 s.getVar(lhs.getString()); -1 return -1 var -1 != -1 null -1 && -1 var.getScope() -1 == -1 s -1 ++++ -1 +++&& -1 +++!isNamedParameter(var) -1 && -1 !blacklistedVars.contains(var); -1 } -1 } -1 ++++ -1 +++private -1 +++boolean -1 +++isNamedParameter(Var -1 +++v) -1 +++{ -1 ++++ -1 +++return -1 +++v.getParentNode().isParamList(); -1 ++++ -1 +++} -1 private -1 void -1 applyCollapses() -1 { -1 for -1 (Collapse -1 collapse -1 : -1 collapses) -1 { -1 -2
public -1 static -1 String -1 toModuleName(String -1 requiredFilename, -1 private -1 String -1 normalizeSourceName(String -1 filename) -1 { -1 // -1 The -1 DOS -1 command -1 shell -1 will -1 normalize -1 "/" -1 to -1 "\", -1 so -1 we -1 have -1 to -1 // -1 wrestle -1 it -1 back. -1 ++++ -1 +++filename -1 +++= -1 +++filename.replace("\\", -1 +++"/"); -1 if -1 (filename.indexOf(filenamePrefix) -1 == -1 0) -1 { -1 filename -1 = -1 filename.substring(filenamePrefix.length()); -1 @@ -1 -180,7 -1 +181,7 -1 @@ -1 private -1 void -1 visitScript(NodeTraversal -1 t, -1 Node -1 script) -1 { -1 Preconditions.checkArgument(scriptNodeCount -1 == -1 1, -1 "ProcessCommonJSModules -1 supports -1 only -1 one -1 invocation -1 per -1 " -1 + -1 "CompilerInput -1 / -1 script -1 node"); -1 ---- -1 ---String -1 ---moduleName -1 ---= -1 ---guessCJSModuleName(normalizeSourceName(script.getSourceFileName())); -1 ++++ -1 +++String -1 +++moduleName -1 +++= -1 +++guessCJSModuleName(script.getSourceFileName()); -1 script.addChildToFront(IR.var(IR.name(moduleName), -1 IR.objectlit()) -1 .copyInformationFromForTree(script)); -1 if -1 (reportDependencies) -1 { -1 -2
private -1 void -1 visitGetProp(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 if -1 (childType.isDict()) -1 { -1 report(t, -1 property, -1 TypeValidator.ILLEGAL_PROPERTY_ACCESS, -1 "'.'", -1 "dict"); -1 ---- -1 ---} -1 ---else -1 ---if -1 ---(n.getJSType() -1 ---!= -1 ---null -1 ---&& -1 ---parent.isAssign()) -1 ---{ -1 ---- -1 ---return; -1 } -1 else -1 if -1 (validator.expectNotNullOrUndefined(t, -1 n, -1 childType, -1 "No -1 properties -1 on -1 this -1 expression", -1 getNativeType(OBJECT_TYPE))) -1 { -1 checkPropertyAccess(childType, -1 property.getString(), -1 t, -1 n); -1 -2
ReachingUses -1 flowThrough(Node -1 n, -1 ReachingUses -1 input) -1 { -1 } -1 private -1 boolean -1 hasExceptionHandler(Node -1 cfgNode) -1 { -1 ++++ -1 +++List<DiGraphEdge<Node, -1 +++Branch>> -1 +++branchEdges -1 +++= -1 +++getCfg().getOutEdges(cfgNode); -1 ++++ -1 +++for -1 +++(DiGraphEdge<Node, -1 +++Branch> -1 +++edge -1 +++: -1 +++branchEdges) -1 +++{ -1 ++++ -1 +++if -1 +++(edge.getValue() -1 +++== -1 +++Branch.ON_EX) -1 +++{ -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 return -1 false; -1 } -1 -2
static -1 boolean -1 mayBeString(Node -1 n) -1 { -1 static -1 boolean -1 mayBeString(Node -1 n, -1 boolean -1 recurse) -1 { -1 if -1 (recurse) -1 { -1 ---- -1 ---return -1 ---allResultsMatch(n, -1 ---MAY_BE_STRING_PREDICATE); -1 ++++ -1 +++return -1 +++anyResultsMatch(n, -1 +++MAY_BE_STRING_PREDICATE); -1 } -1 else -1 { -1 return -1 mayBeStringHelper(n); -1 } -1 -2
private -1 static -1 Node -1 computeFollowNode( -1 } -1 else -1 if -1 (parent.getLastChild() -1 == -1 node){ -1 if -1 (cfa -1 != -1 null) -1 { -1 for -1 (Node -1 finallyNode -1 : -1 cfa.finallyMap.get(parent)) -1 { -1 ---- -1 ---cfa.createEdge(fromNode, -1 ---Branch.UNCOND, -1 ---finallyNode); -1 ++++ -1 +++cfa.createEdge(fromNode, -1 +++Branch.ON_EX, -1 +++finallyNode); -1 } -1 } -1 return -1 computeFollowNode(fromNode, -1 parent, -1 cfa); -1 -2
private -1 JSType -1 getDeclaredType(String -1 sourceName, -1 JSDocInfo -1 info, -1 if -1 (info.isConstant()) -1 { -1 JSType -1 knownType -1 = -1 null; -1 if -1 (rValue -1 != -1 null) -1 { -1 ---- -1 ---if -1 ---(rValue.getJSType() -1 ---!= -1 ---null -1 ---&& -1 ---!rValue.getJSType().isUnknownType()) -1 ---{ -1 ++++ -1 +++JSDocInfo -1 +++rValueInfo -1 +++= -1 +++rValue.getJSDocInfo(); -1 ++++ -1 +++if -1 +++(rValueInfo -1 +++!= -1 +++null -1 +++&& -1 +++rValueInfo.hasType()) -1 +++{ -1 // -1 If -1 rValue -1 has -1 a -1 type-cast, -1 we -1 use -1 the -1 type -1 in -1 the -1 type-cast. -1 ++++ -1 +++return -1 +++rValueInfo.getType().evaluate(scope, -1 +++typeRegistry); -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(rValue.getJSType() -1 +++!= -1 +++null -1 ++++ -1 +++&& -1 +++!rValue.getJSType().isUnknownType()) -1 +++{ -1 // -1 If -1 rValue's -1 type -1 was -1 already -1 computed -1 during -1 scope -1 creation, -1 // -1 then -1 we -1 can -1 safely -1 use -1 that. -1 return -1 rValue.getJSType(); -1 -2
private -1 void -1 traverse(Node -1 node) -1 { -1 do -1 { -1 Node -1 c -1 = -1 node.getFirstChild(); -1 while(c -1 != -1 null) -1 { -1 ---- -1 ---traverse(c); -1 Node -1 next -1 = -1 c.getNext(); -1 ++++ -1 +++traverse(c); -1 c -1 = -1 next; -1 } -1 -2
public -1 void -1 visit(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 // -1 Do -1 not -1 try -1 to -1 remove -1 a -1 block -1 or -1 an -1 expr -1 result. -1 We -1 already -1 handle -1 // -1 these -1 cases -1 when -1 we -1 visit -1 the -1 child, -1 and -1 the -1 peephole -1 passes -1 will -1 // -1 fix -1 up -1 the -1 tree -1 in -1 more -1 clever -1 ways -1 when -1 these -1 are -1 removed. -1 ---- -1 ---if -1 ---(n.isExprResult()) -1 ---{ -1 ++++ -1 +++if -1 +++(n.isExprResult() -1 +++|| -1 +++n.isBlock()) -1 +++{ -1 return; -1 } -1 @@ -1 -110,24 -1 +110,7 -1 @@ -1 public -1 void -1 visit(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 boolean -1 isResultUsed -1 = -1 NodeUtil.isExpressionResultUsed(n); -1 boolean -1 isSimpleOp -1 = -1 NodeUtil.isSimpleOperatorType(n.getType()); -1 ---- -1 ---if -1 ---(parent.getType() -1 ---== -1 ---Token.COMMA) -1 ---{ -1 ---- -1 ---if -1 ---(isResultUsed) -1 ---{ -1 ---- -1 ---return; -1 ---- -1 ---} -1 ---- -1 ---if -1 ---(n -1 ---== -1 ---parent.getLastChild()) -1 ---{ -1 ---- -1 ---for -1 ---(Node -1 ---an -1 ---: -1 ---parent.getAncestors()) -1 ---{ -1 ---- -1 ---int -1 ---ancestorType -1 ---= -1 ---an.getType(); -1 ---- -1 ---if -1 ---(ancestorType -1 ---== -1 ---Token.COMMA) -1 ---continue; -1 ---- -1 ---if -1 ---(ancestorType -1 ---!= -1 ---Token.EXPR_RESULT -1 ---&& -1 ---ancestorType -1 ---!= -1 ---Token.BLOCK) -1 ---return; -1 ---- -1 ---else -1 ---break; -1 ---- -1 ---} -1 ---- -1 ---} -1 ---- -1 ---} -1 ---else -1 ---if -1 ---(parent.getType() -1 ---!= -1 ---Token.EXPR_RESULT -1 ---&& -1 ---parent.getType() -1 ---!= -1 ---Token.BLOCK) -1 ---{ -1 ---- -1 ---if -1 ---(! -1 ---(parent.getType() -1 ---== -1 ---Token.FOR -1 ---&& -1 ---parent.getChildCount() -1 ---== -1 ---4 -1 ---&& -1 ---(n -1 ---== -1 ---parent.getFirstChild() -1 ---|| -1 ---n -1 ---== -1 ---parent.getFirstChild().getNext().getNext()))) -1 ---{ -1 ---- -1 ---return; -1 ---- -1 ---} -1 ---- -1 ---} -1 ---- -1 ---if -1 ---( -1 ++++ -1 +++if -1 +++(!isResultUsed -1 +++&& -1 (isSimpleOp -1 || -1 !NodeUtil.mayHaveSideEffects(n, -1 t.getCompiler()))) -1 { -1 String -1 msg -1 = -1 "This -1 code -1 lacks -1 side-effects. -1 Is -1 there -1 a -1 bug?"; -1 if -1 (n.isString()) -1 { -1 -2
public -1 boolean -1 apply(Node -1 n) -1 { -1 return -1 true; -1 } -1 ++++ -1 +++if -1 +++(n.isDelProp()) -1 +++{ -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 for -1 (Node -1 c -1 = -1 n.getFirstChild(); -1 c -1 != -1 null; -1 c -1 = -1 c.getNext()) -1 { -1 if -1 (!ControlFlowGraph.isEnteringNewCfgNode(c) -1 && -1 apply(c)) -1 { -1 -2
public -1 void -1 applyAlias() -1 { -1 private -1 class -1 AliasedTypeNode -1 implements -1 AliasUsage -1 { -1 private -1 final -1 Node -1 typeReference; -1 ++++ -1 +++private -1 +++final -1 +++Node -1 +++aliasDefinition; -1 private -1 final -1 String -1 aliasName; -1 ---- -1 ---AliasedTypeNode(Node -1 ---typeReference, -1 ++++ -1 +++AliasedTypeNode(Node -1 +++typeReference, -1 +++Node -1 +++aliasDefinition, -1 String -1 aliasName) -1 { -1 this.typeReference -1 = -1 typeReference; -1 ++++ -1 +++this.aliasDefinition -1 +++= -1 +++aliasDefinition; -1 this.aliasName -1 = -1 aliasName; -1 } -1 @Override -1 public -1 void -1 applyAlias() -1 { -1 ---- -1 ---typeReference.setString(aliasName); -1 ++++ -1 +++String -1 +++typeName -1 +++= -1 +++typeReference.getString(); -1 ++++ -1 +++String -1 +++aliasExpanded -1 +++= -1 ++++ -1 +++Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); -1 ++++ -1 +++Preconditions.checkState(typeName.startsWith(aliasName)); -1 ++++ -1 +++typeReference.setString(typeName.replaceFirst(aliasName, -1 +++aliasExpanded)); -1 } -1 } -1 @@ -1 -465,7 -1 +471,7 -1 @@ -1 private -1 void -1 fixTypeNode(Node -1 typeNode) -1 { -1 Var -1 aliasVar -1 = -1 aliases.get(baseName); -1 if -1 (aliasVar -1 != -1 null) -1 { -1 Node -1 aliasedNode -1 = -1 aliasVar.getInitialValue(); -1 ---- -1 ---aliasUsages.add(new -1 ---AliasedTypeNode(typeNode, -1 ---aliasedNode.getQualifiedName() -1 ---+ -1 ---name.substring(endIndex))); -1 ++++ -1 +++aliasUsages.add(new -1 +++AliasedTypeNode(typeNode, -1 +++aliasedNode, -1 +++baseName)); -1 } -1 } -1 -2
Node -1 parseInputs() -1 { -1 // -1 Check -1 if -1 the -1 sources -1 need -1 to -1 be -1 re-ordered. -1 boolean -1 staleInputs -1 = -1 false; -1 ---- -1 ---if -1 ---(options.dependencyOptions.needsManagement() -1 ---&& -1 ---options.closurePass) -1 ---{ -1 ++++ -1 +++if -1 +++(options.dependencyOptions.needsManagement()) -1 +++{ -1 for -1 (CompilerInput -1 input -1 : -1 inputs) -1 { -1 // -1 Forward-declare -1 all -1 the -1 provided -1 types, -1 so -1 that -1 they -1 // -1 are -1 not -1 flagged -1 even -1 if -1 they -1 are -1 dropped -1 from -1 the -1 process. -1 -2
private -1 Node -1 tryFoldSimpleFunctionCall(Node -1 n) -1 { -1 // -1 slightly -1 different -1 semantics -1 than -1 '' -1 + -1 (a). -1 See -1 // -1 http://code.google.com/p/closure-compiler/issues/detail?id=759 -1 Node -1 value -1 = -1 callTarget.getNext(); -1 ---- -1 ---if -1 ---(value -1 ---!= -1 ---null) -1 ---{ -1 ++++ -1 +++if -1 +++(value -1 +++!= -1 +++null -1 +++&& -1 +++value.getNext() -1 +++== -1 +++null -1 +++&& -1 ++++ -1 +++NodeUtil.isImmutableValue(value)) -1 +++{ -1 Node -1 addition -1 = -1 IR.add( -1 IR.string("").srcref(callTarget), -1 value.detachFromParent()); -1 -2
protected -1 void -1 declareNameInScope(FlowScope -1 scope, -1 Node -1 node, -1 JSType -1 type) -1 { -1 scope.inferQualifiedSlot(node, -1 qualifiedName, -1 origType, -1 type); -1 break; -1 ++++ -1 +++case -1 +++Token.THIS: -1 // -1 "this" -1 references -1 aren't -1 currently -1 modeled -1 in -1 the -1 CFG. -1 ++++ -1 +++break; -1 default: -1 throw -1 new -1 IllegalArgumentException("Node -1 cannot -1 be -1 refined. -1 \n" -1 + -1 -2
private -1 Node -1 tryFoldArrayAccess(Node -1 n, -1 Node -1 left, -1 Node -1 right) -1 { -1 Node -1 current -1 = -1 left.getFirstChild(); -1 Node -1 elem -1 = -1 null; -1 ---- -1 ---for -1 ---(int -1 ---i -1 ---= -1 ---0; -1 ---current -1 ---!= -1 ---null -1 ---&& -1 ---i -1 ---< -1 ---intIndex; -1 ---i++) -1 ---{ -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++current -1 +++!= -1 +++null; -1 +++i++) -1 +++{ -1 ++++ -1 +++if -1 +++(i -1 +++!= -1 +++intIndex) -1 +++{ -1 ++++ -1 +++if -1 +++(mayHaveSideEffects(current)) -1 +++{ -1 ++++ -1 +++return -1 +++n; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 +++else -1 +++{ -1 elem -1 = -1 current; -1 ++++ -1 +++} -1 current -1 = -1 current.getNext(); -1 } -1 -2
private -1 void -1 findAliases(NodeTraversal -1 t) -1 { -1 Node -1 n -1 = -1 v.getNode(); -1 int -1 type -1 = -1 n.getType(); -1 Node -1 parent -1 = -1 n.getParent(); -1 ---- -1 ---if -1 ---(parent.isVar()) -1 ---{ -1 ---- -1 ---if -1 ---(n.hasChildren() -1 ---&& -1 ---n.getFirstChild().isQualifiedName()) -1 ---{ -1 ++++ -1 +++if -1 +++(parent.isVar() -1 +++&& -1 ++++ -1 +++n.hasChildren() -1 +++&& -1 +++n.getFirstChild().isQualifiedName()) -1 +++{ -1 String -1 name -1 = -1 n.getString(); -1 Var -1 aliasVar -1 = -1 scope.getVar(name); -1 aliases.put(name, -1 aliasVar); -1 @@ -1 -284,15 -1 +284,16 -1 @@ -1 private -1 void -1 findAliases(NodeTraversal -1 t) -1 { -1 String -1 qualifiedName -1 = -1 aliasVar.getInitialValue().getQualifiedName(); -1 transformation.addAlias(name, -1 qualifiedName); -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(v.isBleedingFunction()) -1 +++{ -1 // -1 Bleeding -1 functions -1 already -1 get -1 a -1 BAD_PARAMETERS -1 error, -1 so -1 just -1 // -1 do -1 nothing. -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(parent.getType() -1 +++== -1 +++Token.LP) -1 +++{ -1 // -1 Parameters -1 of -1 the -1 scope -1 function -1 also -1 get -1 a -1 BAD_PARAMETERS -1 // -1 error. -1 } -1 else -1 { -1 // -1 TODO(robbyw): -1 Support -1 using -1 locals -1 for -1 private -1 variables. -1 report(t, -1 n, -1 GOOG_SCOPE_NON_ALIAS_LOCAL, -1 n.getString()); -1 } -1 ---- -1 ---} -1 } -1 } -1 -2
public -1 void -1 visit(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 // -1 Do -1 not -1 try -1 to -1 remove -1 a -1 block -1 or -1 an -1 expr -1 result. -1 We -1 already -1 handle -1 // -1 these -1 cases -1 when -1 we -1 visit -1 the -1 child, -1 and -1 the -1 peephole -1 passes -1 will -1 // -1 fix -1 up -1 the -1 tree -1 in -1 more -1 clever -1 ways -1 when -1 these -1 are -1 removed. -1 ---- -1 ---if -1 ---(parent.getType() -1 ---== -1 ---Token.COMMA) -1 ---{ -1 ---- -1 ---Node -1 ---gramps -1 ---= -1 ---parent.getParent(); -1 ---- -1 ---if -1 ---(gramps.isCall() -1 ---&& -1 ---parent -1 ---== -1 ---gramps.getFirstChild()) -1 ---{ -1 ---- -1 ---if -1 ---(n -1 ---== -1 ---parent.getFirstChild() -1 ---&& -1 ---parent.getChildCount() -1 ---== -1 ---2 -1 ---&& -1 ---n.getNext().isName() -1 ---&& -1 ---"eval".equals(n.getNext().getString())) -1 ---{ -1 ++++ -1 +++if -1 +++(n.isExprResult() -1 +++|| -1 +++n.isBlock()) -1 +++{ -1 return; -1 ---- -1 ---} -1 } -1 // -1 This -1 no-op -1 statement -1 was -1 there -1 so -1 that -1 JSDoc -1 information -1 could -1 // -1 be -1 attached -1 to -1 the -1 name. -1 This -1 check -1 should -1 not -1 complain -1 about -1 it. -1 ---- -1 ---if -1 ---(n -1 ---== -1 ---parent.getLastChild()) -1 ---{ -1 ---- -1 ---for -1 ---(Node -1 ---an -1 ---: -1 ---parent.getAncestors()) -1 ---{ -1 ---- -1 ---int -1 ---ancestorType -1 ---= -1 ---an.getType(); -1 ---- -1 ---if -1 ---(ancestorType -1 ---== -1 ---Token.COMMA) -1 ---- -1 ---continue; -1 ---- -1 ---if -1 ---(ancestorType -1 ---!= -1 ---Token.EXPR_RESULT -1 ---&& -1 ---ancestorType -1 ---!= -1 ---Token.BLOCK) -1 ---- -1 ---return; -1 ---- -1 ---else -1 ---- -1 ---break; -1 ---- -1 ---} -1 ---- -1 ---} -1 ---- -1 ---} -1 ---else -1 ---if -1 ---(parent.getType() -1 ---!= -1 ---Token.EXPR_RESULT -1 ---&& -1 ---parent.getType() -1 ---!= -1 ---Token.BLOCK) -1 ---{ -1 ---- -1 ---if -1 ---(parent.getType() -1 ---== -1 ---Token.FOR -1 ---&& -1 ---parent.getChildCount() -1 ---== -1 ---4 -1 ---&& -1 ---(n -1 ---== -1 ---parent.getFirstChild() -1 ---|| -1 ---- -1 ---n -1 ---== -1 ---parent.getFirstChild().getNext().getNext())) -1 ---{ -1 ---- -1 ---} -1 ---else -1 ---{ -1 ++++ -1 +++if -1 +++(n.isQualifiedName() -1 +++&& -1 +++n.getJSDocInfo() -1 +++!= -1 +++null) -1 +++{ -1 return; -1 ---- -1 ---} -1 } -1 boolean -1 isResultUsed -1 = -1 NodeUtil.isExpressionResultUsed(n); -1 boolean -1 isSimpleOp -1 = -1 NodeUtil.isSimpleOperatorType(n.getType()); -1 if -1 (!isResultUsed -1 && -1 (isSimpleOp -1 || -1 !NodeUtil.mayHaveSideEffects(n, -1 t.getCompiler()))) -1 { -1 ---- -1 ---if -1 ---(n.isQualifiedName() -1 ---&& -1 ---n.getJSDocInfo() -1 ---!= -1 ---null) -1 ---{ -1 ---- -1 ---return; -1 ---- -1 ---} -1 ---else -1 ---if -1 ---(n.isExprResult()) -1 ---{ -1 ---- -1 ---return; -1 ---- -1 ---} -1 String -1 msg -1 = -1 "This -1 code -1 lacks -1 side-effects. -1 Is -1 there -1 a -1 bug?"; -1 if -1 (n.isString()) -1 { -1 msg -1 = -1 "Is -1 there -1 a -1 missing -1 '+' -1 on -1 the -1 previous -1 line?"; -1 -2
private -1 String -1 normalizeSourceName(String -1 filename) -1 { -1 AbstractPostOrderCallback -1 { -1 private -1 int -1 scriptNodeCount -1 = -1 0; -1 ++++ -1 +++private -1 +++Set<String> -1 +++modulesWithExports -1 +++= -1 +++Sets.newHashSet(); -1 @Override -1 public -1 void -1 visit(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 @@ -1 -204,6 -1 +205,9 -1 @@ -1 private -1 void -1 visitScript(NodeTraversal -1 t, -1 Node -1 script) -1 { -1 */ -1 private -1 void -1 emitOptionalModuleExportsOverride(Node -1 script, -1 String -1 moduleName) -1 { -1 ++++ -1 +++if -1 +++(!modulesWithExports.contains(moduleName)) -1 +++{ -1 ++++ -1 +++return; -1 ++++ -1 +++} -1 Node -1 moduleExportsProp -1 = -1 IR.getprop(IR.name(moduleName), -1 IR.string("module$exports")); -1 @@ -1 -225,6 -1 +229,7 -1 @@ -1 private -1 void -1 visitModuleExports(Node -1 prop) -1 { -1 Node -1 exports -1 = -1 prop.getChildAtIndex(1); -1 exports.putProp(Node.ORIGINALNAME_PROP, -1 "exports"); -1 exports.setString("module$exports"); -1 ++++ -1 +++modulesWithExports.add(moduleName); -1 } -1 /** -1 -2
private -1 void -1 updateTypeOfThisOnClosure(Node -1 n, -1 FunctionType -1 fnType) -1 { -1 } -1 private -1 FlowScope -1 traverseNew(Node -1 n, -1 FlowScope -1 scope) -1 { -1 ++++ -1 +++scope -1 +++= -1 +++traverseChildren(n, -1 +++scope); -1 Node -1 constructor -1 = -1 n.getFirstChild(); -1 ---- -1 ---scope -1 ---= -1 ---traverse(constructor, -1 ---scope); -1 JSType -1 constructorType -1 = -1 constructor.getJSType(); -1 JSType -1 type -1 = -1 null; -1 if -1 (constructorType -1 != -1 null) -1 { -1 @@ -1 -1052,13 -1 +1052,11 -1 @@ -1 private -1 FlowScope -1 traverseNew(Node -1 n, -1 FlowScope -1 scope) -1 { -1 } -1 if -1 (ct -1 != -1 null -1 && -1 ct.isConstructor()) -1 { -1 type -1 = -1 ct.getInstanceType(); -1 ++++ -1 +++backwardsInferenceFromCallSite(n, -1 +++ct); -1 } -1 } -1 } -1 n.setJSType(type); -1 ---- -1 ---for -1 ---(Node -1 ---arg -1 ---= -1 ---constructor.getNext(); -1 ---arg -1 ---!= -1 ---null; -1 ---arg -1 ---= -1 ---arg.getNext()) -1 ---{ -1 ---- -1 ---scope -1 ---= -1 ---traverse(arg, -1 ---scope); -1 ---- -1 ---} -1 return -1 scope; -1 } -1 -2
public -1 static -1 Node -1 block(Node -1 ... -1 stmts) -1 { -1 return -1 block; -1 } -1 ++++ -1 +++private -1 +++static -1 +++Node -1 +++blockUnchecked(Node -1 +++stmt) -1 +++{ -1 ++++ -1 +++return -1 +++new -1 +++Node(Token.BLOCK, -1 +++stmt); -1 ++++ -1 +++} -1 public -1 static -1 Node -1 script(Node -1 ... -1 stmts) -1 { -1 // -1 TODO(johnlenz): -1 finish -1 setting -1 up -1 the -1 SCRIPT -1 node -1 @@ -1 -221,8 -1 +224,8 -1 @@ -1 public -1 static -1 Node -1 labelName(String -1 name) -1 { -1 } -1 public -1 static -1 Node -1 tryFinally(Node -1 tryBody, -1 Node -1 finallyBody) -1 { -1 ---- -1 ---Preconditions.checkState(tryBody.isLabelName()); -1 ---- -1 ---Preconditions.checkState(finallyBody.isLabelName()); -1 ++++ -1 +++Preconditions.checkState(tryBody.isBlock()); -1 ++++ -1 +++Preconditions.checkState(finallyBody.isBlock()); -1 Node -1 catchBody -1 = -1 block().copyInformationFrom(tryBody); -1 return -1 new -1 Node(Token.TRY, -1 tryBody, -1 catchBody, -1 finallyBody); -1 } -1 @@ -1 -230,7 -1 +233,7 -1 @@ -1 public -1 static -1 Node -1 tryFinally(Node -1 tryBody, -1 Node -1 finallyBody) -1 { -1 public -1 static -1 Node -1 tryCatch(Node -1 tryBody, -1 Node -1 catchNode) -1 { -1 Preconditions.checkState(tryBody.isBlock()); -1 Preconditions.checkState(catchNode.isCatch()); -1 ---- -1 ---Node -1 ---catchBody -1 ---= -1 ---block(catchNode).copyInformationFrom(catchNode); -1 ++++ -1 +++Node -1 +++catchBody -1 +++= -1 +++blockUnchecked(catchNode).copyInformationFrom(catchNode); -1 return -1 new -1 Node(Token.TRY, -1 tryBody, -1 catchBody); -1 } -1 -2
private -1 boolean -1 isVarInlineForbidden(Var -1 var) -1 { -1 */ -1 private -1 boolean -1 isInlinableObject(List<Reference> -1 refs) -1 { -1 boolean -1 ret -1 = -1 false; -1 ++++ -1 +++Set<String> -1 +++validProperties -1 +++= -1 +++Sets.newHashSet(); -1 for -1 (Reference -1 ref -1 : -1 refs) -1 { -1 Node -1 name -1 = -1 ref.getNode(); -1 Node -1 parent -1 = -1 ref.getParent(); -1 @@ -1 -178,6 -1 +179,14 -1 @@ -1 private -1 boolean -1 isInlinableObject(List<Reference> -1 refs) -1 { -1 // -1 We -1 short-circuit -1 this -1 problem -1 by -1 bailing -1 out -1 if -1 we -1 see -1 a -1 reference -1 // -1 to -1 a -1 property -1 that -1 isn't -1 defined -1 on -1 the -1 object -1 literal. -1 This -1 // -1 isn't -1 a -1 perfect -1 algorithm, -1 but -1 it -1 should -1 catch -1 most -1 cases. -1 ++++ -1 +++String -1 +++propName -1 +++= -1 +++parent.getLastChild().getString(); -1 ++++ -1 +++if -1 +++(!validProperties.contains(propName)) -1 +++{ -1 ++++ -1 +++if -1 +++(NodeUtil.isVarOrSimpleAssignLhs(parent, -1 +++gramps)) -1 +++{ -1 ++++ -1 +++validProperties.add(propName); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 continue; -1 } -1 @@ -1 -213,6 -1 +222,7 -1 @@ -1 private -1 boolean -1 isInlinableObject(List<Reference> -1 refs) -1 { -1 return -1 false; -1 } -1 ++++ -1 +++validProperties.add(child.getString()); -1 Node -1 childVal -1 = -1 child.getFirstChild(); -1 // -1 Check -1 if -1 childVal -1 is -1 the -1 parent -1 of -1 any -1 of -1 the -1 passed -1 in -1 -2
public -1 void -1 exitScope(NodeTraversal -1 t) -1 {} -1 @Override -1 public -1 void -1 process(Node -1 externs, -1 Node -1 root) -1 { -1 ---- -1 ---(new -1 ---NodeTraversal(compiler, -1 ---this)).traverse(root); -1 ++++ -1 +++(new -1 +++NodeTraversal(compiler, -1 +++this)).traverseRoots(externs, -1 +++root); -1 } -1 @Override -1 ------ -1 ---a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java -1 ++++++ -1 +++b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java -1 @@ -1 -68,6 -1 +68,7 -1 @@ -1 private -1 static -1 class -1 Definition -1 { -1 final -1 Node -1 node; -1 final -1 Set<Var> -1 depends -1 = -1 Sets.newHashSet(); -1 ++++ -1 +++private -1 +++boolean -1 +++unknownDependencies -1 +++= -1 +++false; -1 Definition(Node -1 node) -1 { -1 this.node -1 = -1 node; -1 @@ -1 -393,9 -1 +394,13 -1 @@ -1 private -1 void -1 computeDependence(final -1 Definition -1 def, -1 Node -1 rValue) -1 { -1 new -1 AbstractCfgNodeTraversalCallback() -1 { -1 @Override -1 public -1 void -1 visit(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 ---- -1 ---if -1 ---(n.isName() -1 ---&& -1 ---jsScope.isDeclared(n.getString(), -1 ---true)) -1 ---{ -1 ++++ -1 +++if -1 +++(n.isName()) -1 +++{ -1 Var -1 dep -1 = -1 jsScope.getVar(n.getString()); -1 ++++ -1 +++if -1 +++(dep -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++def.unknownDependencies -1 +++= -1 +++true; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 def.depends.add(dep); -1 ++++ -1 +++} -1 } -1 } -1 }); -1 @@ -1 -427,6 -1 +432,9 -1 @@ -1 boolean -1 dependsOnOuterScopeVars(String -1 name, -1 Node -1 useNode) -1 { -1 GraphNode<Node, -1 Branch> -1 n -1 = -1 getCfg().getNode(useNode); -1 FlowState<MustDef> -1 state -1 = -1 n.getAnnotation(); -1 Definition -1 def -1 = -1 state.getIn().reachingDef.get(jsScope.getVar(name)); -1 ++++ -1 +++if -1 +++(def.unknownDependencies) -1 +++{ -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 for -1 (Var -1 s -1 : -1 def.depends) -1 { -1 if -1 (s.scope -1 != -1 jsScope) -1 { -1 -2
Node -1 parseInputs() -1 { -1 // -1 Check -1 if -1 the -1 sources -1 need -1 to -1 be -1 re-ordered. -1 if -1 (options.dependencyOptions.needsManagement() -1 && -1 ---- -1 ---!options.skipAllPasses -1 ---&& -1 options.closurePass) -1 { -1 for -1 (CompilerInput -1 input -1 : -1 inputs) -1 { -1 // -1 Forward-declare -1 all -1 the -1 provided -1 types, -1 so -1 that -1 they -1 -2
private -1 ExtractionInfo -1 extractMultilineTextualBlock(JsDocToken -1 token, -1 // -1 Track -1 the -1 start -1 of -1 the -1 line -1 to -1 count -1 whitespace -1 that -1 // -1 the -1 tokenizer -1 skipped. -1 Because -1 this -1 case -1 is -1 rare, -1 it's -1 easier -1 // -1 to -1 do -1 this -1 here -1 than -1 in -1 the -1 tokenizer. -1 ++++ -1 +++int -1 +++lineStartChar -1 +++= -1 +++-1; -1 do -1 { -1 switch -1 (token) -1 { -1 case -1 STAR: -1 if -1 (ignoreStar) -1 { -1 // -1 Mark -1 the -1 position -1 after -1 the -1 star -1 as -1 the -1 new -1 start -1 of -1 the -1 line. -1 ++++ -1 +++lineStartChar -1 +++= -1 +++stream.getCharno() -1 ++++ -1 +++1; -1 } -1 else -1 { -1 // -1 The -1 star -1 is -1 part -1 of -1 the -1 comment. -1 if -1 (builder.length() -1 > -1 0) -1 { -1 @@ -1 -1379,6 -1 +1381,7 -1 @@ -1 private -1 ExtractionInfo -1 extractMultilineTextualBlock(JsDocToken -1 token, -1 } -1 ignoreStar -1 = -1 true; -1 ++++ -1 +++lineStartChar -1 +++= -1 +++0; -1 token -1 = -1 next(); -1 continue; -1 @@ -1 -1386,7 -1 +1389,19 -1 @@ -1 private -1 ExtractionInfo -1 extractMultilineTextualBlock(JsDocToken -1 token, -1 ignoreStar -1 = -1 false; -1 state -1 = -1 State.SEARCHING_ANNOTATION; -1 ++++ -1 +++boolean -1 +++isEOC -1 +++= -1 +++token -1 +++== -1 +++JsDocToken.EOC; -1 ++++ -1 +++if -1 +++(!isEOC) -1 +++{ -1 ++++ -1 +++if -1 +++(lineStartChar -1 +++!= -1 +++-1 -1 +++&& -1 +++option -1 +++== -1 +++WhitespaceOption.PRESERVE) -1 +++{ -1 ++++ -1 +++int -1 +++numSpaces -1 +++= -1 +++stream.getCharno() -1 +++- -1 +++lineStartChar; -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++numSpaces; -1 +++i++) -1 +++{ -1 ++++ -1 +++builder.append(' -1 +++'); -1 ++++ -1 +++} -1 ++++ -1 +++lineStartChar -1 +++= -1 +++-1; -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(builder.length() -1 +++> -1 +++0) -1 +++{ -1 // -1 All -1 tokens -1 must -1 be -1 separated -1 by -1 a -1 space. -1 ++++ -1 +++builder.append(' -1 +++'); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 if -1 (token -1 == -1 JsDocToken.EOC -1 || -1 token -1 == -1 JsDocToken.EOF -1 || -1 @@ -1 -1411,9 -1 +1426,6 -1 @@ -1 private -1 ExtractionInfo -1 extractMultilineTextualBlock(JsDocToken -1 token, -1 return -1 new -1 ExtractionInfo(multilineText, -1 token); -1 } -1 ---- -1 ---if -1 ---(builder.length() -1 ---> -1 ---0) -1 ---{ -1 ---- -1 ---builder.append(' -1 ---'); -1 ---- -1 ---} -1 builder.append(toString(token)); -1 line -1 = -1 stream.getRemainingJSDocLine(); -1 -2
JSType -1 resolveInternal(ErrorReporter -1 t, -1 StaticScope<JSType> -1 scope) -1 { -1 @Override -1 public -1 void -1 matchConstraint(ObjectType -1 constraintObj) -1 { -1 // -1 We -1 only -1 want -1 to -1 match -1 contraints -1 on -1 anonymous -1 types. -1 ++++ -1 +++if -1 +++(hasReferenceName()) -1 +++{ -1 ++++ -1 +++return; -1 ++++ -1 +++} -1 // -1 Handle -1 the -1 case -1 where -1 the -1 constraint -1 object -1 is -1 a -1 record -1 type. -1 // -1 -2
void -1 addIdentifier(String -1 identifier) -1 { -1 * -1 Constants -1 (true, -1 false, -1 null) -1 are -1 considered -1 basically -1 free, -1 * -1 because -1 it's -1 likely -1 that -1 they -1 will -1 get -1 folded -1 when -1 we're -1 done. -1 */ -1 ++++ -1 +++@Override -1 ++++ -1 +++void -1 +++addConstant(String -1 +++newcode) -1 +++{ -1 ++++ -1 +++add("0"); -1 ++++ -1 +++} -1 } -1 } -1 -2
void -1 add(Node -1 n, -1 Context -1 context) -1 { -1 cc.addOp(opstr, -1 true); -1 addExpr(last, -1 p, -1 rhsContext); -1 } -1 else -1 { -1 ---- -1 ---addExpr(first, -1 ---p, -1 ---context); -1 ---- -1 ---cc.addOp(opstr, -1 ---true); -1 ---- -1 ---addExpr(last, -1 ---p -1 ---+ -1 ---1, -1 ---rhsContext); -1 ++++ -1 +++unrollBinaryOperator(n, -1 +++type, -1 +++opstr, -1 +++context, -1 +++rhsContext, -1 +++p, -1 +++p -1 ++++ -1 +++1); -1 } -1 return; -1 } -1 @@ -1 -751,7 -1 +749,7 -1 @@ -1 private -1 void -1 unrollBinaryOperator( -1 Node -1 current -1 = -1 firstNonOperator; -1 do -1 { -1 current -1 = -1 current.getParent(); -1 ---- -1 ---cc.listSeparator(); -1 ++++ -1 +++cc.addOp(opStr, -1 +++true); -1 addExpr(current.getFirstChild().getNext(), -1 rightPrecedence, -1 rhsContext); -1 } -1 while -1 (current -1 != -1 n); -1 } -1 ------ -1 ---a/src/com/google/javascript/jscomp/CodePrinter.java -1 ++++++ -1 +++b/src/com/google/javascript/jscomp/CodePrinter.java -1 @@ -1 -331,7 -1 +331,7 -1 @@ -1 void -1 endCaseBody() -1 { -1 @Override -1 void -1 appendOp(String -1 op, -1 boolean -1 binOp) -1 { -1 if -1 (binOp) -1 { -1 ---- -1 ---if -1 ---(getLastChar() -1 ---!= -1 ---' -1 ---') -1 ---{ -1 ++++ -1 +++if -1 +++(getLastChar() -1 +++!= -1 +++' -1 +++' -1 +++&& -1 +++op.charAt(0) -1 +++!= -1 +++',') -1 +++{ -1 append(" -1 "); -1 } -1 append(op); -1 -2
private -1 void -1 inferPropertyTypesToMatchConstraint( -1 ObjectType -1 constraintObj -1 = -1 ObjectType.cast(constraint.restrictByNotNullOrUndefined()); -1 ---- -1 ---if -1 ---(constraintObj -1 ---!= -1 ---null -1 ---&& -1 ---constraintObj.isRecordType()) -1 ---{ -1 ---- -1 ---ObjectType -1 ---objType -1 ---= -1 ---ObjectType.cast(type.restrictByNotNullOrUndefined()); -1 ---- -1 ---if -1 ---(objType -1 ---!= -1 ---null) -1 ---{ -1 ---- -1 ---for -1 ---(String -1 ---prop -1 ---: -1 ---constraintObj.getOwnPropertyNames()) -1 ---{ -1 ---- -1 ---JSType -1 ---propType -1 ---= -1 ---constraintObj.getPropertyType(prop); -1 ---- -1 ---if -1 ---(!objType.isPropertyTypeDeclared(prop)) -1 ---{ -1 ---- -1 ---JSType -1 ---typeToInfer -1 ---= -1 ---propType; -1 ---- -1 ---if -1 ---(!objType.hasProperty(prop)) -1 ---{ -1 ---- -1 ---typeToInfer -1 ---= -1 ---- -1 ---getNativeType(VOID_TYPE).getLeastSupertype(propType); -1 ---- -1 ---} -1 ---- -1 ---objType.defineInferredProperty(prop, -1 ---typeToInfer, -1 ---null); -1 ---- -1 ---} -1 ---- -1 ---} -1 ---- -1 ---} -1 ++++ -1 +++if -1 +++(constraintObj -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++type.matchConstraint(constraintObj); -1 } -1 } -1 -2
private -1 void -1 traverseFunction(Node -1 n, -1 Node -1 parent) -1 { -1 // -1 Body -1 Preconditions.checkState(body.getNext() -1 == -1 null -1 && -1 ---- -1 ---body.isBlock()); -1 ++++ -1 +++body.isBlock(), -1 +++body); -1 traverseBranch(body, -1 n); -1 popScope(); -1 ------ -1 ---a/src/com/google/javascript/jscomp/parsing/IRFactory.java -1 ++++++ -1 +++b/src/com/google/javascript/jscomp/parsing/IRFactory.java -1 @@ -1 -664,9 -1 +664,13 -1 @@ -1 Node -1 processFunctionNode(FunctionNode -1 functionNode) -1 { -1 node.addChildToBack(lp); -1 Node -1 bodyNode -1 = -1 transform(functionNode.getBody()); -1 ++++ -1 +++if -1 +++(!bodyNode.isBlock()) -1 +++{ -1 // -1 When -1 in -1 ideMode -1 Rhino -1 tries -1 to -1 parse -1 some -1 constructs -1 the -1 compiler -1 // -1 doesn't -1 support, -1 repair -1 it -1 here. -1 see -1 Rhino's -1 // -1 Parser#parseFunctionBodyExpr. -1 ++++ -1 +++Preconditions.checkState(config.isIdeMode); -1 ++++ -1 +++bodyNode -1 +++= -1 +++IR.block(); -1 ++++ -1 +++} -1 parseDirectives(bodyNode); -1 node.addChildToBack(bodyNode); -1 return -1 node; -1 -2
private -1 boolean -1 canInline( -1 // -1 issue -1 668: -1 Don't -1 inline -1 singleton -1 getter -1 methods -1 // -1 calls -1 as -1 this -1 confused -1 class -1 removing -1 logic. -1 ++++ -1 +++if -1 +++(convention.getSingletonGetterClassName(callNode) -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 } -1 } -1 -2
String -1 toStringHelper(boolean -1 forAnnotations) -1 { -1 sb.append(property); -1 sb.append(": -1 "); -1 ---- -1 ---sb.append(getPropertyType(property).toString()); -1 ++++ -1 +++sb.append(getPropertyType(property).toStringHelper(forAnnotations)); -1 ++i; -1 ---- -1 ---if -1 ---(i -1 ---== -1 ---MAX_PRETTY_PRINTED_PROPERTIES) -1 ---{ -1 ++++ -1 +++if -1 +++(!forAnnotations -1 +++&& -1 +++i -1 +++== -1 +++MAX_PRETTY_PRINTED_PROPERTIES) -1 +++{ -1 sb.append(", -1 ..."); -1 break; -1 } -1 @@ -1 -391,7 -1 +391,7 -1 @@ -1 String -1 toStringHelper(boolean -1 forAnnotations) -1 { -1 prettyPrint -1 = -1 true; -1 return -1 sb.toString(); -1 } -1 else -1 { -1 ---- -1 ---return -1 ---"{...}"; -1 ++++ -1 +++return -1 +++forAnnotations -1 +++? -1 +++"?" -1 +++: -1 +++"{...}"; -1 } -1 } -1 -2
private -1 void -1 interpretAssigns() -1 { -1 assignedToUnknownValue -1 = -1 true; -1 } -1 ++++ -1 +++boolean -1 +++maybeEscaped -1 +++= -1 +++false; -1 for -1 (Assign -1 assign -1 : -1 assignsByVar.get(var)) -1 { -1 if -1 (assign.isPropertyAssign) -1 { -1 hasPropertyAssign -1 = -1 true; -1 @@ -1 -736,9 -1 +737,12 -1 @@ -1 private -1 void -1 interpretAssigns() -1 { -1 assign.assignNode.getLastChild(), -1 true)) -1 { -1 assignedToUnknownValue -1 = -1 true; -1 } -1 ++++ -1 +++if -1 +++(assign.maybeAliased) -1 +++{ -1 ++++ -1 +++maybeEscaped -1 +++= -1 +++true; -1 ++++ -1 +++} -1 } -1 ---- -1 ---if -1 ---(assignedToUnknownValue -1 ---&& -1 ---hasPropertyAssign) -1 ---{ -1 ++++ -1 +++if -1 +++((assignedToUnknownValue -1 +++|| -1 +++maybeEscaped) -1 +++&& -1 +++hasPropertyAssign) -1 +++{ -1 changes -1 = -1 markReferencedVar(var) -1 || -1 changes; -1 maybeUnreferenced.remove(current); -1 current--; -1 @@ -1 -901,7 -1 +905,7 -1 @@ -1 void -1 apply() -1 { -1 this.nameNode -1 = -1 nameNode; -1 this.isPropertyAssign -1 = -1 isPropertyAssign; -1 ---- -1 ---this.maybeAliased -1 ---= -1 ---!assignNode.getParent().isExprResult(); -1 ++++ -1 +++this.maybeAliased -1 +++= -1 +++NodeUtil.isExpressionResultUsed(assignNode); -1 this.mayHaveSecondarySideEffects -1 = -1 maybeAliased -1 || -1 NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) -1 || -1 -2
void -1 addNumber(double -1 x) -1 { -1 // -1 x--4 -1 (which -1 is -1 a -1 syntax -1 error). -1 char -1 prev -1 = -1 getLastChar(); -1 boolean -1 negativeZero -1 = -1 isNegativeZero(x); -1 ---- -1 ---if -1 ---(x -1 ---< -1 ---0 -1 ---&& -1 ---prev -1 ---== -1 ---'-') -1 ---{ -1 ++++ -1 +++if -1 +++((x -1 +++< -1 +++0 -1 +++|| -1 +++negativeZero) -1 +++&& -1 +++prev -1 +++== -1 +++'-') -1 +++{ -1 add(" -1 "); -1 } -1 -2
public -1 void -1 visit(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 Node -1 nameNode -1 = -1 n.getFirstChild(); -1 NameInformation -1 ns -1 = -1 createNameInformation(t, -1 nameNode, -1 n); -1 if -1 (ns -1 != -1 null -1 && -1 ns.onlyAffectsClassDef) -1 { -1 ---- -1 ---JsName -1 ---name -1 ---= -1 ---getName(ns.name, -1 ---false); -1 ---- -1 ---if -1 ---(name -1 ---!= -1 ---null) -1 ---{ -1 ++++ -1 +++JsName -1 +++name -1 +++= -1 +++getName(ns.name, -1 +++true); -1 refNodes.add(new -1 ClassDefiningFunctionNode( -1 name, -1 n, -1 parent, -1 parent.getParent())); -1 ---- -1 ---} -1 } -1 } -1 } -1 -2
Node -1 processExpressionStatement(ExpressionStatement -1 statementNode) -1 { -1 @Override -1 Node -1 processForInLoop(ForInLoop -1 loopNode) -1 { -1 ++++ -1 +++if -1 +++(loopNode.isForEach()) -1 +++{ -1 ++++ -1 +++errorReporter.error( -1 ++++ -1 +++"unsupported -1 +++language -1 +++extension: -1 +++for -1 +++each", -1 ++++ -1 +++sourceName, -1 ++++ -1 +++loopNode.getLineno(), -1 +++"", -1 +++0); -1 // -1 Return -1 the -1 bare -1 minimum -1 to -1 put -1 the -1 AST -1 in -1 a -1 valid -1 state. -1 ++++ -1 +++return -1 +++newNode(Token.EXPR_RESULT, -1 +++Node.newNumber(0)); -1 ++++ -1 +++} -1 return -1 newNode( -1 Token.FOR, -1 transform(loopNode.getIterator()), -1 -2
FunctionTypeBuilder -1 inferFromOverriddenFunction( -1 } -1 // -1 Clone -1 any -1 remaining -1 params -1 that -1 aren't -1 in -1 the -1 function -1 literal. -1 ++++ -1 +++while -1 +++(oldParams.hasNext()) -1 +++{ -1 ++++ -1 +++paramBuilder.newParameterFromNode(oldParams.next()); -1 ++++ -1 +++} -1 parametersNode -1 = -1 paramBuilder.build(); -1 } -1 @@ -1 -480,6 -1 +483,12 -1 @@ -1 FunctionTypeBuilder -1 inferParameterTypes(@Nullable -1 Node -1 argsParent, -1 } -1 // -1 Copy -1 over -1 any -1 old -1 parameters -1 that -1 aren't -1 in -1 the -1 param -1 list. -1 ++++ -1 +++if -1 +++(!isVarArgs) -1 +++{ -1 ++++ -1 +++while -1 +++(oldParameterType -1 +++!= -1 +++null -1 +++&& -1 +++!isVarArgs) -1 +++{ -1 ++++ -1 +++builder.newParameterFromNode(oldParameterType); -1 ++++ -1 +++oldParameterType -1 +++= -1 +++oldParameterType.getNext(); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 if -1 (templateTypeName -1 != -1 null -1 && -1 !foundTemplateType) -1 { -1 reportError(TEMPLATE_TYPE_EXPECTED, -1 fnName); -1 -2
void -1 add(String -1 newcode) -1 { -1 // -1 need -1 space -1 to -1 separate. -1 This -1 is -1 not -1 pretty -1 printing. -1 // -1 For -1 example: -1 "return -1 foo;" -1 append(" -1 "); -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(c -1 +++== -1 +++'/' -1 +++&& -1 +++getLastChar() -1 +++== -1 +++'/') -1 +++{ -1 // -1 Do -1 not -1 allow -1 a -1 forward -1 slash -1 to -1 appear -1 after -1 a -1 DIV. -1 // -1 For -1 example, -1 // -1 REGEXP -1 DIV -1 REGEXP -1 // -1 is -1 valid -1 and -1 should -1 print -1 like -1 // -1 / -1 // -1 / -1 / -1 ++++ -1 +++append(" -1 +++"); -1 } -1 append(newcode); -1 -2
private -1 void -1 identifyNameNode( -1 private -1 JSType -1 getNativeType(JSTypeNative -1 nativeType) -1 { -1 return -1 typeRegistry.getNativeType(nativeType); -1 } -1 private -1 abstract -1 class -1 AbstractScopeBuilder -1 implements -1 NodeTraversal.Callback -1 { -1 /** -1 * -1 The -1 scope -1 that -1 we're -1 builidng. -1 */ -1 final -1 Scope -1 scope; -1 private -1 final -1 List<DeferredSetType> -1 deferredSetTypes -1 = -1 Lists.newArrayList(); -1 /** -1 * -1 Functions -1 that -1 we -1 found -1 in -1 the -1 global -1 scope -1 and -1 not -1 in -1 externs. -1 */ -1 private -1 final -1 List<Node> -1 nonExternFunctions -1 = -1 Lists.newArrayList(); -1 /** -1 * -1 Object -1 literals -1 with -1 a -1 @lends -1 annotation -1 aren't -1 analyzed -1 until -1 we -1 * -1 reach -1 the -1 root -1 of -1 the -1 statement -1 they're -1 defined -1 in. -1 * -1 * -1 This -1 ensures -1 that -1 if -1 there -1 are -1 any -1 @lends -1 annotations -1 on -1 the -1 object -1 * -1 literals, -1 the -1 type -1 on -1 the -1 @lends -1 annotation -1 resolves -1 correctly. -1 * -1 * -1 For -1 more -1 information, -1 see -1 * -1 http://code.google.com/p/closure-compiler/issues/detail?id=314 -1 */ -1 ++++ -1 +++private -1 +++List<Node> -1 +++lentObjectLiterals -1 +++= -1 +++null; -1 /** -1 * -1 Type-less -1 stubs. -1 * -1 * -1 If -1 at -1 the -1 end -1 of -1 traversal, -1 we -1 still -1 don't -1 have -1 types -1 for -1 these -1 * -1 stubs, -1 then -1 we -1 should -1 declare -1 UNKNOWN -1 types. -1 */ -1 private -1 final -1 List<StubDeclaration> -1 stubDeclarations -1 = -1 Lists.newArrayList(); -1 /** -1 * -1 The -1 current -1 source -1 file -1 that -1 we're -1 in. -1 */ -1 private -1 String -1 sourceName -1 = -1 null; -1 /** -1 * -1 The -1 InputId -1 of -1 the -1 current -1 node. -1 */ -1 private -1 InputId -1 inputId; -1 @@ -1 -498,90 -1 +499,106 -1 @@ -1 public -1 final -1 boolean -1 shouldTraverse(NodeTraversal -1 t, -1 Node -1 n, -1 public -1 void -1 visit(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 inputId -1 = -1 t.getInputId(); -1 attachLiteralTypes(t, -1 n); -1 switch -1 (n.getType()) -1 { -1 case -1 Token.CALL: -1 checkForClassDefiningCalls(t, -1 n, -1 parent); -1 checkForCallingConventionDefiningCalls(n, -1 delegateCallingConventions); -1 break; -1 case -1 Token.FUNCTION: -1 if -1 (t.getInput() -1 == -1 null -1 || -1 !t.getInput().isExtern()) -1 { -1 nonExternFunctions.add(n); -1 } -1 // -1 Hoisted -1 functions -1 are -1 handled -1 during -1 pre-traversal. -1 if -1 (!NodeUtil.isHoistedFunctionDeclaration(n)) -1 { -1 defineFunctionLiteral(n, -1 parent); -1 } -1 break; -1 case -1 Token.ASSIGN: -1 // -1 Handle -1 initialization -1 of -1 properties. -1 Node -1 firstChild -1 = -1 n.getFirstChild(); -1 if -1 (firstChild.isGetProp() -1 && -1 firstChild.isQualifiedName()) -1 { -1 maybeDeclareQualifiedName(t, -1 n.getJSDocInfo(), -1 firstChild, -1 n, -1 firstChild.getNext()); -1 } -1 break; -1 case -1 Token.CATCH: -1 defineCatch(n, -1 parent); -1 break; -1 case -1 Token.VAR: -1 defineVar(n, -1 parent); -1 break; -1 case -1 Token.GETPROP: -1 // -1 Handle -1 stubbed -1 properties. -1 if -1 (parent.isExprResult() -1 && -1 n.isQualifiedName()) -1 { -1 maybeDeclareQualifiedName(t, -1 n.getJSDocInfo(), -1 n, -1 parent, -1 null); -1 } -1 break; -1 } -1 // -1 Analyze -1 any -1 @lends -1 object -1 literals -1 in -1 this -1 statement. -1 ++++ -1 +++if -1 +++(n.getParent() -1 +++!= -1 +++null -1 +++&& -1 +++NodeUtil.isStatement(n) -1 +++&& -1 ++++ -1 +++lentObjectLiterals -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++for -1 +++(Node -1 +++objLit -1 +++: -1 +++lentObjectLiterals) -1 +++{ -1 ++++ -1 +++defineObjectLiteral(objLit); -1 ++++ -1 +++} -1 ++++ -1 +++lentObjectLiterals.clear(); -1 ++++ -1 +++} -1 } -1 private -1 void -1 attachLiteralTypes(NodeTraversal -1 t, -1 Node -1 n) -1 { -1 switch -1 (n.getType()) -1 { -1 case -1 Token.NULL: -1 n.setJSType(getNativeType(NULL_TYPE)); -1 break; -1 case -1 Token.VOID: -1 n.setJSType(getNativeType(VOID_TYPE)); -1 break; -1 case -1 Token.STRING: -1 // -1 Defer -1 keys -1 to -1 the -1 Token.OBJECTLIT -1 case -1 if -1 (!NodeUtil.isObjectLitKey(n, -1 n.getParent())) -1 { -1 n.setJSType(getNativeType(STRING_TYPE)); -1 } -1 break; -1 case -1 Token.NUMBER: -1 n.setJSType(getNativeType(NUMBER_TYPE)); -1 break; -1 case -1 Token.TRUE: -1 case -1 Token.FALSE: -1 n.setJSType(getNativeType(BOOLEAN_TYPE)); -1 break; -1 case -1 Token.REGEXP: -1 n.setJSType(getNativeType(REGEXP_TYPE)); -1 break; -1 case -1 Token.OBJECTLIT: -1 ++++ -1 +++JSDocInfo -1 +++info -1 +++= -1 +++n.getJSDocInfo(); -1 ++++ -1 +++if -1 +++(info -1 +++!= -1 +++null -1 +++&& -1 ++++ -1 +++info.getLendsName() -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++if -1 +++(lentObjectLiterals -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++lentObjectLiterals -1 +++= -1 +++Lists.newArrayList(); -1 ++++ -1 +++} -1 ++++ -1 +++lentObjectLiterals.add(n); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 defineObjectLiteral(n); -1 ++++ -1 +++} -1 break; -1 // -1 NOTE(nicksantos): -1 If -1 we -1 ever -1 support -1 Array -1 tuples, -1 // -1 we -1 will -1 need -1 to -1 put -1 ARRAYLIT -1 here -1 as -1 well. -1 } -1 } -1 -2
boolean -1 defineProperty(String -1 propertyName, -1 JSType -1 type, -1 propertyNode); -1 } -1 ---- -1 ---@Override -1 ---- -1 ---public -1 ---JSType -1 ---getLeastSupertype(JSType -1 ---that) -1 ---{ -1 ---- -1 ---if -1 ---(!that.isRecordType()) -1 ---{ -1 ---- -1 ---return -1 ---super.getLeastSupertype(that); -1 ---- -1 ---} -1 ---- -1 ---RecordTypeBuilder -1 ---builder -1 ---= -1 ---new -1 ---RecordTypeBuilder(registry); -1 ---- -1 ---for -1 ---(String -1 ---property -1 ---: -1 ---properties.keySet()) -1 ---{ -1 ---- -1 ---if -1 ---(that.toMaybeRecordType().hasProperty(property) -1 ---&& -1 ---- -1 ---that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( -1 ---- -1 ---getPropertyType(property))) -1 ---{ -1 ---- -1 ---builder.addProperty(property, -1 ---getPropertyType(property), -1 ---- -1 ---getPropertyNode(property)); -1 ---- -1 ---} -1 ---- -1 ---} -1 ---- -1 ---return -1 ---builder.build(); -1 ---- -1 ---} -1 JSType -1 getGreatestSubtypeHelper(JSType -1 that) -1 { -1 if -1 (that.isRecordType()) -1 { -1 RecordType -1 thatRecord -1 = -1 that.toMaybeRecordType(); -1 -2
private -1 OriginalMapping -1 getOriginalMappingForEntry(Entry -1 entry) -1 { -1 // -1 Adjust -1 the -1 line/column -1 here -1 to -1 be -1 start -1 at -1 1. -1 Builder -1 x -1 = -1 OriginalMapping.newBuilder() -1 .setOriginalFile(sources[entry.getSourceFileId()]) -1 ---- -1 ---.setLineNumber(entry.getSourceLine()) -1 ---- -1 ---.setColumnPosition(entry.getSourceColumn()); -1 ++++ -1 +++.setLineNumber(entry.getSourceLine() -1 ++++ -1 +++1) -1 ++++ -1 +++.setColumnPosition(entry.getSourceColumn() -1 ++++ -1 +++1); -1 if -1 (entry.getNameId() -1 != -1 UNMAPPED) -1 { -1 x.setIdentifier(names[entry.getNameId()]); -1 } -1 ------ -1 ---a/src/com/google/javascript/jscomp/SourceMap.java -1 ++++++ -1 +++b/src/com/google/javascript/jscomp/SourceMap.java -1 @@ -1 -135,10 -1 +135,15 -1 @@ -1 public -1 void -1 addMapping( -1 // -1 zero -1 based. -1 // -1 We -1 don't -1 change -1 this -1 for -1 the -1 v1 -1 or -1 v2 -1 source -1 maps -1 but -1 for -1 // -1 v3 -1 we -1 make -1 them -1 both -1 0 -1 based. -1 ++++ -1 +++int -1 +++lineBaseOffset -1 +++= -1 +++1; -1 ++++ -1 +++if -1 +++(generator -1 +++instanceof -1 +++SourceMapGeneratorV1 -1 ++++ -1 +++|| -1 +++generator -1 +++instanceof -1 +++SourceMapGeneratorV2) -1 +++{ -1 ++++ -1 +++lineBaseOffset -1 +++= -1 +++0; -1 ++++ -1 +++} -1 generator.addMapping( -1 sourceFile, -1 originalName, -1 ---- -1 ---new -1 ---FilePosition(node.getLineno(), -1 ---node.getCharno()), -1 ++++ -1 +++new -1 +++FilePosition(node.getLineno() -1 +++- -1 +++lineBaseOffset, -1 +++node.getCharno()), -1 outputStartPosition, -1 outputEndPosition); -1 } -1 -2
void -1 maybeDeclareQualifiedName(NodeTraversal -1 t, -1 JSDocInfo -1 info, -1 || -1 FunctionTypeBuilder.isFunctionTypeDeclaration(info)); -1 } -1 ---- -1 ---if -1 ---(inferred) -1 ---{ -1 ++++ -1 +++if -1 +++(inferred -1 +++&& -1 +++rhsValue -1 +++!= -1 +++null -1 +++&& -1 +++rhsValue.isFunction()) -1 +++{ -1 // -1 Determining -1 declaration -1 for -1 #2 -1 ---- -1 ---inferred -1 ---= -1 ---!(rhsValue -1 ---!= -1 ---null -1 ---&& -1 ---- -1 ---rhsValue.isFunction() -1 ---&& -1 ---- -1 ---(info -1 ---!= -1 ---null -1 ---|| -1 ---!scope.isDeclared(qName, -1 ---false))); -1 ++++ -1 +++if -1 +++(info -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++inferred -1 +++= -1 +++false; -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(!scope.isDeclared(qName, -1 +++false) -1 +++&& -1 ++++ -1 +++n.isUnscopedQualifiedName()) -1 +++{ -1 ++++ -1 +++inferred -1 +++= -1 +++false; -1 ++++ -1 +++} -1 } -1 if -1 (!inferred) -1 { -1 -2
public -1 void -1 enterScope(NodeTraversal -1 t) -1 { -1 renamer -1 = -1 nameStack.peek().forChildScope(); -1 } -1 ---- -1 ---if -1 ---(declarationRoot.getType() -1 ---== -1 ---Token.FUNCTION) -1 ---{ -1 ---- -1 ---for -1 ---(Node -1 ---c -1 ---= -1 ---declarationRoot.getFirstChild().getNext().getFirstChild(); -1 ---c -1 ---!= -1 ---null; -1 ---c -1 ---= -1 ---c.getNext()) -1 ---{ -1 ---- -1 ---String -1 ---name -1 ---= -1 ---c.getString(); -1 ---- -1 ---renamer.addDeclaredName(name); -1 ---- -1 ---} -1 ---- -1 ---Node -1 ---functionBody -1 ---= -1 ---declarationRoot.getLastChild(); -1 ---- -1 ---findDeclaredNames(functionBody, -1 ---null, -1 ---renamer); -1 ---- -1 ---} -1 ---else -1 if -1 (declarationRoot.getType() -1 != -1 Token.FUNCTION) -1 { -1 // -1 Add -1 the -1 block -1 declarations -1 findDeclaredNames(declarationRoot, -1 null, -1 renamer); -1 @@ -1 -127,11 -1 +119,22 -1 @@ -1 public -1 boolean -1 shouldTraverse(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 renamer.addDeclaredName(name); -1 } -1 ++++ -1 +++nameStack.push(renamer); -1 ++++ -1 +++} -1 ++++ -1 +++break; -1 ++++ -1 +++case -1 +++Token.LP: -1 +++{ -1 ++++ -1 +++Renamer -1 +++renamer -1 +++= -1 +++nameStack.peek().forChildScope(); -1 // -1 Add -1 the -1 function -1 parameters -1 ++++ -1 +++for -1 +++(Node -1 +++c -1 +++= -1 +++n.getFirstChild(); -1 +++c -1 +++!= -1 +++null; -1 +++c -1 +++= -1 +++c.getNext()) -1 +++{ -1 ++++ -1 +++String -1 +++name -1 +++= -1 +++c.getString(); -1 ++++ -1 +++renamer.addDeclaredName(name); -1 ++++ -1 +++} -1 // -1 Add -1 the -1 function -1 body -1 declarations -1 ++++ -1 +++Node -1 +++functionBody -1 +++= -1 +++n.getNext(); -1 ++++ -1 +++findDeclaredNames(functionBody, -1 +++null, -1 +++renamer); -1 nameStack.push(renamer); -1 } -1 @@ -1 -170,13 -1 +173,16 -1 @@ -1 public -1 void -1 visit(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 case -1 Token.FUNCTION: -1 // -1 Remove -1 the -1 function -1 body -1 scope -1 ++++ -1 +++nameStack.pop(); -1 // -1 Remove -1 function -1 recursive -1 name -1 (if -1 any). -1 nameStack.pop(); -1 break; -1 ++++ -1 +++case -1 +++Token.LP: -1 // -1 Note: -1 The -1 parameters -1 and -1 function -1 body -1 variables -1 live -1 in -1 the -1 // -1 same -1 scope, -1 we -1 introduce -1 the -1 scope -1 when -1 in -1 the -1 "shouldTraverse" -1 // -1 visit -1 of -1 LP, -1 but -1 remove -1 it -1 when -1 when -1 we -1 exit -1 the -1 function -1 above. -1 ++++ -1 +++break; -1 case -1 Token.CATCH: -1 // -1 Remove -1 catch -1 except -1 name -1 from -1 the -1 stack -1 of -1 names. -1 -2
private -1 Node -1 tryFoldArrayJoin(Node -1 n) -1 { -1 Node -1 right -1 = -1 callTarget.getNext(); -1 if -1 (right -1 != -1 null) -1 { -1 ---- -1 ---if -1 ---(!NodeUtil.isImmutableValue(right)) -1 ---{ -1 ++++ -1 +++if -1 +++(right.getNext() -1 +++!= -1 +++null -1 +++|| -1 +++!NodeUtil.isImmutableValue(right)) -1 +++{ -1 return -1 n; -1 } -1 } -1 @@ -1 -386,7 -1 +386,12 -1 @@ -1 private -1 Node -1 tryFoldArrayJoin(Node -1 n) -1 { -1 return -1 n; -1 } -1 ++++ -1 +++if -1 +++(right -1 +++!= -1 +++null -1 +++&& -1 +++right.getType() -1 +++== -1 +++Token.STRING -1 ++++ -1 +++&& -1 +++",".equals(right.getString())) -1 +++{ -1 // -1 "," -1 is -1 the -1 default, -1 it -1 doesn't -1 need -1 to -1 be -1 explicit -1 ++++ -1 +++n.removeChild(right); -1 ++++ -1 +++reportCodeChange(); -1 ++++ -1 +++} -1 String -1 joinString -1 = -1 (right -1 == -1 null) -1 ? -1 "," -1 : -1 NodeUtil.getStringValue(right); -1 List<Node> -1 arrayFoldedChildren -1 = -1 Lists.newLinkedList(); -1 -2
private -1 void -1 replaceAssignmentExpression(Var -1 v, -1 Reference -1 ref, -1 } -1 Node -1 replacement; -1 ++++ -1 +++if -1 +++(nodes.isEmpty()) -1 +++{ -1 ++++ -1 +++replacement -1 +++= -1 +++new -1 +++Node(Token.TRUE); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 // -1 All -1 assignments -1 evaluate -1 to -1 true, -1 so -1 make -1 sure -1 that -1 the -1 // -1 expr -1 statement -1 evaluates -1 to -1 true -1 in -1 case -1 it -1 matters. -1 nodes.add(new -1 Node(Token.TRUE)); -1 @@ -1 -347,6 -1 +350,7 -1 @@ -1 private -1 void -1 replaceAssignmentExpression(Var -1 v, -1 Reference -1 ref, -1 } -1 cur.addChildToFront(nodes.get(i)); -1 cur.addChildToFront(nodes.get(i -1 + -1 1)); -1 ++++ -1 +++} -1 Node -1 replace -1 = -1 ref.getParent(); -1 replacement.copyInformationFromForTree(replace); -1 -2
void -1 addNumber(double -1 x) -1 { -1 add(" -1 "); -1 } -1 ---- -1 ---if -1 ---((long) -1 ---x -1 ---== -1 ---x) -1 ---{ -1 ++++ -1 +++if -1 +++((long) -1 +++x -1 +++== -1 +++x -1 +++&& -1 +++!isNegativeZero(x)) -1 +++{ -1 long -1 value -1 = -1 (long) -1 x; -1 long -1 mantissa -1 = -1 value; -1 int -1 exp -1 = -1 0; -1 -2
static -1 boolean -1 isSimpleNumber(String -1 s) -1 { -1 return -1 false; -1 } -1 } -1 ---- -1 ---return -1 ---len -1 ---> -1 ---0; -1 ++++ -1 +++return -1 +++len -1 +++> -1 +++0 -1 +++&& -1 +++s.charAt(0) -1 +++!= -1 +++'0'; -1 } -1 static -1 double -1 getSimpleNumber(String -1 s) -1 { -1 -2
public -1 void -1 initOptions(CompilerOptions -1 options) -1 { -1 CheckLevel.OFF); -1 } -1 ---- -1 ---if -1 ---(options.checkGlobalThisLevel.isOn()) -1 ---{ -1 ++++ -1 +++if -1 +++(options.checkGlobalThisLevel.isOn() -1 +++&& -1 ++++ -1 +++!options.disables(DiagnosticGroups.GLOBAL_THIS)) -1 +++{ -1 options.setWarningLevel( -1 DiagnosticGroups.GLOBAL_THIS, -1 options.checkGlobalThisLevel); -1 -2
public -1 Node -1 parseHelperCode(Reducer -1 reducer) -1 { -1 } -1 private -1 static -1 boolean -1 isReduceableFunctionExpression(Node -1 n) -1 { -1 ---- -1 ---return -1 ---NodeUtil.isFunctionExpression(n); -1 ++++ -1 +++return -1 +++NodeUtil.isFunctionExpression(n) -1 ++++ -1 +++&& -1 +++!NodeUtil.isGetOrSetKey(n.getParent()); -1 } -1 /** -1 -2
void -1 maybeDeclareQualifiedName(NodeTraversal -1 t, -1 JSDocInfo -1 info, -1 // -1 then -1 they -1 are -1 responsible -1 for -1 making -1 sure -1 that -1 the -1 object -1 literal's -1 // -1 implicit -1 prototype -1 is -1 set -1 up -1 appropriately. -1 We -1 just -1 obey -1 // -1 the -1 @extends -1 tag. -1 ---- -1 ---if -1 ---(!qVar.isTypeInferred()) -1 ---{ -1 ++++ -1 +++ObjectType -1 +++qVarType -1 +++= -1 +++ObjectType.cast(qVar.getType()); -1 ++++ -1 +++if -1 +++(qVarType -1 +++!= -1 +++null -1 +++&& -1 ++++ -1 +++rhsValue -1 +++!= -1 +++null -1 +++&& -1 ++++ -1 +++rhsValue.getType() -1 +++== -1 +++Token.OBJECTLIT) -1 +++{ -1 ++++ -1 +++typeRegistry.resetImplicitPrototype( -1 ++++ -1 +++rhsValue.getJSType(), -1 +++qVarType.getImplicitPrototype()); -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(!qVar.isTypeInferred()) -1 +++{ -1 // -1 If -1 the -1 programmer -1 has -1 declared -1 that -1 F -1 inherits -1 from -1 Super, -1 // -1 and -1 they -1 assign -1 F.prototype -1 to -1 some -1 arbitrary -1 expression, -1 // -1 there's -1 not -1 much -1 we -1 can -1 do. -1 We -1 just -1 ignore -1 the -1 expression, -1 ------ -1 ---a/src/com/google/javascript/rhino/jstype/FunctionType.java -1 ++++++ -1 +++b/src/com/google/javascript/rhino/jstype/FunctionType.java -1 @@ -1 -338,7 -1 +338,6 -1 @@ -1 public -1 void -1 setPrototypeBasedOn(ObjectType -1 baseType) -1 { -1 // -1 // -1 In -1 the -1 second -1 case, -1 we -1 just -1 use -1 the -1 anonymous -1 object -1 as -1 the -1 prototype. -1 if -1 (baseType.hasReferenceName() -1 || -1 ---- -1 ---baseType.isUnknownType() -1 ---|| -1 isNativeObjectType() -1 || -1 baseType.isFunctionPrototypeType() -1 || -1 !(baseType -1 instanceof -1 PrototypeObjectType)) -1 { -1 @@ -1 -363,14 -1 +362,18 -1 @@ -1 public -1 boolean -1 setPrototype(PrototypeObjectType -1 prototype) -1 { -1 return -1 false; -1 } -1 ---- -1 ---boolean -1 ---replacedPrototype -1 ---= -1 ---prototype -1 ---!= -1 ---null; -1 ++++ -1 +++PrototypeObjectType -1 +++oldPrototype -1 +++= -1 +++this.prototype; -1 ++++ -1 +++boolean -1 +++replacedPrototype -1 +++= -1 +++oldPrototype -1 +++!= -1 +++null; -1 this.prototype -1 = -1 prototype; -1 this.prototypeSlot -1 = -1 new -1 SimpleSlot("prototype", -1 prototype, -1 true); -1 this.prototype.setOwnerFunction(this); -1 ++++ -1 +++if -1 +++(oldPrototype -1 +++!= -1 +++null) -1 +++{ -1 // -1 Disassociating -1 the -1 old -1 prototype -1 makes -1 this -1 easier -1 to -1 debug-- -1 // -1 we -1 don't -1 have -1 to -1 worry -1 about -1 two -1 prototypes -1 running -1 around. -1 ++++ -1 +++oldPrototype.setOwnerFunction(null); -1 ++++ -1 +++} -1 if -1 (isConstructor() -1 || -1 isInterface()) -1 { -1 FunctionType -1 superClass -1 = -1 getSuperClassConstructor(); -1 -2
public -1 String -1 getLine(int -1 lineNumber) -1 { -1 // -1 If -1 next -1 new -1 line -1 cannot -1 be -1 found, -1 there -1 are -1 two -1 cases -1 // -1 1. -1 pos -1 already -1 reaches -1 the -1 end -1 of -1 file, -1 then -1 null -1 should -1 be -1 returned -1 // -1 2. -1 otherwise, -1 return -1 the -1 contents -1 between -1 pos -1 and -1 the -1 end -1 of -1 file. -1 ++++ -1 +++if -1 +++(pos -1 +++>= -1 +++js.length()) -1 +++{ -1 return -1 null; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++return -1 +++js.substring(pos, -1 +++js.length()); -1 ++++ -1 +++} -1 } -1 else -1 { -1 return -1 js.substring(pos, -1 js.indexOf('\n', -1 pos)); -1 } -1 -2
private -1 void -1 computeGenKill(Node -1 n, -1 BitSet -1 gen, -1 BitSet -1 kill, -1 // -1 for(var -1 x -1 in -1 y) -1 {...} -1 lhs -1 = -1 lhs.getLastChild(); -1 } -1 ++++ -1 +++if -1 +++(NodeUtil.isName(lhs)) -1 +++{ -1 addToSetIfLocal(lhs, -1 kill); -1 addToSetIfLocal(lhs, -1 gen); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++computeGenKill(lhs, -1 +++gen, -1 +++kill, -1 +++conditional); -1 ++++ -1 +++} -1 computeGenKill(rhs, -1 gen, -1 kill, -1 conditional); -1 } -1 return; -1 -2
private -1 static -1 String -1 extractClassNameIfGoog(Node -1 node, -1 Node -1 parent, -1 String -1 qualifiedName -1 = -1 callee.getQualifiedName(); -1 if -1 (functionName.equals(qualifiedName)) -1 { -1 Node -1 target -1 = -1 callee.getNext(); -1 ---- -1 ---if -1 ---(target -1 ---!= -1 ---null) -1 ---{ -1 ++++ -1 +++if -1 +++(target -1 +++!= -1 +++null -1 +++&& -1 +++target.getType() -1 +++== -1 +++Token.STRING) -1 +++{ -1 className -1 = -1 target.getString(); -1 } -1 } -1 -2
private -1 String -1 format(JSError -1 error, -1 boolean -1 warning) -1 { -1 // -1 charno -1 == -1 sourceExpert.length() -1 means -1 something -1 is -1 missing -1 // -1 at -1 the -1 end -1 of -1 the -1 line -1 if -1 (excerpt.equals(LINE) -1 ---- -1 ---&& -1 ---0 -1 ---<= -1 ---charno -1 ---&& -1 ---charno -1 ---< -1 ---sourceExcerpt.length()) -1 ---{ -1 ++++ -1 +++&& -1 +++0 -1 +++<= -1 +++charno -1 +++&& -1 +++charno -1 +++<= -1 +++sourceExcerpt.length()) -1 +++{ -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 charno; -1 i++) -1 { -1 char -1 c -1 = -1 sourceExcerpt.charAt(i); -1 if -1 (Character.isWhitespace(c)) -1 { -1 -2
static -1 TernaryValue -1 getImpureBooleanValue(Node -1 n) -1 { -1 // -1 ignoring -1 side-effects -1 return -1 TernaryValue.TRUE; -1 ++++ -1 +++case -1 +++Token.VOID: -1 ++++ -1 +++return -1 +++TernaryValue.FALSE; -1 default: -1 return -1 getPureBooleanValue(n); -1 @@ -1 -133,7 -1 +135,10 -1 @@ -1 static -1 TernaryValue -1 getPureBooleanValue(Node -1 n) -1 { -1 return -1 TernaryValue.FALSE; -1 case -1 Token.VOID: -1 ++++ -1 +++if -1 +++(!mayHaveSideEffects(n.getFirstChild())) -1 +++{ -1 return -1 TernaryValue.FALSE; -1 ++++ -1 +++} -1 ++++ -1 +++break; -1 case -1 Token.NAME: -1 String -1 name -1 = -1 n.getString(); -1 -2
private -1 String -1 format(JSError -1 error, -1 boolean -1 warning) -1 { -1 // -1 charno -1 == -1 sourceExpert.length() -1 means -1 something -1 is -1 missing -1 // -1 at -1 the -1 end -1 of -1 the -1 line -1 if -1 (excerpt.equals(LINE) -1 ---- -1 ---&& -1 ---0 -1 ---<= -1 ---charno -1 ---&& -1 ---charno -1 ---< -1 ---sourceExcerpt.length()) -1 ---{ -1 ++++ -1 +++&& -1 +++0 -1 +++<= -1 +++charno -1 +++&& -1 +++charno -1 +++<= -1 +++sourceExcerpt.length()) -1 +++{ -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 charno; -1 i++) -1 { -1 char -1 c -1 = -1 sourceExcerpt.charAt(i); -1 if -1 (Character.isWhitespace(c)) -1 { -1 -2
static -1 boolean -1 functionCallHasSideEffects( -1 } -1 // -1 Functions -1 in -1 the -1 "Math" -1 namespace -1 have -1 no -1 side -1 effects. -1 ++++ -1 +++if -1 +++(nameNode.getFirstChild().getType() -1 +++== -1 +++Token.NAME) -1 +++{ -1 ++++ -1 +++String -1 +++namespaceName -1 +++= -1 +++nameNode.getFirstChild().getString(); -1 ++++ -1 +++if -1 +++(namespaceName.equals("Math")) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 if -1 (compiler -1 != -1 null -1 && -1 !compiler.hasRegExpGlobalReferences()) -1 { -1 if -1 (nameNode.getFirstChild().getType() -1 == -1 Token.REGEXP -1 -2
public -1 Void -1 call() -1 throws -1 Exception -1 { -1 // -1 if -1 LanguageMode -1 is -1 ECMASCRIPT5_STRICT, -1 only -1 print -1 'use -1 strict' -1 // -1 for -1 the -1 first -1 input -1 file -1 ---- -1 ---String -1 ---code -1 ---= -1 ---toSource(root, -1 ---sourceMap); -1 ++++ -1 +++String -1 +++code -1 +++= -1 +++toSource(root, -1 +++sourceMap, -1 +++inputSeqNum -1 +++== -1 +++0); -1 if -1 (!code.isEmpty()) -1 { -1 cb.append(code); -1 @@ -1 -1458,19 -1 +1458,19 -1 @@ -1 public -1 Void -1 call() -1 throws -1 Exception -1 { -1 @Override -1 String -1 toSource(Node -1 n) -1 { -1 initCompilerOptionsIfTesting(); -1 ---- -1 ---return -1 ---toSource(n, -1 ---null); -1 ++++ -1 +++return -1 +++toSource(n, -1 +++null, -1 +++true); -1 } -1 /** -1 * -1 Generates -1 JavaScript -1 source -1 code -1 for -1 an -1 AST. -1 */ -1 ---- -1 ---private -1 ---String -1 ---toSource(Node -1 ---n, -1 ---SourceMap -1 ---sourceMap) -1 ---{ -1 ++++ -1 +++private -1 +++String -1 +++toSource(Node -1 +++n, -1 +++SourceMap -1 +++sourceMap, -1 +++boolean -1 +++firstOutput) -1 +++{ -1 CodePrinter.Builder -1 builder -1 = -1 new -1 CodePrinter.Builder(n); -1 builder.setPrettyPrint(options.prettyPrint); -1 builder.setLineBreak(options.lineBreak); -1 builder.setSourceMap(sourceMap); -1 builder.setSourceMapDetailLevel(options.sourceMapDetailLevel); -1 ---- -1 ---builder.setTagAsStrict( -1 ++++ -1 +++builder.setTagAsStrict(firstOutput -1 +++&& -1 options.getLanguageOut() -1 == -1 LanguageMode.ECMASCRIPT5_STRICT); -1 builder.setLineLengthThreshold(options.lineLengthThreshold); -1 -2
static -1 String -1 strEscape(String -1 s, -1 char -1 quote, -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 s.length(); -1 i++) -1 { -1 char -1 c -1 = -1 s.charAt(i); -1 switch -1 (c) -1 { -1 ---- -1 ---case -1 ---'\0': -1 ---sb.append("\\0"); -1 ---break; -1 ++++ -1 +++case -1 +++'\0': -1 +++sb.append("\\000"); -1 +++break; -1 case -1 '\n': -1 sb.append("\\n"); -1 break; -1 case -1 '\r': -1 sb.append("\\r"); -1 break; -1 case -1 '\t': -1 sb.append("\\t"); -1 break; -1 -2
public -1 void -1 visit(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 // -1 Object -1 literal -1 keys -1 are -1 handled -1 with -1 OBJECTLIT -1 if -1 (!NodeUtil.isObjectLitKey(n, -1 n.getParent())) -1 { -1 ensureTyped(t, -1 n, -1 STRING_TYPE); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 // -1 Object -1 literal -1 keys -1 are -1 not -1 typeable -1 ++++ -1 +++typeable -1 +++= -1 +++false; -1 } -1 break; -1 -2
static -1 String -1 strEscape(String -1 s, -1 char -1 quote, -1 // -1 No -1 charsetEncoder -1 provided -1 - -1 pass -1 straight -1 latin -1 characters -1 // -1 through, -1 and -1 escape -1 the -1 rest. -1 Doing -1 the -1 explicit -1 character -1 // -1 check -1 is -1 measurably -1 faster -1 than -1 using -1 the -1 CharsetEncoder. -1 ---- -1 ---if -1 ---(c -1 ---> -1 ---0x1f -1 ---&& -1 ---c -1 ---<= -1 ---0x7f) -1 ---{ -1 ++++ -1 +++if -1 +++(c -1 +++> -1 +++0x1f -1 +++&& -1 +++c -1 +++< -1 +++0x7f) -1 +++{ -1 sb.append(c); -1 } -1 else -1 { -1 // -1 Other -1 characters -1 can -1 be -1 misinterpreted -1 by -1 some -1 js -1 parsers, -1 -2
private -1 boolean -1 isPrototypePropertyAssign(Node -1 assign) -1 { -1 Node -1 n -1 = -1 assign.getFirstChild(); -1 if -1 (n -1 != -1 null -1 && -1 NodeUtil.isVarOrSimpleAssignLhs(n, -1 assign) -1 && -1 n.getType() -1 == -1 Token.GETPROP -1 ---- -1 ---) -1 ---{ -1 ++++ -1 +++&& -1 +++assign.getParent().getType() -1 +++== -1 +++Token.EXPR_RESULT) -1 +++{ -1 // -1 We -1 want -1 to -1 exclude -1 the -1 assignment -1 itself -1 from -1 the -1 usage -1 list -1 boolean -1 isChainedProperty -1 = -1 n.getFirstChild().getType() -1 == -1 Token.GETPROP; -1 -2
private -1 Node -1 tryFoldComparison(Node -1 n, -1 Node -1 left, -1 Node -1 right) -1 { -1 && -1 right.getString().equals("undefined")) -1 || -1 (Token.VOID -1 == -1 right.getType() -1 && -1 NodeUtil.isLiteralValue(right.getFirstChild(), -1 false))); -1 ---- -1 ---int -1 ---lhType -1 ---= -1 ---left.getType(); -1 ---- -1 ---int -1 ---rhType -1 ---= -1 ---right.getType(); -1 ++++ -1 +++int -1 +++lhType -1 +++= -1 +++getNormalizedNodeType(left); -1 ++++ -1 +++int -1 +++rhType -1 +++= -1 +++getNormalizedNodeType(right); -1 switch -1 (lhType) -1 { -1 case -1 Token.VOID: -1 if -1 (!NodeUtil.isLiteralValue(left.getFirstChild(), -1 false)) -1 { -1 @@ -1 -1071,6 -1 +1071,19 -1 @@ -1 private -1 Node -1 tryFoldComparison(Node -1 n, -1 Node -1 left, -1 Node -1 right) -1 { -1 /** -1 * -1 @return -1 Translate -1 NOT -1 expressions -1 into -1 TRUE -1 or -1 FALSE -1 when -1 possible. -1 */ -1 ++++ -1 +++private -1 +++int -1 +++getNormalizedNodeType(Node -1 +++n) -1 +++{ -1 ++++ -1 +++int -1 +++type -1 +++= -1 +++n.getType(); -1 ++++ -1 +++if -1 +++(type -1 +++== -1 +++Token.NOT) -1 +++{ -1 ++++ -1 +++TernaryValue -1 +++value -1 +++= -1 +++NodeUtil.getPureBooleanValue(n); -1 ++++ -1 +++switch -1 +++(value) -1 +++{ -1 ++++ -1 +++case -1 +++TRUE: -1 ++++ -1 +++return -1 +++Token.TRUE; -1 ++++ -1 +++case -1 +++FALSE: -1 ++++ -1 +++return -1 +++Token.FALSE; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++type; -1 ++++ -1 +++} -1 /** -1 * -1 The -1 result -1 of -1 the -1 comparison -1 as -1 a -1 Boolean -1 or -1 null -1 if -1 the -1 -2
private -1 void -1 checkPropertyVisibility(NodeTraversal -1 t, -1 if -1 (objectType -1 != -1 null) -1 { -1 // -1 Is -1 this -1 a -1 normal -1 property -1 access, -1 or -1 are -1 we -1 trying -1 to -1 override -1 // -1 an -1 existing -1 property? -1 ---- -1 ---boolean -1 ---isOverride -1 ---= -1 ---t.inGlobalScope() -1 ---&& -1 ++++ -1 +++boolean -1 +++isOverride -1 +++= -1 +++parent.getJSDocInfo() -1 +++!= -1 +++null -1 +++&& -1 parent.getType() -1 == -1 Token.ASSIGN -1 && -1 parent.getFirstChild() -1 == -1 getprop; -1 -2
boolean -1 parse() -1 { -1 } -1 break; -1 } -1 ++++ -1 +++} -1 token -1 = -1 eatTokensUntilEOL(); -1 ---- -1 ---} -1 continue -1 retry; -1 } -1 } -1 @@ -1 -1706,6 -1 +1706,7 -1 @@ -1 private -1 Node -1 parseBasicTypeExpression(JsDocToken -1 token) -1 { -1 } -1 } -1 ++++ -1 +++restoreLookAhead(token); -1 return -1 reportGenericTypeSyntaxWarning(); -1 } -1 @@ -1 -1758,6 -1 +1759,7 -1 @@ -1 private -1 Node -1 parseFunctionType(JsDocToken -1 token) -1 { -1 // -1 NOTE(nicksantos): -1 We're -1 not -1 implementing -1 generics -1 at -1 the -1 moment, -1 so -1 // -1 just -1 throw -1 out -1 TypeParameters. -1 if -1 (token -1 != -1 JsDocToken.LP) -1 { -1 ++++ -1 +++restoreLookAhead(token); -1 return -1 reportTypeSyntaxWarning("msg.jsdoc.missing.lp"); -1 } -1 -2
private -1 void -1 visitCall(NodeTraversal -1 t, -1 Node -1 n) -1 { -1 // -1 Functions -1 with -1 explcit -1 'this' -1 types -1 must -1 be -1 called -1 in -1 a -1 GETPROP -1 // -1 or -1 GETELEM. -1 ++++ -1 +++if -1 +++(functionType.isOrdinaryFunction() -1 +++&& -1 ++++ -1 +++!functionType.getTypeOfThis().isUnknownType() -1 +++&& -1 ++++ -1 +++!functionType.getTypeOfThis().isNativeObjectType() -1 +++&& -1 ++++ -1 +++!(child.getType() -1 +++== -1 +++Token.GETELEM -1 +++|| -1 ++++ -1 +++child.getType() -1 +++== -1 +++Token.GETPROP)) -1 +++{ -1 ++++ -1 +++report(t, -1 +++n, -1 +++EXPECTED_THIS_TYPE, -1 +++functionType.toString()); -1 ++++ -1 +++} -1 visitParameterList(t, -1 n, -1 functionType); -1 ensureTyped(t, -1 n, -1 functionType.getReturnType()); -1 -2
private -1 void -1 declareArguments(Node -1 functionNode) -1 { -1 for -1 (Node -1 astParameter -1 : -1 astParameters.children()) -1 { -1 if -1 (jsDocParameter -1 != -1 null) -1 { -1 defineSlot(astParameter, -1 functionNode, -1 ---- -1 ---jsDocParameter.getJSType(), -1 ---true); -1 ++++ -1 +++jsDocParameter.getJSType(), -1 +++false); -1 jsDocParameter -1 = -1 jsDocParameter.getNext(); -1 } -1 else -1 { -1 defineSlot(astParameter, -1 functionNode, -1 null, -1 true); -1 -2
private -1 void -1 makeLocalNamesUnique(Node -1 fnNode, -1 boolean -1 isCallInLoop) -1 { -1 "inline_", -1 isCallInLoop))); -1 // -1 Make -1 label -1 names -1 unique -1 to -1 this -1 instance. -1 ++++ -1 +++new -1 +++RenameLabels(compiler, -1 +++new -1 +++LabelNameSupplier(idSupplier), -1 +++false) -1 ++++ -1 +++.process(null, -1 +++fnNode); -1 } -1 static -1 class -1 LabelNameSupplier -1 implements -1 Supplier<String> -1 { -1 ------ -1 ---a/src/com/google/javascript/jscomp/RenameLabels.java -1 ++++++ -1 +++b/src/com/google/javascript/jscomp/RenameLabels.java -1 @@ -1 -212,7 -1 +212,7 -1 @@ -1 private -1 void -1 visitLabel(Node -1 node, -1 Node -1 parent) -1 { -1 String -1 name -1 = -1 nameNode.getString(); -1 LabelInfo -1 li -1 = -1 getLabelInfo(name); -1 // -1 This -1 is -1 a -1 label... -1 ---- -1 ---if -1 ---(li.referenced) -1 ---{ -1 ++++ -1 +++if -1 +++(li.referenced -1 +++|| -1 +++!removeUnused) -1 +++{ -1 String -1 newName -1 = -1 getNameForId(li.id); -1 if -1 (!name.equals(newName)) -1 { -1 // -1 ... -1 and -1 it -1 is -1 used, -1 give -1 it -1 the -1 short -1 name. -1 -2
private -1 boolean -1 isVariableStillLiveWithinExpression( -1 // -1 If -1 the -1 currently -1 node -1 is -1 the -1 first -1 child -1 of -1 // -1 AND/OR, -1 be -1 conservative -1 only -1 consider -1 the -1 READs -1 // -1 of -1 the -1 second -1 operand. -1 ++++ -1 +++if -1 +++(n.getNext() -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++state -1 +++= -1 +++isVariableReadBeforeKill( -1 ++++ -1 +++n.getNext(), -1 +++variable); -1 ++++ -1 +++if -1 +++(state -1 +++== -1 +++VariableLiveness.KILL) -1 +++{ -1 ++++ -1 +++state -1 +++= -1 +++VariableLiveness.MAYBE_LIVE; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++break; -1 case -1 Token.HOOK: -1 // -1 If -1 current -1 node -1 is -1 the -1 condition, -1 check -1 each -1 following -1 // -1 branch, -1 otherwise -1 it -1 is -1 a -1 conditional -1 branch -1 and -1 the -1 // -1 other -1 branch -1 can -1 be -1 ignored. -1 ++++ -1 +++if -1 +++(n.getNext() -1 +++!= -1 +++null -1 +++&& -1 +++n.getNext().getNext() -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++state -1 +++= -1 +++checkHookBranchReadBeforeKill( -1 ++++ -1 +++n.getNext(), -1 +++n.getNext().getNext(), -1 +++variable); -1 ++++ -1 +++} -1 ++++ -1 +++break; -1 default: -1 for(Node -1 sibling -1 = -1 n.getNext(); -1 sibling -1 != -1 null; -1 sibling -1 = -1 sibling.getNext()) -1 { -1 ---- -1 ---if -1 ---(!ControlFlowGraph.isEnteringNewCfgNode(sibling)) -1 ---{ -1 state -1 = -1 isVariableReadBeforeKill(sibling, -1 variable); -1 ++++ -1 +++if -1 +++(state -1 +++!= -1 +++VariableLiveness.MAYBE_LIVE) -1 +++{ -1 ++++ -1 +++break; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++} -1 // -1 If -1 we -1 see -1 a -1 READ -1 or -1 KILL -1 there -1 is -1 no -1 need -1 to -1 continue. -1 if -1 (state -1 == -1 VariableLiveness.READ) -1 { -1 return -1 true; -1 } -1 else -1 if -1 (state -1 == -1 VariableLiveness.KILL) -1 { -1 return -1 false; -1 ---- -1 ---} -1 ---- -1 ---} -1 ---- -1 ---} -1 } -1 n -1 = -1 n.getParent(); -1 } -1 @@ -1 -337,6 -1 +351,9 -1 @@ -1 private -1 boolean -1 isVariableStillLiveWithinExpression( -1 */ -1 private -1 VariableLiveness -1 isVariableReadBeforeKill( -1 Node -1 n, -1 String -1 variable) -1 { -1 ++++ -1 +++if -1 +++(ControlFlowGraph.isEnteringNewCfgNode(n)) -1 +++{ -1 +++// -1 +++Not -1 +++a -1 +++FUNCTION -1 ++++ -1 +++return -1 +++VariableLiveness.MAYBE_LIVE; -1 ++++ -1 +++} -1 if -1 (NodeUtil.isName(n) -1 && -1 variable.equals(n.getString())) -1 { -1 if -1 (NodeUtil.isLhs(n, -1 n.getParent())) -1 { -1 @@ -1 -359,9 -1 +376,25 -1 @@ -1 private -1 VariableLiveness -1 isVariableReadBeforeKill( -1 // -1 Conditionals -1 case -1 Token.OR: -1 case -1 Token.AND: -1 ++++ -1 +++VariableLiveness -1 +++v1 -1 +++= -1 +++isVariableReadBeforeKill( -1 ++++ -1 +++n.getFirstChild(), -1 +++variable); -1 ++++ -1 +++VariableLiveness -1 +++v2 -1 +++= -1 +++isVariableReadBeforeKill( -1 ++++ -1 +++n.getLastChild(), -1 +++variable); -1 // -1 With -1 a -1 AND/OR -1 the -1 first -1 branch -1 always -1 runs, -1 but -1 the -1 second -1 is -1 // -1 may -1 not. -1 ++++ -1 +++if -1 +++(v1 -1 +++!= -1 +++VariableLiveness.MAYBE_LIVE) -1 +++{ -1 ++++ -1 +++return -1 +++v1; -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(v2 -1 +++== -1 +++VariableLiveness.READ) -1 +++{ -1 ++++ -1 +++return -1 +++VariableLiveness.READ; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++return -1 +++VariableLiveness.MAYBE_LIVE; -1 ++++ -1 +++} -1 case -1 Token.HOOK: -1 ++++ -1 +++VariableLiveness -1 +++first -1 +++= -1 +++isVariableReadBeforeKill( -1 ++++ -1 +++n.getFirstChild(), -1 +++variable); -1 ++++ -1 +++if -1 +++(first -1 +++!= -1 +++VariableLiveness.MAYBE_LIVE) -1 +++{ -1 ++++ -1 +++return -1 +++first; -1 ++++ -1 +++} -1 return -1 checkHookBranchReadBeforeKill( -1 n.getFirstChild().getNext(), -1 n.getLastChild(), -1 variable); -1 @@ -1 -369,13 -1 +402,11 -1 @@ -1 private -1 VariableLiveness -1 isVariableReadBeforeKill( -1 // -1 Expressions -1 are -1 evaluated -1 left-right, -1 depth -1 first. -1 for -1 (Node -1 child -1 = -1 n.getFirstChild(); -1 child -1 != -1 null; -1 child -1 = -1 child.getNext()) -1 { -1 ---- -1 ---if -1 ---(!ControlFlowGraph.isEnteringNewCfgNode(child)) -1 ---{ -1 ---// -1 ---Not -1 ---a -1 ---FUNCTION -1 VariableLiveness -1 state -1 = -1 isVariableReadBeforeKill(child, -1 variable); -1 if -1 (state -1 != -1 VariableLiveness.MAYBE_LIVE) -1 { -1 return -1 state; -1 } -1 } -1 ---- -1 ---} -1 } -1 return -1 VariableLiveness.MAYBE_LIVE; -1 -2
private -1 void -1 reportCodeChange(String -1 changeDescription) -1 { -1 public -1 void -1 process(Node -1 externs, -1 Node -1 root) -1 { -1 new -1 NodeTraversal( -1 compiler, -1 new -1 NormalizeStatements(compiler, -1 assertOnChange)) -1 ---- -1 ---.traverse(root); -1 ++++ -1 +++.traverseRoots(externs, -1 +++root); -1 if -1 (MAKE_LOCAL_NAMES_UNIQUE) -1 { -1 MakeDeclaredNamesUnique -1 renamer -1 = -1 new -1 MakeDeclaredNamesUnique(); -1 NodeTraversal -1 t -1 = -1 new -1 NodeTraversal(compiler, -1 renamer); -1 ------ -1 ---a/src/com/google/javascript/jscomp/VarCheck.java -1 ++++++ -1 +++b/src/com/google/javascript/jscomp/VarCheck.java -1 @@ -1 -218,6 -1 +218,7 -1 @@ -1 private -1 void -1 createSynthesizedExternVar(String -1 varName) -1 { -1 getSynthesizedExternsRoot().addChildToBack( -1 new -1 Node(Token.VAR, -1 nameNode)); -1 varsToDeclareInExterns.remove(varName); -1 ++++ -1 +++compiler.reportCodeChange(); -1 } -1 /** -1 -2
static -1 String -1 strEscape(String -1 s, -1 char -1 quote, -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 s.length(); -1 i++) -1 { -1 char -1 c -1 = -1 s.charAt(i); -1 switch -1 (c) -1 { -1 ++++ -1 +++case -1 +++'\0': -1 +++sb.append("\\0"); -1 +++break; -1 case -1 '\n': -1 sb.append("\\n"); -1 break; -1 case -1 '\r': -1 sb.append("\\r"); -1 break; -1 case -1 '\t': -1 sb.append("\\t"); -1 break; -1 -2
static -1 Double -1 getNumberValue(Node -1 n) -1 { -1 } -1 static -1 Double -1 getStringNumberValue(String -1 rawJsString) -1 { -1 ++++ -1 +++if -1 +++(rawJsString.contains("\u000b")) -1 +++{ -1 // -1 vertical -1 tab -1 is -1 not -1 always -1 whitespace -1 ++++ -1 +++return -1 +++null; -1 ++++ -1 +++} -1 String -1 s -1 = -1 trimJsWhiteSpace(rawJsString); -1 // -1 return -1 ScriptRuntime.toNumber(s); -1 @@ -1 -372,7 -1 +375,7 -1 @@ -1 static -1 String -1 trimJsWhiteSpace(String -1 s) -1 { -1 static -1 TernaryValue -1 isStrWhiteSpaceChar(int -1 c) -1 { -1 switch -1 (c) -1 { -1 case -1 '\u000B': -1 // -1 <VT> -1 ---- -1 ---return -1 ---TernaryValue.TRUE; -1 ++++ -1 +++return -1 +++TernaryValue.UNKNOWN; -1 +++// -1 +++IE -1 +++says -1 +++"no", -1 +++EcmaScript -1 +++says -1 +++"yes" -1 case -1 ' -1 ': -1 // -1 <SP> -1 case -1 '\n': -1 // -1 <LF> -1 case -1 '\r': -1 // -1 <CR> -1 -2
private -1 Node -1 performArithmeticOp(int -1 opType, -1 Node -1 left, -1 Node -1 right) -1 { -1 break; -1 case -1 Token.MOD: -1 if -1 (rval -1 == -1 0) -1 { -1 ---- -1 ---error(DiagnosticType.error("JSC_DIVIDE_BY_0_ERROR", -1 ---"Divide -1 ---by -1 ---0"), -1 ---right); -1 return -1 null; -1 } -1 result -1 = -1 lval -1 % -1 rval; -1 break; -1 case -1 Token.DIV: -1 if -1 (rval -1 == -1 0) -1 { -1 ---- -1 ---error(DiagnosticType.error("JSC_DIVIDE_BY_0_ERROR", -1 ---"Divide -1 ---by -1 ---0"), -1 ---right); -1 return -1 null; -1 } -1 result -1 = -1 lval -1 / -1 rval; -1 -2
public -1 BooleanOptionHandler( -1 @Override -1 public -1 int -1 parseArguments(Parameters -1 params) -1 throws -1 CmdLineException -1 { -1 ---- -1 ---String -1 ---param -1 ---= -1 ---params.getParameter(0); -1 ++++ -1 +++String -1 +++param -1 +++= -1 +++null; -1 ++++ -1 +++try -1 +++{ -1 ++++ -1 +++param -1 +++= -1 +++params.getParameter(0); -1 ++++ -1 +++} -1 +++catch -1 +++(CmdLineException -1 +++e) -1 +++{} -1 if -1 (param -1 == -1 null) -1 { -1 setter.addValue(true); -1 -2
static -1 boolean -1 isBooleanResultHelper(Node -1 n) -1 { -1 // -1 Inversion -1 case -1 Token.NOT: -1 // -1 delete -1 operator -1 returns -1 a -1 boolean. -1 ++++ -1 +++case -1 +++Token.DELPROP: -1 return -1 true; -1 default: -1 return -1 false; -1 @@ -1 -2907,6 -1 +2908,7 -1 @@ -1 static -1 boolean -1 evaluatesToLocalValue(Node -1 value, -1 Predicate<Node> -1 locals) -1 { -1 case -1 Token.OBJECTLIT: -1 // -1 Literals -1 objects -1 with -1 non-literal -1 children -1 are -1 allowed. -1 return -1 true; -1 ++++ -1 +++case -1 +++Token.DELPROP: -1 case -1 Token.IN: -1 // -1 TODO(johnlenz): -1 should -1 IN -1 operator -1 be -1 included -1 in -1 #isSimpleOperator? -1 return -1 true; -1 -2
Node -1 processFunctionNode(FunctionNode -1 functionNode) -1 { -1 Name -1 name -1 = -1 functionNode.getFunctionName(); -1 Boolean -1 isUnnamedFunction -1 = -1 false; -1 if -1 (name -1 == -1 null) -1 { -1 ++++ -1 +++int -1 +++functionType -1 +++= -1 +++functionNode.getFunctionType(); -1 ++++ -1 +++if -1 +++(functionType -1 +++!= -1 +++FunctionNode.FUNCTION_EXPRESSION) -1 +++{ -1 ++++ -1 +++errorReporter.error( -1 ++++ -1 +++"unnamed -1 +++function -1 +++statement", -1 ++++ -1 +++sourceName, -1 ++++ -1 +++functionNode.getLineno(), -1 +++"", -1 +++0); -1 ++++ -1 +++} -1 name -1 = -1 new -1 Name(); -1 name.setIdentifier(""); -1 isUnnamedFunction -1 = -1 true; -1 -2
public -1 boolean -1 isNoObjectType() -1 { -1 } -1 public -1 final -1 boolean -1 isEmptyType() -1 { -1 ---- -1 ---return -1 ---isNoType() -1 ---|| -1 ---isNoObjectType() -1 ---|| -1 ---isNoResolvedType(); -1 ++++ -1 +++return -1 +++isNoType() -1 +++|| -1 +++isNoObjectType() -1 +++|| -1 +++isNoResolvedType() -1 +++|| -1 ++++ -1 +++(registry.getNativeFunctionType( -1 ++++ -1 +++JSTypeNative.LEAST_FUNCTION_TYPE) -1 +++== -1 +++this); -1 } -1 public -1 boolean -1 isNumberObjectType() -1 { -1 -2
private -1 Node -1 tryRemoveUnconditionalBranching(Node -1 n) -1 { -1 return -1 n; -1 } -1 ---- -1 ---if -1 ---(n.getParent() -1 ---== -1 ---null) -1 ---{ -1 ---- -1 ---List<DiGraphEdge<Node,Branch>> -1 ---outEdges -1 ---= -1 ---gNode.getOutEdges(); -1 ---- -1 ---if -1 ---(outEdges.size() -1 ---== -1 ---1) -1 ---{ -1 ---- -1 ---return -1 ---tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue()); -1 ---- -1 ---} -1 ---- -1 ---} -1 switch -1 (n.getType()) -1 { -1 ---- -1 ---case -1 ---Token.BLOCK: -1 ---- -1 ---if -1 ---(n.hasChildren()) -1 ---{ -1 ---- -1 ---Node -1 ---first -1 ---= -1 ---n.getFirstChild(); -1 ---- -1 ---return -1 ---tryRemoveUnconditionalBranching(first); -1 ---- -1 ---} -1 ---else -1 ---{ -1 ---- -1 ---return -1 ---tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n)); -1 ---- -1 ---} -1 case -1 Token.RETURN: -1 if -1 (n.hasChildren()) -1 { -1 break; -1 @@ -1 -180,7 -1 +167,7 -1 @@ -1 private -1 Node -1 tryRemoveUnconditionalBranching(Node -1 n) -1 { -1 (n.getNext() -1 == -1 null -1 || -1 n.getNext().getType() -1 == -1 Token.FUNCTION)) -1 { -1 Preconditions.checkState(outEdges.get(0).getValue() -1 == -1 Branch.UNCOND); -1 ---- -1 ---Node -1 ---fallThrough -1 ---= -1 ---tryRemoveUnconditionalBranching(computeFollowing(n)); -1 ++++ -1 +++Node -1 +++fallThrough -1 +++= -1 +++computeFollowing(n); -1 Node -1 nextCfgNode -1 = -1 outEdges.get(0).getDestination().getValue(); -1 if -1 (nextCfgNode -1 == -1 fallThrough) -1 { -1 removeDeadExprStatementSafely(n); -1 @@ -1 -193,6 -1 +180,13 -1 @@ -1 private -1 Node -1 tryRemoveUnconditionalBranching(Node -1 n) -1 { -1 private -1 Node -1 computeFollowing(Node -1 n) -1 { -1 Node -1 next -1 = -1 ControlFlowAnalysis.computeFollowNode(n); -1 ++++ -1 +++while -1 +++(next -1 +++!= -1 +++null -1 +++&& -1 +++next.getType() -1 +++== -1 +++Token.BLOCK) -1 +++{ -1 ++++ -1 +++if -1 +++(next.hasChildren()) -1 +++{ -1 ++++ -1 +++next -1 +++= -1 +++next.getFirstChild(); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++next -1 +++= -1 +++computeFollowing(next); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 return -1 next; -1 } -1 -2
static -1 boolean -1 evaluatesToLocalValue(Node -1 value, -1 Predicate<Node> -1 locals) -1 { -1 // -1 TODO(nicksantos): -1 This -1 needs -1 to -1 be -1 changed -1 so -1 that -1 it -1 // -1 returns -1 true -1 iff -1 we're -1 sure -1 the -1 value -1 was -1 never -1 aliased -1 from -1 inside -1 // -1 the -1 constructor -1 (similar -1 to -1 callHasLocalResult) -1 ---- -1 ---return -1 ---true; -1 ++++ -1 +++return -1 +++false; -1 case -1 Token.FUNCTION: -1 case -1 Token.REGEXP: -1 case -1 Token.ARRAYLIT: -1 -2
Node -1 processArrayLiteral(ArrayLiteral -1 literalNode) -1 { -1 @Override -1 Node -1 processAssignment(Assignment -1 assignmentNode) -1 { -1 Node -1 assign -1 = -1 processInfixExpression(assignmentNode); -1 ++++ -1 +++Node -1 +++target -1 +++= -1 +++assign.getFirstChild(); -1 ++++ -1 +++if -1 +++(!validAssignmentTarget(target)) -1 +++{ -1 ++++ -1 +++errorReporter.error( -1 ++++ -1 +++"invalid -1 +++assignment -1 +++target", -1 ++++ -1 +++sourceName, -1 ++++ -1 +++target.getLineno(), -1 +++"", -1 +++0); -1 ++++ -1 +++} -1 return -1 assign; -1 } -1 @@ -1 -794,6 -1 +801,17 -1 @@ -1 Node -1 processUnaryExpression(UnaryExpression -1 exprNode) -1 { -1 operand.setDouble(-operand.getDouble()); -1 return -1 operand; -1 } -1 else -1 { -1 ++++ -1 +++if -1 +++(type -1 +++== -1 +++Token.INC -1 +++|| -1 +++type -1 +++== -1 +++Token.DEC) -1 +++{ -1 ++++ -1 +++if -1 +++(!validAssignmentTarget(operand)) -1 +++{ -1 ++++ -1 +++String -1 +++msg -1 +++= -1 +++(type -1 +++== -1 +++Token.INC) -1 ++++ -1 +++? -1 +++"invalid -1 +++increment -1 +++target" -1 ++++ -1 +++: -1 +++"invalid -1 +++decrement -1 +++target"; -1 ++++ -1 +++errorReporter.error( -1 ++++ -1 +++msg, -1 ++++ -1 +++sourceName, -1 ++++ -1 +++operand.getLineno(), -1 +++"", -1 +++0); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 Node -1 node -1 = -1 newNode(type, -1 operand); -1 if -1 (exprNode.isPostfix()) -1 { -1 @@ -1 -803,6 -1 +821,15 -1 @@ -1 Node -1 processUnaryExpression(UnaryExpression -1 exprNode) -1 { -1 } -1 } -1 ++++ -1 +++private -1 +++boolean -1 +++validAssignmentTarget(Node -1 +++target) -1 +++{ -1 ++++ -1 +++switch -1 +++(target.getType()) -1 +++{ -1 ++++ -1 +++case -1 +++Token.NAME: -1 ++++ -1 +++case -1 +++Token.GETPROP: -1 ++++ -1 +++case -1 +++Token.GETELEM: -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 @Override -1 Node -1 processVariableDeclaration(VariableDeclaration -1 declarationNode) -1 { -1 -2
private -1 void -1 updateSimpleDeclaration(String -1 alias, -1 Name -1 refName, -1 Ref -1 ref) -1 { -1 Node -1 greatGramps -1 = -1 gramps.getParent(); -1 Node -1 greatGreatGramps -1 = -1 greatGramps.getParent(); -1 ++++ -1 +++if -1 +++(rvalue -1 +++!= -1 +++null -1 +++&& -1 +++rvalue.getType() -1 +++== -1 +++Token.FUNCTION) -1 +++{ -1 ++++ -1 +++checkForHosedThisReferences(rvalue, -1 +++refName.docInfo, -1 +++refName); -1 ++++ -1 +++} -1 // -1 Create -1 the -1 new -1 alias -1 node. -1 Node -1 nameNode -1 = -1 NodeUtil.newName( -1 ------ -1 ---a/src/com/google/javascript/jscomp/GlobalNamespace.java -1 ++++++ -1 +++b/src/com/google/javascript/jscomp/GlobalNamespace.java -1 @@ -1 -917,7 -1 +917,7 -1 @@ -1 boolean -1 canCollapseUnannotatedChildNames() -1 { -1 } -1 // -1 If -1 this -1 is -1 aliased, -1 then -1 its -1 properties -1 can't -1 be -1 collapsed -1 either. -1 ---- -1 ---if -1 ---(type -1 ---!= -1 ---Type.FUNCTION -1 ---&& -1 ---aliasingGets -1 ---> -1 ---0) -1 ---{ -1 ++++ -1 +++if -1 +++(aliasingGets -1 +++> -1 +++0) -1 +++{ -1 return -1 false; -1 } -1 -2
private -1 VariableLiveness -1 isVariableReadBeforeKill( -1 Node -1 n, -1 String -1 variable) -1 { -1 if -1 (NodeUtil.isName(n) -1 && -1 variable.equals(n.getString())) -1 { -1 if -1 (NodeUtil.isLhs(n, -1 n.getParent())) -1 { -1 ++++ -1 +++Preconditions.checkState(n.getParent().getType() -1 +++== -1 +++Token.ASSIGN); -1 // -1 The -1 expression -1 to -1 which -1 the -1 assignment -1 is -1 made -1 is -1 evaluated -1 before -1 // -1 the -1 RHS -1 is -1 evaluated -1 (normal -1 left -1 to -1 right -1 evaluation) -1 but -1 the -1 KILL -1 // -1 occurs -1 after -1 the -1 RHS -1 is -1 evaluated. -1 ++++ -1 +++Node -1 +++rhs -1 +++= -1 +++n.getNext(); -1 ++++ -1 +++VariableLiveness -1 +++state -1 +++= -1 +++isVariableReadBeforeKill(rhs, -1 +++variable); -1 ++++ -1 +++if -1 +++(state -1 +++== -1 +++VariableLiveness.READ) -1 +++{ -1 ++++ -1 +++return -1 +++state; -1 ++++ -1 +++} -1 return -1 VariableLiveness.KILL; -1 } -1 else -1 { -1 return -1 VariableLiveness.READ; -1 -2
private -1 boolean -1 isFoldableExpressBlock(Node -1 n) -1 { -1 if -1 (n.getType() -1 == -1 Token.BLOCK) -1 { -1 if -1 (n.hasOneChild()) -1 { -1 Node -1 maybeExpr -1 = -1 n.getFirstChild(); -1 ++++ -1 +++if -1 +++(maybeExpr.getType() -1 +++== -1 +++Token.EXPR_RESULT) -1 +++{ -1 // -1 IE -1 has -1 a -1 bug -1 where -1 event -1 handlers -1 behave -1 differently -1 when -1 // -1 their -1 return -1 value -1 is -1 used -1 vs. -1 when -1 their -1 return -1 value -1 is -1 in -1 // -1 an -1 EXPR_RESULT. -1 It's -1 pretty -1 freaking -1 weird. -1 See: -1 // -1 http://code.google.com/p/closure-compiler/issues/detail?id=291 -1 // -1 We -1 try -1 to -1 detect -1 this -1 case, -1 and -1 not -1 fold -1 EXPR_RESULTs -1 // -1 into -1 other -1 expressions. -1 ++++ -1 +++if -1 +++(maybeExpr.getFirstChild().getType() -1 +++== -1 +++Token.CALL) -1 +++{ -1 ++++ -1 +++Node -1 +++calledFn -1 +++= -1 +++maybeExpr.getFirstChild().getFirstChild(); -1 // -1 We -1 only -1 have -1 to -1 worry -1 about -1 methods -1 with -1 an -1 implicit -1 'this' -1 // -1 param, -1 or -1 this -1 doesn't -1 happen. -1 ++++ -1 +++if -1 +++(calledFn.getType() -1 +++== -1 +++Token.GETELEM) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(calledFn.getType() -1 +++== -1 +++Token.GETPROP -1 +++&& -1 ++++ -1 +++calledFn.getLastChild().getString().startsWith("on")) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ---- -1 ---return -1 ---NodeUtil.isExpressionNode(maybeExpr); -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++false; -1 } -1 } -1 -2
void -1 replace() -1 { -1 } -1 else -1 { -1 // -1 In -1 this -1 case, -1 the -1 name -1 was -1 implicitly -1 provided -1 by -1 two -1 independent -1 // -1 modules. -1 We -1 need -1 to -1 move -1 this -1 code -1 up -1 to -1 a -1 common -1 module. -1 ---- -1 ---int -1 ---indexOfDot -1 ---= -1 ---namespace.indexOf('.'); -1 ++++ -1 +++int -1 +++indexOfDot -1 +++= -1 +++namespace.lastIndexOf('.'); -1 if -1 (indexOfDot -1 == -1 -1) -1 { -1 // -1 Any -1 old -1 place -1 is -1 fine. -1 compiler.getNodeForCodeInsertion(minimumModule) -1 -2
void -1 defineSlot(Node -1 n, -1 Node -1 parent, -1 JSType -1 type, -1 boolean -1 inferred) -1 { -1 // -1 scope -1 where -1 the -1 root -1 object -1 appears. -1 This -1 helps -1 out -1 people -1 // -1 who -1 declare -1 "global" -1 names -1 in -1 an -1 anonymous -1 namespace. -1 Scope -1 scopeToDeclareIn -1 = -1 scope; -1 ++++ -1 +++if -1 +++(n.getType() -1 +++== -1 +++Token.GETPROP -1 +++&& -1 +++!scope.isGlobal() -1 +++&& -1 ++++ -1 +++isQnameRootedInGlobalScope(n)) -1 +++{ -1 ++++ -1 +++Scope -1 +++globalScope -1 +++= -1 +++scope.getGlobalScope(); -1 // -1 don't -1 try -1 to -1 declare -1 in -1 the -1 global -1 scope -1 if -1 there's -1 // -1 already -1 a -1 symbol -1 there -1 with -1 this -1 name. -1 ++++ -1 +++if -1 +++(!globalScope.isDeclared(variableName, -1 +++false)) -1 +++{ -1 ++++ -1 +++scopeToDeclareIn -1 +++= -1 +++scope.getGlobalScope(); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 // -1 declared -1 in -1 closest -1 scope? -1 if -1 (scopeToDeclareIn.isDeclared(variableName, -1 false)) -1 { -1 -2
public -1 boolean -1 apply(JSType -1 type) -1 { -1 // -1 create -1 interfaces -1 JSType, -1 ObjectType, -1 FunctionType -1 etc -1 and -1 have -1 // -1 separate -1 implementation -1 instead -1 of -1 the -1 class -1 hierarchy, -1 so -1 that -1 // -1 union -1 types -1 can -1 also -1 be -1 object -1 types, -1 etc. -1 ---- -1 ---if -1 ---(!type.isSubtype( -1 ++++ -1 +++if -1 +++(!type.restrictByNotNullOrUndefined().isSubtype( -1 typeRegistry.getNativeType(OBJECT_TYPE))) -1 { -1 reportWarning(THIS_TYPE_NON_OBJECT, -1 type.toString()); -1 return -1 false; -1 ------ -1 ---a/src/com/google/javascript/rhino/jstype/FunctionType.java -1 ++++++ -1 +++b/src/com/google/javascript/rhino/jstype/FunctionType.java -1 @@ -1 -877,6 -1 +877,9 -1 @@ -1 JSType -1 resolveInternal(ErrorReporter -1 t, -1 StaticScope<JSType> -1 scope) -1 { -1 // -1 mean -1 "nullable -1 Foo". -1 For -1 certain -1 tags -1 (like -1 @extends) -1 we -1 de-nullify -1 // -1 the -1 name -1 for -1 them. -1 JSType -1 maybeTypeOfThis -1 = -1 safeResolve(typeOfThis, -1 t, -1 scope); -1 ++++ -1 +++if -1 +++(maybeTypeOfThis -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++maybeTypeOfThis -1 +++= -1 +++maybeTypeOfThis.restrictByNotNullOrUndefined(); -1 ++++ -1 +++} -1 if -1 (maybeTypeOfThis -1 instanceof -1 ObjectType) -1 { -1 typeOfThis -1 = -1 (ObjectType) -1 maybeTypeOfThis; -1 } -1 -2
static -1 boolean -1 isValidDefineValue(Node -1 val, -1 Set<String> -1 defines) -1 { -1 return -1 true; -1 // -1 Binary -1 operators -1 are -1 only -1 valid -1 if -1 both -1 children -1 are -1 valid. -1 ++++ -1 +++case -1 +++Token.ADD: -1 case -1 Token.BITAND: -1 case -1 Token.BITNOT: -1 case -1 Token.BITOR: -1 case -1 Token.BITXOR: -1 ++++ -1 +++case -1 +++Token.DIV: -1 ++++ -1 +++case -1 +++Token.EQ: -1 ++++ -1 +++case -1 +++Token.GE: -1 ++++ -1 +++case -1 +++Token.GT: -1 ++++ -1 +++case -1 +++Token.LE: -1 ++++ -1 +++case -1 +++Token.LSH: -1 ++++ -1 +++case -1 +++Token.LT: -1 ++++ -1 +++case -1 +++Token.MOD: -1 ++++ -1 +++case -1 +++Token.MUL: -1 ++++ -1 +++case -1 +++Token.NE: -1 ++++ -1 +++case -1 +++Token.RSH: -1 ++++ -1 +++case -1 +++Token.SHEQ: -1 ++++ -1 +++case -1 +++Token.SHNE: -1 ++++ -1 +++case -1 +++Token.SUB: -1 ++++ -1 +++case -1 +++Token.URSH: -1 ++++ -1 +++return -1 +++isValidDefineValue(val.getFirstChild(), -1 +++defines) -1 ++++ -1 +++&& -1 +++isValidDefineValue(val.getLastChild(), -1 +++defines); -1 // -1 Uniary -1 operators -1 are -1 valid -1 if -1 the -1 child -1 is -1 valid. -1 case -1 Token.NOT: -1 case -1 Token.NEG: -1 ++++ -1 +++case -1 +++Token.POS: -1 return -1 isValidDefineValue(val.getFirstChild(), -1 defines); -1 // -1 Names -1 are -1 valid -1 if -1 and -1 only -1 if -1 they -1 are -1 defines -1 themselves. -1 -2
public -1 boolean -1 shouldTraverse(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 } -1 // -1 Don't -1 traverse -1 functions -1 that -1 are -1 getting -1 lent -1 to -1 a -1 prototype. -1 ++++ -1 +++Node -1 +++gramps -1 +++= -1 +++parent.getParent(); -1 ++++ -1 +++if -1 +++(NodeUtil.isObjectLitKey(parent, -1 +++gramps)) -1 +++{ -1 ++++ -1 +++JSDocInfo -1 +++maybeLends -1 +++= -1 +++gramps.getJSDocInfo(); -1 ++++ -1 +++if -1 +++(maybeLends -1 +++!= -1 +++null -1 +++&& -1 ++++ -1 +++maybeLends.getLendsName() -1 +++!= -1 +++null -1 +++&& -1 ++++ -1 +++maybeLends.getLendsName().endsWith(".prototype")) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 } -1 if -1 (parent -1 != -1 null -1 && -1 parent.getType() -1 == -1 Token.ASSIGN) -1 { -1 -2
void -1 replace() -1 { -1 } -1 else -1 { -1 // -1 In -1 this -1 case, -1 the -1 name -1 was -1 implicitly -1 provided -1 by -1 two -1 independent -1 // -1 modules. -1 We -1 need -1 to -1 move -1 this -1 code -1 up -1 to -1 a -1 common -1 module. -1 ---- -1 ---int -1 ---indexOfDot -1 ---= -1 ---namespace.indexOf('.'); -1 ++++ -1 +++int -1 +++indexOfDot -1 +++= -1 +++namespace.lastIndexOf('.'); -1 if -1 (indexOfDot -1 == -1 -1) -1 { -1 // -1 Any -1 old -1 place -1 is -1 fine. -1 compiler.getNodeForCodeInsertion(minimumModule) -1 -2
private -1 Node -1 tryFoldShift(Node -1 n, -1 Node -1 left, -1 Node -1 right) -1 { -1 // -1 JavaScript -1 handles -1 zero -1 shifts -1 on -1 signed -1 numbers -1 differently -1 than -1 // -1 Java -1 as -1 an -1 Java -1 int -1 can -1 not -1 represent -1 the -1 unsigned -1 32-bit -1 number -1 // -1 where -1 JavaScript -1 can -1 so -1 use -1 a -1 long -1 here. -1 ---- -1 ---result -1 ---= -1 ---lvalInt -1 --->>> -1 ---rvalInt; -1 ++++ -1 +++long -1 +++lvalLong -1 +++= -1 +++lvalInt -1 +++& -1 +++0xffffffffL; -1 ++++ -1 +++result -1 +++= -1 +++lvalLong -1 +++>>> -1 +++rvalInt; -1 break; -1 default: -1 throw -1 new -1 AssertionError("Unknown -1 shift -1 operator: -1 " -1 + -1 -2
private -1 void -1 visitParameterList(NodeTraversal -1 t, -1 Node -1 call, -1 Node -1 parameter -1 = -1 null; -1 Node -1 argument -1 = -1 null; -1 while -1 (arguments.hasNext() -1 && -1 ---- -1 ---parameters.hasNext()) -1 ---{ -1 ++++ -1 +++(parameters.hasNext() -1 +++|| -1 ++++ -1 +++parameter -1 +++!= -1 +++null -1 +++&& -1 +++parameter.isVarArgs())) -1 +++{ -1 // -1 If -1 there -1 are -1 no -1 parameters -1 left -1 in -1 the -1 list, -1 then -1 the -1 while -1 loop -1 // -1 above -1 implies -1 that -1 this -1 must -1 be -1 a -1 var_args -1 function. -1 ++++ -1 +++if -1 +++(parameters.hasNext()) -1 +++{ -1 parameter -1 = -1 parameters.next(); -1 ++++ -1 +++} -1 argument -1 = -1 arguments.next(); -1 ordinal++; -1 -2
protected -1 CompilerOptions -1 createOptions() -1 { -1 for -1 (FormattingOption -1 formattingOption -1 : -1 flags.formatting) -1 { -1 formattingOption.applyToOptions(options); -1 } -1 ---- -1 ---if -1 ---(flags.process_closure_primitives) -1 ---{ -1 ---- -1 ---options.closurePass -1 ---= -1 ---true; -1 ---- -1 ---} -1 ++++ -1 +++options.closurePass -1 +++= -1 +++flags.process_closure_primitives; -1 initOptionsFromFlags(options); -1 return -1 options; -1 } -1 -2
public -1 boolean -1 shouldTraverse(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 // -1 var -1 a -1 = -1 function() -1 { -1 }; -1 // -1 or -1 // -1 function -1 a() -1 {} -1 // -1 or -1 // -1 a.x -1 = -1 function() -1 {}; -1 ++++ -1 +++int -1 +++pType -1 +++= -1 +++parent.getType(); -1 ++++ -1 +++if -1 +++(!(pType -1 +++== -1 +++Token.BLOCK -1 +++|| -1 ++++ -1 +++pType -1 +++== -1 +++Token.SCRIPT -1 +++|| -1 ++++ -1 +++pType -1 +++== -1 +++Token.NAME -1 +++|| -1 ++++ -1 +++pType -1 +++== -1 +++Token.ASSIGN)) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 } -1 if -1 (parent -1 != -1 null -1 && -1 parent.getType() -1 == -1 Token.ASSIGN) -1 { -1 @@ -1 -143,7 -1 +150,7 -1 @@ -1 private -1 boolean -1 shouldReportThis(Node -1 n, -1 Node -1 parent) -1 { -1 } -1 // -1 Also -1 report -1 a -1 THIS -1 with -1 a -1 property -1 access. -1 ---- -1 ---return -1 ---false; -1 ++++ -1 +++return -1 +++parent -1 +++!= -1 +++null -1 +++&& -1 +++NodeUtil.isGet(parent); -1 } -1 /** -1 -2
Reference -1 getInitializingReferenceForConstants() -1 { -1 boolean -1 isAssignedOnceInLifetime() -1 { -1 Reference -1 ref -1 = -1 getOneAndOnlyAssignment(); -1 if -1 (ref -1 == -1 null) -1 { -1 return -1 false; -1 } -1 // -1 Make -1 sure -1 this -1 assignment -1 is -1 not -1 in -1 a -1 loop. -1 ++++ -1 +++for -1 +++(BasicBlock -1 +++block -1 +++= -1 +++ref.getBasicBlock(); -1 ++++ -1 +++block -1 +++!= -1 +++null; -1 +++block -1 +++= -1 +++block.getParent()) -1 +++{ -1 ++++ -1 +++if -1 +++(block.isFunction) -1 +++{ -1 ++++ -1 +++break; -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(block.isLoop) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 return -1 true; -1 } -1 /** -1 * -1 @return -1 The -1 one -1 and -1 only -1 assignment. -1 Returns -1 if -1 there -1 are -1 0 -1 or -1 2+ -1 * -1 assignments. -1 */ -1 @@ -1 -523,41 -1 +531,52 -1 @@ -1 Scope -1 getScope() -1 { -1 public -1 String -1 getSourceName() -1 { -1 return -1 sourceName; -1 } -1 } -1 /** -1 * -1 Represents -1 a -1 section -1 of -1 code -1 that -1 is -1 uninterrupted -1 by -1 control -1 structures -1 * -1 (conditional -1 or -1 iterative -1 logic). -1 */ -1 static -1 final -1 class -1 BasicBlock -1 { -1 private -1 final -1 BasicBlock -1 parent; -1 /** -1 * -1 Determines -1 whether -1 the -1 block -1 may -1 not -1 be -1 part -1 of -1 the -1 normal -1 control -1 flow, -1 * -1 but -1 instead -1 "hoisted" -1 to -1 the -1 top -1 of -1 the -1 scope. -1 */ -1 private -1 final -1 boolean -1 isHoisted; -1 /** -1 * -1 Whether -1 this -1 block -1 denotes -1 a -1 function -1 scope. -1 */ -1 ++++ -1 +++private -1 +++final -1 +++boolean -1 +++isFunction; -1 /** -1 * -1 Whether -1 this -1 block -1 denotes -1 a -1 loop. -1 */ -1 ++++ -1 +++private -1 +++final -1 +++boolean -1 +++isLoop; -1 /** -1 * -1 Creates -1 a -1 new -1 block. -1 * -1 @param -1 parent -1 The -1 containing -1 block. -1 * -1 @param -1 root -1 The -1 root -1 node -1 of -1 the -1 block. -1 */ -1 BasicBlock(BasicBlock -1 parent, -1 Node -1 root) -1 { -1 this.parent -1 = -1 parent; -1 // -1 only -1 named -1 functions -1 may -1 be -1 hoisted. -1 this.isHoisted -1 = -1 NodeUtil.isHoistedFunctionDeclaration(root); -1 ++++ -1 +++this.isFunction -1 +++= -1 +++root.getType() -1 +++== -1 +++Token.FUNCTION; -1 ++++ -1 +++if -1 +++(root.getParent() -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++int -1 +++pType -1 +++= -1 +++root.getParent().getType(); -1 ++++ -1 +++this.isLoop -1 +++= -1 +++pType -1 +++== -1 +++Token.DO -1 +++|| -1 ++++ -1 +++pType -1 +++== -1 +++Token.WHILE -1 +++|| -1 ++++ -1 +++pType -1 +++== -1 +++Token.FOR; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++this.isLoop -1 +++= -1 +++false; -1 ++++ -1 +++} -1 } -1 -2
public -1 boolean -1 shouldTraverse(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 JSDocInfo -1 jsDoc -1 = -1 getFunctionJsDocInfo(n); -1 if -1 (jsDoc -1 != -1 null -1 && -1 (jsDoc.isConstructor() -1 || -1 ++++ -1 +++jsDoc.isInterface() -1 +++|| -1 jsDoc.hasThisType() -1 || -1 jsDoc.isOverride())) -1 { -1 return -1 false; -1 @@ -1 -122,13 -1 +123,17 -1 @@ -1 public -1 boolean -1 shouldTraverse(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 } -1 else -1 { -1 // -1 Only -1 traverse -1 the -1 right -1 side -1 if -1 it's -1 not -1 an -1 assignment -1 to -1 a -1 prototype -1 // -1 property -1 or -1 subproperty. -1 ++++ -1 +++if -1 +++(NodeUtil.isGet(lhs)) -1 +++{ -1 if -1 (lhs.getType() -1 == -1 Token.GETPROP -1 && -1 lhs.getLastChild().getString().equals("prototype")) -1 { -1 return -1 false; -1 } -1 ---- -1 ---if -1 ---(lhs.getQualifiedName() -1 ---!= -1 ---null -1 ---&& -1 ---lhs.getQualifiedName().contains(".prototype.")) -1 ---{ -1 ++++ -1 +++Node -1 +++llhs -1 +++= -1 +++lhs.getFirstChild(); -1 ++++ -1 +++if -1 +++(llhs.getType() -1 +++== -1 +++Token.GETPROP -1 +++&& -1 ++++ -1 +++llhs.getLastChild().getString().equals("prototype")) -1 +++{ -1 return -1 false; -1 } -1 ++++ -1 +++} -1 } -1 } -1 -2
JSType -1 meet(JSType -1 that) -1 { -1 builder.addAlternate(that); -1 } -1 JSType -1 result -1 = -1 builder.build(); -1 ---- -1 ---if -1 ---(result -1 ---!= -1 ---null) -1 ---{ -1 ++++ -1 +++if -1 +++(!result.isNoType()) -1 +++{ -1 return -1 result; -1 } -1 else -1 if -1 (this.isObject() -1 && -1 that.isObject()) -1 { -1 return -1 getNativeType(JSTypeNative.NO_OBJECT_TYPE); -1 -2
void -1 tryFoldStringJoin(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 left, -1 Node -1 right, -1 String -1 joinString -1 = -1 NodeUtil.getStringValue(right); -1 List<Node> -1 arrayFoldedChildren -1 = -1 Lists.newLinkedList(); -1 ---- -1 ---StringBuilder -1 ---sb -1 ---= -1 ---new -1 ---StringBuilder(); -1 ++++ -1 +++StringBuilder -1 +++sb -1 +++= -1 +++null; -1 int -1 foldedSize -1 = -1 0; -1 Node -1 elem -1 = -1 arrayNode.getFirstChild(); -1 // -1 Merges -1 adjacent -1 String -1 nodes. -1 while -1 (elem -1 != -1 null) -1 { -1 if -1 (NodeUtil.isImmutableValue(elem)) -1 { -1 ---- -1 ---if -1 ---(sb.length() -1 ---> -1 ---0) -1 ---{ -1 ++++ -1 +++if -1 +++(sb -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++sb -1 +++= -1 +++new -1 +++StringBuilder(); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 sb.append(joinString); -1 } -1 sb.append(NodeUtil.getStringValue(elem)); -1 } -1 else -1 { -1 ---- -1 ---if -1 ---(sb.length() -1 ---> -1 ---0) -1 ---{ -1 ++++ -1 +++if -1 +++(sb -1 +++!= -1 +++null) -1 +++{ -1 // -1 + -1 2 -1 for -1 the -1 quotes. -1 foldedSize -1 += -1 sb.length() -1 + -1 2; -1 arrayFoldedChildren.add(Node.newString(sb.toString())); -1 ---- -1 ---sb -1 ---= -1 ---new -1 ---StringBuilder(); -1 ++++ -1 +++sb -1 +++= -1 +++null; -1 } -1 foldedSize -1 += -1 InlineCostEstimator.getCost(elem); -1 arrayFoldedChildren.add(elem); -1 @@ -1 -1497,7 -1 +1499,7 -1 @@ -1 void -1 tryFoldStringJoin(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 left, -1 Node -1 right, -1 elem -1 = -1 elem.getNext(); -1 } -1 ---- -1 ---if -1 ---(sb.length() -1 ---> -1 ---0) -1 ---{ -1 ++++ -1 +++if -1 +++(sb -1 +++!= -1 +++null) -1 +++{ -1 // -1 + -1 2 -1 for -1 the -1 quotes. -1 foldedSize -1 += -1 sb.length() -1 + -1 2; -1 arrayFoldedChildren.add(Node.newString(sb.toString())); -1 -2
boolean -1 canCollapseUnannotatedChildNames() -1 { -1 // -1 Don't -1 try -1 to -1 collapse -1 if -1 the -1 one -1 global -1 set -1 is -1 a -1 twin -1 reference. -1 // -1 We -1 could -1 theoretically -1 handle -1 this -1 case -1 in -1 CollapseProperties, -1 but -1 // -1 it's -1 probably -1 not -1 worth -1 the -1 effort. -1 ++++ -1 +++Preconditions.checkNotNull(declaration); -1 ++++ -1 +++if -1 +++(declaration.getTwin() -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 if -1 (isClassOrEnum) -1 { -1 return -1 true; -1 ------ -1 ---a/src/com/google/javascript/rhino/JSDocInfoBuilder.java -1 ++++++ -1 +++b/src/com/google/javascript/rhino/JSDocInfoBuilder.java -1 @@ -1 -186,9 -1 +186,7 -1 @@ -1 public -1 void -1 markName(String -1 name, -1 int -1 lineno, -1 int -1 charno) -1 { -1 * -1 @return -1 {@code -1 true} -1 if -1 the -1 description -1 was -1 recorded. -1 */ -1 public -1 boolean -1 recordBlockDescription(String -1 description) -1 { -1 ---- -1 ---if -1 ---(parseDocumentation) -1 ---{ -1 populated -1 = -1 true; -1 ---- -1 ---} -1 return -1 currentInfo.documentBlock(description); -1 } -1 -2
private -1 void -1 reportCodeChange(String -1 changeDescription) -1 { -1 @Override -1 public -1 void -1 process(Node -1 externs, -1 Node -1 root) -1 { -1 NodeTraversal.traverse(compiler, -1 root, -1 this); -1 ++++ -1 +++removeDuplicateDeclarations(root); -1 if -1 (MAKE_LOCAL_NAMES_UNIQUE) -1 { -1 MakeDeclaredNamesUnique -1 renamer -1 = -1 new -1 MakeDeclaredNamesUnique(); -1 NodeTraversal -1 t -1 = -1 new -1 NodeTraversal(compiler, -1 renamer); -1 t.traverseRoots(externs, -1 root); -1 } -1 ---- -1 ---removeDuplicateDeclarations(root); -1 new -1 PropogateConstantAnnotations(compiler, -1 assertOnChange) -1 .process(externs, -1 root); -1 } -1 -2
private -1 static -1 boolean -1 mayThrowException(Node -1 n) -1 { -1 case -1 Token.ASSIGN: -1 case -1 Token.INC: -1 case -1 Token.DEC: -1 ++++ -1 +++case -1 +++Token.INSTANCEOF: -1 return -1 true; -1 case -1 Token.FUNCTION: -1 return -1 false; -1 ------ -1 ---a/src/com/google/javascript/jscomp/DisambiguateProperties.java -1 ++++++ -1 +++b/src/com/google/javascript/jscomp/DisambiguateProperties.java -1 @@ -1 -760,9 -1 +760,16 -1 @@ -1 public -1 JSTypeSystem(AbstractCompiler -1 compiler) -1 { -1 } -1 // -1 If -1 the -1 property -1 does -1 not -1 exist -1 on -1 the -1 referenced -1 type -1 but -1 the -1 original -1 // -1 type -1 is -1 an -1 object -1 type, -1 see -1 if -1 any -1 subtype -1 has -1 the -1 property. -1 ++++ -1 +++if -1 +++(foundType -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++ObjectType -1 +++maybeType -1 +++= -1 +++ObjectType.cast( -1 ++++ -1 +++registry.getGreatestSubtypeWithProperty(type, -1 +++field)); -1 // -1 getGreatestSubtypeWithProperty -1 does -1 not -1 guarantee -1 that -1 the -1 property -1 // -1 is -1 defined -1 on -1 the -1 returned -1 type, -1 it -1 just -1 indicates -1 that -1 it -1 might -1 be, -1 // -1 so -1 we -1 have -1 to -1 double -1 check. -1 ++++ -1 +++if -1 +++(maybeType -1 +++!= -1 +++null -1 +++&& -1 +++maybeType.hasOwnProperty(field)) -1 +++{ -1 ++++ -1 +++foundType -1 +++= -1 +++maybeType; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 return -1 foundType; -1 } -1 -2
protected -1 CompilerOptions -1 createOptions() -1 { -1 // -1 so -1 we -1 might -1 as -1 well -1 inline -1 it. -1 But -1 shut -1 off -1 the -1 i18n -1 warnings, -1 // -1 because -1 the -1 user -1 didn't -1 really -1 ask -1 for -1 i18n. -1 options.messageBundle -1 = -1 new -1 EmptyMessageBundle(); -1 ++++ -1 +++options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, -1 +++CheckLevel.OFF); -1 } -1 return -1 options; -1 -2
public -1 void -1 applyAlias() -1 { -1 private -1 final -1 Map<String, -1 Var> -1 aliases -1 = -1 Maps.newHashMap(); -1 // -1 Also -1 temporary -1 and -1 cleared -1 for -1 each -1 scope. -1 ++++ -1 +++private -1 +++final -1 +++Set<Node> -1 +++injectedDecls -1 +++= -1 +++Sets.newHashSet(); -1 // -1 Suppose -1 you -1 create -1 an -1 alias. -1 // -1 var -1 x -1 = -1 goog.x; -1 @@ -1 -313,6 -1 +314,7 -1 @@ -1 public -1 void -1 exitScope(NodeTraversal -1 t) -1 { -1 if -1 (t.getScopeDepth() -1 == -1 2) -1 { -1 renameNamespaceShadows(t); -1 ++++ -1 +++injectedDecls.clear(); -1 aliases.clear(); -1 forbiddenLocals.clear(); -1 transformation -1 = -1 null; -1 @@ -1 -429,6 -1 +431,7 -1 @@ -1 private -1 void -1 findAliases(NodeTraversal -1 t) -1 { -1 } -1 else -1 { -1 grandparent.addChildBefore(newDecl, -1 varNode); -1 } -1 ++++ -1 +++injectedDecls.add(newDecl.getFirstChild()); -1 } -1 // -1 Rewrite -1 "var -1 name -1 = -1 EXPR;" -1 to -1 "var -1 name -1 = -1 $jscomp.scope.name;" -1 @@ -1 -578,7 -1 +581,7 -1 @@ -1 public -1 void -1 visit(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 // -1 When -1 we -1 inject -1 declarations, -1 we -1 duplicate -1 jsdoc. -1 Make -1 sure -1 // -1 we -1 only -1 process -1 that -1 jsdoc -1 once. -1 JSDocInfo -1 info -1 = -1 n.getJSDocInfo(); -1 ---- -1 ---if -1 ---(info -1 ---!= -1 ---null) -1 ---{ -1 ++++ -1 +++if -1 +++(info -1 +++!= -1 +++null -1 +++&& -1 +++!injectedDecls.contains(n)) -1 +++{ -1 for -1 (Node -1 node -1 : -1 info.getTypeNodes()) -1 { -1 fixTypeNode(node); -1 } -1 -2
private -1 Node -1 parseTypeExpression(JsDocToken -1 token) -1 { -1 * -1 For -1 expressions -1 on -1 the -1 right -1 hand -1 side -1 of -1 a -1 this: -1 or -1 new: -1 */ -1 private -1 Node -1 parseContextTypeExpression(JsDocToken -1 token) -1 { -1 ---- -1 ---return -1 ---parseTypeName(token); -1 ++++ -1 +++if -1 +++(token -1 +++== -1 +++JsDocToken.QMARK) -1 +++{ -1 ++++ -1 +++return -1 +++newNode(Token.QMARK); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++return -1 +++parseBasicTypeExpression(token); -1 ++++ -1 +++} -1 } -1 /** -1 -2
private -1 String -1 formatFoundRequired(String -1 description, -1 JSType -1 found, -1 * -1 to -1 an -1 Object -1 type, -1 if -1 possible. -1 */ -1 String -1 getReadableJSTypeName(Node -1 n, -1 boolean -1 dereference) -1 { -1 ++++ -1 +++JSType -1 +++type -1 +++= -1 +++getJSType(n); -1 ++++ -1 +++if -1 +++(dereference) -1 +++{ -1 ++++ -1 +++ObjectType -1 +++dereferenced -1 +++= -1 +++type.dereference(); -1 ++++ -1 +++if -1 +++(dereferenced -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++type -1 +++= -1 +++dereferenced; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 // -1 The -1 best -1 type -1 name -1 is -1 the -1 actual -1 type -1 name. -1 ++++ -1 +++if -1 +++(type.isFunctionPrototypeType() -1 +++|| -1 ++++ -1 +++(type.toObjectType() -1 +++!= -1 +++null -1 +++&& -1 ++++ -1 +++type.toObjectType().getConstructor() -1 +++!= -1 +++null)) -1 +++{ -1 ++++ -1 +++return -1 +++type.toString(); -1 ++++ -1 +++} -1 // -1 If -1 we're -1 analyzing -1 a -1 GETPROP, -1 the -1 property -1 may -1 be -1 inherited -1 by -1 the -1 // -1 prototype -1 chain. -1 So -1 climb -1 the -1 prototype -1 chain -1 and -1 find -1 out -1 where -1 @@ -1 -753,18 -1 +765,6 -1 @@ -1 String -1 getReadableJSTypeName(Node -1 n, -1 boolean -1 dereference) -1 { -1 } -1 } -1 ---- -1 ---JSType -1 ---type -1 ---= -1 ---getJSType(n); -1 ---- -1 ---if -1 ---(dereference) -1 ---{ -1 ---- -1 ---ObjectType -1 ---dereferenced -1 ---= -1 ---type.dereference(); -1 ---- -1 ---if -1 ---(dereferenced -1 ---!= -1 ---null) -1 ---{ -1 ---- -1 ---type -1 ---= -1 ---dereferenced; -1 ---- -1 ---} -1 ---- -1 ---} -1 ---- -1 ---if -1 ---(type.isFunctionPrototypeType() -1 ---|| -1 ---- -1 ---(type.toObjectType() -1 ---!= -1 ---null -1 ---&& -1 ---- -1 ---type.toObjectType().getConstructor() -1 ---!= -1 ---null)) -1 ---{ -1 ---- -1 ---return -1 ---type.toString(); -1 ---- -1 ---} -1 String -1 qualifiedName -1 = -1 n.getQualifiedName(); -1 if -1 (qualifiedName -1 != -1 null) -1 { -1 return -1 qualifiedName; -1 -2
private -1 boolean -1 inferTemplatedTypesForCall( -1 } -1 // -1 Try -1 to -1 infer -1 the -1 template -1 types -1 ---- -1 ---Map<TemplateType, -1 ---JSType> -1 ---inferred -1 ---= -1 ---- -1 ---inferTemplateTypesFromParameters(fnType, -1 ---n); -1 ---- -1 ++++ -1 +++Map<TemplateType, -1 +++JSType> -1 +++inferred -1 +++= -1 +++Maps.filterKeys( -1 ++++ -1 +++inferTemplateTypesFromParameters(fnType, -1 +++n), -1 ++++ -1 +++new -1 +++Predicate<TemplateType>() -1 +++{ -1 ++++ -1 ++++ -1 +++@Override -1 ++++ -1 +++public -1 +++boolean -1 +++apply(TemplateType -1 +++key) -1 +++{ -1 ++++ -1 +++return -1 +++keys.contains(key); -1 ++++ -1 +++}} -1 ++++ -1 +++); -1 // -1 Replace -1 all -1 template -1 types. -1 If -1 we -1 couldn't -1 find -1 a -1 replacement, -1 we -1 // -1 replace -1 it -1 with -1 UNKNOWN. -1 -2
private -1 void -1 recordAssignment(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 recordNode) -1 { -1 } -1 else -1 { -1 recordDepScope(nameNode, -1 ns); -1 } -1 ---- -1 ---} -1 ---else -1 ---{ -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(!(parent.isCall() -1 +++&& -1 +++parent.getFirstChild() -1 +++== -1 +++n)) -1 +++{ -1 // -1 The -1 rhs -1 of -1 the -1 assignment -1 is -1 the -1 caller, -1 so -1 it's -1 used -1 by -1 the -1 // -1 context. -1 Don't -1 associate -1 it -1 w/ -1 the -1 lhs. -1 // -1 FYI: -1 this -1 fixes -1 only -1 the -1 specific -1 case -1 where -1 the -1 assignment -1 is -1 the -1 -2
private -1 void -1 processRequireCall(NodeTraversal -1 t, -1 Node -1 n, -1 Node -1 parent) -1 { -1 // -1 the -1 checks -1 for -1 broken -1 requires -1 turned -1 off. -1 In -1 these -1 cases, -1 we -1 // -1 allow -1 broken -1 requires -1 to -1 be -1 preserved -1 by -1 the -1 first -1 run -1 to -1 // -1 let -1 them -1 be -1 caught -1 in -1 the -1 subsequent -1 run. -1 ---- -1 ---if -1 ---(provided -1 ---!= -1 ---null) -1 ---{ -1 ++++ -1 +++if -1 +++(provided -1 +++!= -1 +++null -1 +++|| -1 +++requiresLevel.isOn()) -1 +++{ -1 parent.detachFromParent(); -1 compiler.reportCodeChange(); -1 } -1 -2
private -1 CanInlineResult -1 canInlineReferenceDirectly( -1 Node -1 block -1 = -1 fnNode.getLastChild(); -1 ---- -1 ---boolean -1 ---hasSideEffects -1 ---= -1 ---false; -1 ---- -1 ---if -1 ---(block.hasChildren()) -1 ---{ -1 ---- -1 ---Preconditions.checkState(block.hasOneChild()); -1 ---- -1 ---Node -1 ---stmt -1 ---= -1 ---block.getFirstChild(); -1 ---- -1 ---if -1 ---(stmt.isReturn()) -1 ---{ -1 ---- -1 ---hasSideEffects -1 ---= -1 ---NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), -1 ---compiler); -1 ---- -1 ---} -1 ---- -1 ---} -1 // -1 CALL -1 NODE: -1 [ -1 NAME, -1 ARG1, -1 ARG2, -1 ... -1 ] -1 Node -1 cArg -1 = -1 callNode.getFirstChild().getNext(); -1 @@ -1 -727,9 -1 +719,6 -1 @@ -1 private -1 CanInlineResult -1 canInlineReferenceDirectly( -1 // -1 For -1 each -1 named -1 parameter -1 check -1 if -1 a -1 mutable -1 argument -1 use -1 more -1 than -1 one. -1 if -1 (fnParam -1 != -1 null) -1 { -1 if -1 (cArg -1 != -1 null) -1 { -1 ---- -1 ---if -1 ---(hasSideEffects -1 ---&& -1 ---NodeUtil.canBeSideEffected(cArg)) -1 ---{ -1 ---- -1 ---return -1 ---CanInlineResult.NO; -1 ---- -1 ---} -1 // -1 Check -1 for -1 arguments -1 that -1 are -1 evaluated -1 more -1 than -1 once. -1 // -1 Note: -1 Unlike -1 block -1 inlining, -1 there -1 it -1 is -1 not -1 possible -1 that -1 a -1 // -1 parameter -1 reference -1 will -1 be -1 in -1 a -1 loop. -1 -2
private -1 CanInlineResult -1 canInlineReferenceDirectly( -1 Node -1 block -1 = -1 fnNode.getLastChild(); -1 ++++ -1 +++boolean -1 +++hasSideEffects -1 +++= -1 +++false; -1 +++// -1 +++empty -1 +++function -1 +++case -1 ++++ -1 +++if -1 +++(block.hasChildren()) -1 +++{ -1 ++++ -1 +++Preconditions.checkState(block.hasOneChild()); -1 ++++ -1 +++Node -1 +++stmt -1 +++= -1 +++block.getFirstChild(); -1 ++++ -1 +++if -1 +++(stmt.isReturn()) -1 +++{ -1 ++++ -1 +++hasSideEffects -1 +++= -1 +++NodeUtil.mayHaveSideEffects( -1 ++++ -1 +++stmt.getFirstChild(), -1 +++compiler); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 // -1 CALL -1 NODE: -1 [ -1 NAME, -1 ARG1, -1 ARG2, -1 ... -1 ] -1 Node -1 cArg -1 = -1 callNode.getFirstChild().getNext(); -1 @@ -1 -720,6 -1 +729,9 -1 @@ -1 private -1 CanInlineResult -1 canInlineReferenceDirectly( -1 // -1 For -1 each -1 named -1 parameter -1 check -1 if -1 a -1 mutable -1 argument -1 use -1 more -1 than -1 one. -1 if -1 (fnParam -1 != -1 null) -1 { -1 if -1 (cArg -1 != -1 null) -1 { -1 ++++ -1 +++if -1 +++(hasSideEffects -1 +++&& -1 +++NodeUtil.canBeSideEffected(cArg)) -1 +++{ -1 ++++ -1 +++return -1 +++CanInlineResult.NO; -1 ++++ -1 +++} -1 // -1 Check -1 for -1 arguments -1 that -1 are -1 evaluated -1 more -1 than -1 once. -1 // -1 Note: -1 Unlike -1 block -1 inlining, -1 there -1 it -1 is -1 not -1 possible -1 that -1 a -1 -2
new -1 RestrictByTrueTypeOfResultVisitor() -1 { -1 @Override -1 protected -1 JSType -1 caseTopType(JSType -1 topType) -1 { -1 ---- -1 ---return -1 ---topType; -1 ++++ -1 +++return -1 +++topType.isAllType() -1 +++? -1 ++++ -1 +++getNativeType(ARRAY_TYPE) -1 +++: -1 +++topType; -1 } -1 @Override -1 -2
private -1 void -1 findAliases(NodeTraversal -1 t) -1 { -1 Node -1 n -1 = -1 v.getNode(); -1 Node -1 parent -1 = -1 n.getParent(); -1 boolean -1 isVar -1 = -1 parent.isVar(); -1 ++++ -1 +++boolean -1 +++isFunctionDecl -1 +++= -1 +++NodeUtil.isFunctionDeclaration(parent); -1 if -1 (isVar -1 && -1 n.getFirstChild() -1 != -1 null -1 && -1 n.getFirstChild().isQualifiedName()) -1 { -1 recordAlias(v); -1 } -1 else -1 if -1 (v.isBleedingFunction()) -1 { -1 @@ -1 -363,12 -1 +364,13 -1 @@ -1 private -1 void -1 findAliases(NodeTraversal -1 t) -1 { -1 } -1 else -1 if -1 (parent.getType() -1 == -1 Token.LP) -1 { -1 // -1 Parameters -1 of -1 the -1 scope -1 function -1 also -1 get -1 a -1 BAD_PARAMETERS -1 // -1 error. -1 ---- -1 ---} -1 ---else -1 ---if -1 ---(isVar) -1 ---{ -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(isVar -1 +++|| -1 +++isFunctionDecl) -1 +++{ -1 ++++ -1 +++boolean -1 +++isHoisted -1 +++= -1 +++NodeUtil.isHoistedFunctionDeclaration(parent); -1 Node -1 grandparent -1 = -1 parent.getParent(); -1 ---- -1 ---Node -1 ---value -1 ---= -1 ---n.hasChildren() -1 ---? -1 ---- -1 ---v.getInitialValue().detachFromParent() -1 ---: -1 ++++ -1 +++Node -1 +++value -1 +++= -1 +++v.getInitialValue() -1 +++!= -1 +++null -1 +++? -1 ++++ -1 +++v.getInitialValue() -1 +++: -1 null; -1 ---- -1 ---Node -1 ---varNode -1 ---= -1 ---parent; -1 ++++ -1 +++Node -1 +++varNode -1 +++= -1 +++null; -1 String -1 name -1 = -1 n.getString(); -1 int -1 nameCount -1 = -1 scopedAliasNames.count(name); -1 @@ -1 -380,7 -1 +382,9 -1 @@ -1 private -1 void -1 findAliases(NodeTraversal -1 t) -1 { -1 // -1 First, -1 we -1 need -1 to -1 free -1 up -1 the -1 function -1 expression -1 (EXPR) -1 // -1 to -1 be -1 used -1 in -1 another -1 expression. -1 ++++ -1 +++if -1 +++(isFunctionDecl) -1 +++{ -1 // -1 Replace -1 "function -1 NAME() -1 { -1 ... -1 }" -1 with -1 "var -1 NAME;". -1 ++++ -1 +++Node -1 +++existingName -1 +++= -1 +++v.getNameNode(); -1 // -1 We -1 can't -1 keep -1 the -1 local -1 name -1 on -1 the -1 function -1 expression, -1 // -1 because -1 IE -1 is -1 buggy -1 and -1 will -1 leak -1 the -1 name -1 into -1 the -1 global -1 @@ -1 -389,9 -1 +393,19 -1 @@ -1 private -1 void -1 findAliases(NodeTraversal -1 t) -1 { -1 // -1 // -1 This -1 will -1 only -1 cause -1 problems -1 if -1 this -1 is -1 a -1 hoisted, -1 recursive -1 // -1 function, -1 and -1 the -1 programmer -1 is -1 using -1 the -1 hoisting. -1 ++++ -1 +++Node -1 +++newName -1 +++= -1 +++IR.name("").useSourceInfoFrom(existingName); -1 ++++ -1 +++value.replaceChild(existingName, -1 +++newName); -1 ++++ -1 +++varNode -1 +++= -1 +++IR.var(existingName).useSourceInfoFrom(existingName); -1 ++++ -1 +++grandparent.replaceChild(parent, -1 +++varNode); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++if -1 +++(value -1 +++!= -1 +++null) -1 +++{ -1 // -1 If -1 this -1 is -1 a -1 VAR, -1 we -1 can -1 just -1 detach -1 the -1 expression -1 and -1 // -1 the -1 tree -1 will -1 still -1 be -1 valid. -1 ++++ -1 +++value.detachFromParent(); -1 ++++ -1 +++} -1 ++++ -1 +++varNode -1 +++= -1 +++parent; -1 ++++ -1 +++} -1 // -1 Add -1 $jscomp.scope.name -1 = -1 EXPR; -1 // -1 Make -1 sure -1 we -1 copy -1 over -1 all -1 the -1 jsdoc -1 and -1 debug -1 info. -1 @@ -1 -405,7 -1 +419,11 -1 @@ -1 private -1 void -1 findAliases(NodeTraversal -1 t) -1 { -1 NodeUtil.setDebugInformation( -1 newDecl.getFirstChild().getFirstChild(), -1 n, -1 name); -1 ++++ -1 +++if -1 +++(isHoisted) -1 +++{ -1 ++++ -1 +++grandparent.addChildToFront(newDecl); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 grandparent.addChildBefore(newDecl, -1 varNode); -1 ++++ -1 +++} -1 } -1 // -1 Rewrite -1 "var -1 name -1 = -1 EXPR;" -1 to -1 "var -1 name -1 = -1 $jscomp.scope.name;" -1 ------ -1 ---a/src/com/google/javascript/rhino/Node.java -1 ++++++ -1 +++b/src/com/google/javascript/rhino/Node.java -1 @@ -1 -551,6 -1 +551,9 -1 @@ -1 public -1 Node -1 getChildBefore(Node -1 child) -1 { -1 return -1 null; -1 } -1 Node -1 n -1 = -1 first; -1 ++++ -1 +++if -1 +++(n -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++RuntimeException("node -1 +++is -1 +++not -1 +++a -1 +++child"); -1 ++++ -1 +++} -1 while -1 (n.next -1 != -1 child) -1 { -1 n -1 = -1 n.next; -1 -2
private -1 void -1 handleObjectLit(NodeTraversal -1 t, -1 Node -1 n) -1 { -1 child -1 != -1 null; -1 child -1 = -1 child.getNext()) -1 { -1 // -1 Maybe -1 STRING, -1 GET, -1 SET -1 ++++ -1 +++if -1 +++(child.isQuotedString()) -1 +++{ -1 ++++ -1 +++continue; -1 ++++ -1 +++} -1 // -1 We -1 should -1 never -1 see -1 a -1 mix -1 of -1 numbers -1 and -1 strings. -1 String -1 name -1 = -1 child.getString(); -1 -2
boolean -1 isAssignedOnceInLifetime() -1 { -1 for -1 (BasicBlock -1 block -1 = -1 ref.getBasicBlock(); -1 block -1 != -1 null; -1 block -1 = -1 block.getParent()) -1 { -1 if -1 (block.isFunction) -1 { -1 ++++ -1 +++if -1 +++(ref.getSymbol().getScope() -1 +++!= -1 +++ref.scope) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 break; -1 } -1 else -1 if -1 (block.isLoop) -1 { -1 return -1 false; -1 -2
public -1 void -1 collect(JSModule -1 module, -1 Scope -1 scope, -1 Node -1 n) -1 { -1 isSet -1 = -1 true; -1 type -1 = -1 Name.Type.FUNCTION; -1 break; -1 ++++ -1 +++case -1 +++Token.CATCH: -1 case -1 Token.INC: -1 case -1 Token.DEC: -1 isSet -1 = -1 true; -1 -2
private -1 void -1 inlineNonConstants( -1 if -1 (!maybeModifiedArguments -1 && -1 !staleVars.contains(v) -1 && -1 referenceInfo.isWellDefined() -1 && -1 ---- -1 ---referenceInfo.isAssignedOnceInLifetime()) -1 ---{ -1 ++++ -1 +++referenceInfo.isAssignedOnceInLifetime() -1 +++&& -1 // -1 Inlining -1 the -1 variable -1 based -1 solely -1 on -1 well-defined -1 and -1 assigned -1 // -1 once -1 is -1 *NOT* -1 correct. -1 We -1 relax -1 the -1 correctness -1 requirement -1 if -1 // -1 the -1 variable -1 is -1 declared -1 constant. -1 ++++ -1 +++(isInlineableDeclaredConstant(v, -1 +++referenceInfo) -1 +++|| -1 ++++ -1 +++referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) -1 +++{ -1 List<Reference> -1 refs -1 = -1 referenceInfo.references; -1 for -1 (int -1 i -1 = -1 1 -1 /* -1 start -1 from -1 a -1 read -1 */; -1 i -1 < -1 refs.size(); -1 i++) -1 { -1 Node -1 nameNode -1 = -1 refs.get(i).getNode(); -1 -2
void -1 add(Node -1 n, -1 Context -1 context) -1 { -1 case -1 Token.HOOK: -1 { -1 Preconditions.checkState(childCount -1 == -1 3); -1 int -1 p -1 = -1 NodeUtil.precedence(type); -1 ---- -1 ---Context -1 ---rhsContext -1 ---= -1 ---Context.OTHER; -1 ++++ -1 +++Context -1 +++rhsContext -1 +++= -1 +++getContextForNoInOperator(context); -1 addExpr(first, -1 p -1 + -1 1, -1 context); -1 cc.addOp("?", -1 true); -1 addExpr(first.getNext(), -1 1, -1 rhsContext); -1 -2
private -1 Node -1 transformBlock(AstNode -1 node) -1 { -1 * -1 Check -1 to -1 see -1 if -1 the -1 given -1 block -1 comment -1 looks -1 like -1 it -1 should -1 be -1 JSDoc. -1 */ -1 private -1 void -1 handleBlockComment(Comment -1 comment) -1 { -1 ---- -1 ---if -1 ---(comment.getValue().indexOf("/* -1 ---@") -1 ---!= -1 ----1 -1 ---|| -1 ---comment.getValue().indexOf("\n -1 ---* -1 ---@") -1 ---!= -1 ----1) -1 ---{ -1 ++++ -1 +++Pattern -1 +++p -1 +++= -1 +++Pattern.compile("(/|(\n[ -1 +++\t]*))\\*[ -1 +++\t]*@[a-zA-Z]"); -1 ++++ -1 +++if -1 +++(p.matcher(comment.getValue()).find()) -1 +++{ -1 errorReporter.warning( -1 SUSPICIOUS_COMMENT_WARNING, -1 sourceName, -1 -2
void -1 tryMinimizeExits(Node -1 n, -1 int -1 exitType, -1 String -1 labelName) -1 { -1 * -1 can -1 cause -1 problems -1 if -1 it -1 changes -1 the -1 completion -1 type -1 of -1 the -1 finally -1 * -1 block. -1 See -1 ECMA -1 262 -1 Sections -1 8.9 -1 & -1 12.14 -1 */ -1 ---- -1 ---if -1 ---(NodeUtil.hasFinally(n)) -1 ---{ -1 ---- -1 ---Node -1 ---finallyBlock -1 ---= -1 ---n.getLastChild(); -1 ---- -1 ---tryMinimizeExits(finallyBlock, -1 ---exitType, -1 ---labelName); -1 ---- -1 ---} -1 } -1 // -1 Just -1 a -1 'label'. -1 -2
private -1 boolean -1 isSafeReplacement(Node -1 node, -1 Node -1 replacement) -1 { -1 } -1 Preconditions.checkArgument(node.isGetProp()); -1 ++++ -1 +++while -1 +++(node.isGetProp()) -1 +++{ -1 node -1 = -1 node.getFirstChild(); -1 ++++ -1 +++} -1 if -1 (node.isName() -1 && -1 isNameAssignedTo(node.getString(), -1 replacement)) -1 { -1 return -1 false; -1 -2
private -1 void -1 tryRemoveUnconditionalBranching(Node -1 n) -1 { -1 outEdges.get(0).getValue() -1 == -1 Branch.UNCOND); -1 Node -1 fallThrough -1 = -1 computeFollowing(n); -1 Node -1 nextCfgNode -1 = -1 outEdges.get(0).getDestination().getValue(); -1 ---- -1 ---if -1 ---(nextCfgNode -1 ---== -1 ---fallThrough) -1 ---{ -1 ++++ -1 +++if -1 +++(nextCfgNode -1 +++== -1 +++fallThrough -1 +++&& -1 +++!inFinally(n.getParent(), -1 +++n)) -1 +++{ -1 removeNode(n); -1 } -1 } -1 } -1 } -1 ++++ -1 +++private -1 +++boolean -1 +++inFinally(Node -1 +++parent, -1 +++Node -1 +++child) -1 +++{ -1 ++++ -1 +++if -1 +++(parent -1 +++== -1 +++null -1 +++|| -1 +++parent.isFunction()) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(NodeUtil.isTryFinallyNode(parent, -1 +++child)) -1 +++{ -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++return -1 +++inFinally(parent.getParent(), -1 +++parent); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 private -1 Node -1 computeFollowing(Node -1 n) -1 { -1 Node -1 next -1 = -1 ControlFlowAnalysis.computeFollowNode(n); -1 -2
private -1 void -1 visitNew(NodeTraversal -1 t, -1 Node -1 n) -1 { -1 JSType -1 type -1 = -1 getJSType(constructor).restrictByNotNullOrUndefined(); -1 if -1 (type.isConstructor() -1 || -1 type.isEmptyType() -1 || -1 type.isUnknownType()) -1 { -1 FunctionType -1 fnType -1 = -1 type.toMaybeFunctionType(); -1 ---- -1 ---if -1 ---(fnType -1 ---!= -1 ---null) -1 ---{ -1 ++++ -1 +++if -1 +++(fnType -1 +++!= -1 +++null -1 +++&& -1 +++fnType.hasInstanceType()) -1 +++{ -1 visitParameterList(t, -1 n, -1 fnType); -1 ensureTyped(t, -1 n, -1 fnType.getInstanceType()); -1 } -1 else -1 { -1 -2
private -1 void -1 unrollBinaryOperator( -1 static -1 boolean -1 isSimpleNumber(String -1 s) -1 { -1 int -1 len -1 = -1 s.length(); -1 ++++ -1 +++if -1 +++(len -1 +++== -1 +++0) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 for -1 (int -1 index -1 = -1 0; -1 index -1 < -1 len; -1 index++) -1 { -1 char -1 c -1 = -1 s.charAt(index); -1 if -1 (c -1 < -1 '0' -1 || -1 c -1 > -1 '9') -1 { -1 return -1 false; -1 } -1 } -1 ---- -1 ---return -1 ---len -1 ---> -1 ---0 -1 ---&& -1 ---s.charAt(0) -1 ---!= -1 ---'0'; -1 ++++ -1 +++return -1 +++len -1 +++== -1 +++1 -1 +++|| -1 +++s.charAt(0) -1 +++!= -1 +++'0'; -1 } -1 static -1 double -1 getSimpleNumber(String -1 s) -1 { -1 -2
public -1 static -1 Number -1 createNumber(final -1 String -1 str) -1 throws -1 NumberFormatException -1 //Must -1 be -1 a -1 Float, -1 Double, -1 BigDecimal -1 final -1 boolean -1 allZeros -1 = -1 isAllZeros(mant) -1 && -1 isAllZeros(exp); -1 try -1 { -1 ++++ -1 +++if(numDecimals -1 +++<= -1 +++7){// -1 +++If -1 +++number -1 +++has -1 +++7 -1 +++or -1 +++fewer -1 +++digits -1 +++past -1 +++the -1 +++decimal -1 +++point -1 +++then -1 +++make -1 +++it -1 +++a -1 +++float -1 final -1 Float -1 f -1 = -1 createFloat(str); -1 if -1 (!(f.isInfinite() -1 || -1 (f.floatValue() -1 == -1 0.0F -1 && -1 !allZeros))) -1 { -1 return -1 f; -1 } -1 ++++ -1 +++} -1 } -1 catch -1 (final -1 NumberFormatException -1 nfe) -1 { -1 // -1 NOPMD -1 // -1 ignore -1 the -1 bad -1 number -1 } -1 try -1 { -1 ++++ -1 +++if(numDecimals -1 +++<= -1 +++16){// -1 +++If -1 +++number -1 +++has -1 +++between -1 +++8 -1 +++and -1 +++16 -1 +++digits -1 +++past -1 +++the -1 +++decimal -1 +++point -1 +++then -1 +++make -1 +++it -1 +++a -1 +++double -1 final -1 Double -1 d -1 = -1 createDouble(str); -1 if -1 (!(d.isInfinite() -1 || -1 (d.doubleValue() -1 == -1 0.0D -1 && -1 !allZeros))) -1 { -1 return -1 d; -1 } -1 ++++ -1 +++} -1 } -1 catch -1 (final -1 NumberFormatException -1 nfe) -1 { -1 // -1 NOPMD -1 // -1 ignore -1 the -1 bad -1 number -1 } -1 -2
public -1 static -1 Locale -1 toLocale(final -1 String -1 str) -1 { -1 if -1 (str -1 == -1 null) -1 { -1 return -1 null; -1 } -1 ++++ -1 +++if -1 +++(str.contains("#")) -1 +++{ -1 +++// -1 +++LANG-879 -1 +++- -1 +++Cannot -1 +++handle -1 +++Java -1 +++7 -1 +++script -1 +++& -1 +++extensions -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Invalid -1 +++locale -1 +++format: -1 +++" -1 ++++ -1 +++str); -1 ++++ -1 +++} -1 final -1 int -1 len -1 = -1 str.length(); -1 if -1 (len -1 < -1 2) -1 { -1 throw -1 new -1 IllegalArgumentException("Invalid -1 locale -1 format: -1 " -1 + -1 str); -1 -2
public -1 static -1 Locale -1 toLocale(final -1 String -1 str) -1 { -1 throw -1 new -1 IllegalArgumentException("Invalid -1 locale -1 format: -1 " -1 + -1 str); -1 } -1 final -1 char -1 ch0 -1 = -1 str.charAt(0); -1 ++++ -1 +++if -1 +++(ch0 -1 +++== -1 +++'_') -1 +++{ -1 ++++ -1 +++if -1 +++(len -1 +++< -1 +++3) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Invalid -1 +++locale -1 +++format: -1 +++" -1 ++++ -1 +++str); -1 ++++ -1 +++} -1 ++++ -1 +++final -1 +++char -1 +++ch1 -1 +++= -1 +++str.charAt(1); -1 ++++ -1 +++final -1 +++char -1 +++ch2 -1 +++= -1 +++str.charAt(2); -1 ++++ -1 +++if -1 +++(!Character.isUpperCase(ch1) -1 +++|| -1 +++!Character.isUpperCase(ch2)) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Invalid -1 +++locale -1 +++format: -1 +++" -1 ++++ -1 +++str); -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(len -1 +++== -1 +++3) -1 +++{ -1 ++++ -1 +++return -1 +++new -1 +++Locale("", -1 +++str.substring(1, -1 +++3)); -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(len -1 +++< -1 +++5) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Invalid -1 +++locale -1 +++format: -1 +++" -1 ++++ -1 +++str); -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(str.charAt(3) -1 +++!= -1 +++'_') -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Invalid -1 +++locale -1 +++format: -1 +++" -1 ++++ -1 +++str); -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++new -1 +++Locale("", -1 +++str.substring(1, -1 +++3), -1 +++str.substring(4)); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 final -1 char -1 ch1 -1 = -1 str.charAt(1); -1 if -1 (!Character.isLowerCase(ch0) -1 || -1 !Character.isLowerCase(ch1)) -1 { -1 throw -1 new -1 IllegalArgumentException("Invalid -1 locale -1 format: -1 " -1 + -1 str); -1 @@ -1 -125,6 -1 +145,7 -1 @@ -1 public -1 static -1 Locale -1 toLocale(final -1 String -1 str) -1 { -1 throw -1 new -1 IllegalArgumentException("Invalid -1 locale -1 format: -1 " -1 + -1 str); -1 } -1 return -1 new -1 Locale(str.substring(0, -1 2), -1 str.substring(3, -1 5), -1 str.substring(6)); -1 ++++ -1 +++} -1 } -1 //----------------------------------------------------------------------- -1 -2
private -1 void -1 inlineAliases(GlobalNamespace -1 namespace) -1 { -1 continue; -1 } -1 ---- -1 ---if -1 ---(name.globalSets -1 ---== -1 ---1 -1 ---&& -1 ---name.localSets -1 ---== -1 ---0 -1 ---&& -1 ++++ -1 +++if -1 +++(!name.inExterns -1 +++&& -1 +++name.globalSets -1 +++== -1 +++1 -1 +++&& -1 +++name.localSets -1 +++== -1 +++0 -1 +++&& -1 name.aliasingGets -1 > -1 0) -1 { -1 // -1 {@code -1 name} -1 meets -1 condition -1 (b). -1 Find -1 all -1 of -1 its -1 local -1 aliases -1 // -1 and -1 try -1 to -1 inline -1 them. -1 -2
*/ -1 public -1 class -1 LookupTranslator -1 extends -1 CharSequenceTranslator -1 { -1 ---- -1 ---private -1 ---final -1 ---HashMap<CharSequence, -1 ---CharSequence> -1 ---lookupMap; -1 ++++ -1 +++private -1 +++final -1 +++HashMap<String, -1 +++CharSequence> -1 +++lookupMap; -1 private -1 final -1 int -1 shortest; -1 private -1 final -1 int -1 longest; -1 @@ -1 -43,12 -1 +43,12 -1 @@ -1 * -1 @param -1 lookup -1 CharSequence[][] -1 table -1 of -1 size -1 [*][2] -1 */ -1 public -1 LookupTranslator(final -1 CharSequence[]... -1 lookup) -1 { -1 ---- -1 ---lookupMap -1 ---= -1 ---new -1 ---HashMap<CharSequence, -1 ---CharSequence>(); -1 ++++ -1 +++lookupMap -1 +++= -1 +++new -1 +++HashMap<String, -1 +++CharSequence>(); -1 int -1 _shortest -1 = -1 Integer.MAX_VALUE; -1 int -1 _longest -1 = -1 0; -1 if -1 (lookup -1 != -1 null) -1 { -1 for -1 (final -1 CharSequence[] -1 seq -1 : -1 lookup) -1 { -1 ---- -1 ---this.lookupMap.put(seq[0], -1 ---seq[1]); -1 ++++ -1 +++this.lookupMap.put(seq[0].toString(), -1 +++seq[1]); -1 final -1 int -1 sz -1 = -1 seq[0].length(); -1 if -1 (sz -1 < -1 _shortest) -1 { -1 _shortest -1 = -1 sz; -1 @@ -1 -74,7 -1 +74,7 -1 @@ -1 public -1 int -1 translate(final -1 CharSequence -1 input, -1 final -1 int -1 index, -1 final -1 Writer -1 out -1 // -1 descend -1 so -1 as -1 to -1 get -1 a -1 greedy -1 algorithm -1 for -1 (int -1 i -1 = -1 max; -1 i -1 >= -1 shortest; -1 i--) -1 { -1 final -1 CharSequence -1 subSeq -1 = -1 input.subSequence(index, -1 index -1 + -1 i); -1 ---- -1 ---final -1 ---CharSequence -1 ---result -1 ---= -1 ---lookupMap.get(subSeq); -1 ++++ -1 +++final -1 +++CharSequence -1 +++result -1 +++= -1 +++lookupMap.get(subSeq.toString()); -1 if -1 (result -1 != -1 null) -1 { -1 out.write(result.toString()); -1 return -1 i; -1 -2
private -1 void -1 annotateCalls(Node -1 n) -1 { -1 Node -1 first -1 = -1 n.getFirstChild(); -1 // -1 ignore -1 cast -1 nodes. -1 ++++ -1 +++while -1 +++(first.isCast()) -1 +++{ -1 ++++ -1 +++first -1 +++= -1 +++first.getFirstChild(); -1 ++++ -1 +++} -1 if -1 (!NodeUtil.isGet(first)) -1 { -1 n.putBooleanProp(Node.FREE_CALL, -1 true); -1 -2
public -1 static -1 Number -1 createNumber(final -1 String -1 str) -1 throws -1 NumberFormatException -1 } -1 } -1 if -1 (pfxLen -1 > -1 0) -1 { -1 // -1 we -1 have -1 a -1 hex -1 number -1 ++++ -1 +++char -1 +++firstSigDigit -1 +++= -1 +++0; -1 +++// -1 +++strip -1 +++leading -1 +++zeroes -1 ++++ -1 +++for(int -1 +++i -1 +++= -1 +++pfxLen; -1 +++i -1 +++< -1 +++str.length(); -1 +++i++) -1 +++{ -1 ++++ -1 +++firstSigDigit -1 +++= -1 +++str.charAt(i); -1 ++++ -1 +++if -1 +++(firstSigDigit -1 +++== -1 +++'0') -1 +++{ -1 +++// -1 +++count -1 +++leading -1 +++zeroes -1 ++++ -1 +++pfxLen++; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++break; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 final -1 int -1 hexDigits -1 = -1 str.length() -1 - -1 pfxLen; -1 ---- -1 ---if -1 ---(hexDigits -1 ---> -1 ---16) -1 ---{ -1 ---// -1 ---too -1 ---many -1 ---for -1 ---Long -1 ++++ -1 +++if -1 +++(hexDigits -1 +++> -1 +++16 -1 +++|| -1 +++(hexDigits -1 +++== -1 +++16 -1 +++&& -1 +++firstSigDigit -1 +++> -1 +++'7')) -1 +++{ -1 +++// -1 +++too -1 +++many -1 +++for -1 +++Long -1 return -1 createBigInteger(str); -1 } -1 ---- -1 ---if -1 ---(hexDigits -1 ---> -1 ---8) -1 ---{ -1 ---// -1 ---too -1 ---many -1 ---for -1 ---an -1 ---int -1 ++++ -1 +++if -1 +++(hexDigits -1 +++> -1 +++8 -1 +++|| -1 +++(hexDigits -1 +++== -1 +++8 -1 +++&& -1 +++firstSigDigit -1 +++> -1 +++'7')) -1 +++{ -1 +++// -1 +++too -1 +++many -1 +++for -1 +++an -1 +++int -1 return -1 createLong(str); -1 } -1 return -1 createInteger(str); -1 -2
private -1 Node -1 tryMinimizeIf(Node -1 n) -1 { -1 // -1 evaluates -1 LHS -1 before -1 cond] -1 // -1 NOTE -1 - -1 there -1 are -1 some -1 circumstances -1 where -1 we -1 can -1 // -1 proceed -1 even -1 if -1 there -1 are -1 side -1 effects... -1 ---- -1 ---!mayEffectMutableState(lhs)) -1 ---{ -1 ++++ -1 +++!mayEffectMutableState(lhs) -1 +++&& -1 ++++ -1 +++(!mayHaveSideEffects(cond) -1 +++|| -1 ++++ -1 +++(thenOp.isAssign() -1 +++&& -1 +++thenOp.getFirstChild().isName()))) -1 +++{ -1 n.removeChild(cond); -1 Node -1 assignName -1 = -1 thenOp.removeFirstChild(); -1 -2
public -1 final -1 void -1 translate(CharSequence -1 input, -1 Writer -1 out) -1 throws -1 IOException -1 { -1 // -1 // -1 contract -1 with -1 translators -1 is -1 that -1 they -1 have -1 to -1 understand -1 codepoints -1 // -1 // -1 and -1 they -1 just -1 took -1 care -1 of -1 a -1 surrogate -1 pair -1 for -1 (int -1 pt -1 = -1 0; -1 pt -1 < -1 consumed; -1 pt++) -1 { -1 ---- -1 ---pos -1 ---+= -1 ---Character.charCount(Character.codePointAt(input, -1 ---pos)); -1 ++++ -1 +++pos -1 ++++= -1 +++Character.charCount(Character.codePointAt(input, -1 +++pt)); -1 } -1 } -1 } -1 -2
private -1 void -1 skipEOLs() -1 { -1 */ -1 private -1 String -1 getRemainingJSDocLine() -1 { -1 String -1 result -1 = -1 stream.getRemainingJSDocLine(); -1 ++++ -1 +++unreadToken -1 +++= -1 +++NO_UNREAD_TOKEN; -1 return -1 result; -1 } -1 -2
public -1 static -1 Number -1 createNumber(String -1 str) -1 throws -1 NumberFormatException -1 { -1 if -1 (StringUtils.isBlank(str)) -1 { -1 throw -1 new -1 NumberFormatException("A -1 blank -1 string -1 is -1 not -1 a -1 valid -1 number"); -1 } -1 ---- -1 ---if -1 ---(str.startsWith("--")) -1 ---{ -1 ---- -1 ---return -1 ---null; -1 ---- -1 ---} -1 if -1 (str.startsWith("0x") -1 || -1 str.startsWith("-0x") -1 || -1 str.startsWith("0X") -1 || -1 str.startsWith("-0X")) -1 { -1 int -1 hexDigits -1 = -1 str.length() -1 - -1 2; -1 // -1 drop -1 0x -1 if -1 (str.startsWith("-")) -1 { -1 // -1 drop -1 - -1 @@ -1 -718,10 -1 +715,13 -1 @@ -1 public -1 static -1 BigDecimal -1 createBigDecimal(String -1 str) -1 { -1 if -1 (StringUtils.isBlank(str)) -1 { -1 throw -1 new -1 NumberFormatException("A -1 blank -1 string -1 is -1 not -1 a -1 valid -1 number"); -1 } -1 ++++ -1 +++if -1 +++(str.trim().startsWith("--")) -1 +++{ -1 // -1 this -1 is -1 protection -1 for -1 poorness -1 in -1 java.lang.BigDecimal. -1 // -1 it -1 accepts -1 this -1 as -1 a -1 legal -1 value, -1 but -1 it -1 does -1 not -1 appear -1 // -1 to -1 be -1 in -1 specification -1 of -1 class. -1 OS -1 X -1 Java -1 parses -1 it -1 to -1 // -1 a -1 wrong -1 value. -1 ++++ -1 +++throw -1 +++new -1 +++NumberFormatException(str -1 ++++ -1 +++" -1 +++is -1 +++not -1 +++a -1 +++valid -1 +++number."); -1 ++++ -1 +++} -1 return -1 new -1 BigDecimal(str); -1 } -1 -2
public -1 static -1 boolean -1 isJSIdentifier(String -1 s) -1 { -1 int -1 length -1 = -1 s.length(); -1 if -1 (length -1 == -1 0 -1 || -1 ++++ -1 +++Character.isIdentifierIgnorable(s.charAt(0)) -1 +++|| -1 !Character.isJavaIdentifierStart(s.charAt(0))) -1 { -1 return -1 false; -1 } -1 for -1 (int -1 i -1 = -1 1; -1 i -1 < -1 length; -1 i++) -1 { -1 ---- -1 ---if -1 ---( -1 ++++ -1 +++if -1 +++(Character.isIdentifierIgnorable(s.charAt(i)) -1 +++|| -1 !Character.isJavaIdentifierPart(s.charAt(i))) -1 { -1 return -1 false; -1 } -1 -2
static -1 String -1 getTimeZoneDisplay(TimeZone -1 tz, -1 boolean -1 daylight, -1 int -1 style, -1 Local -1 private -1 static -1 class -1 TimeZoneNameRule -1 implements -1 Rule -1 { -1 private -1 final -1 Locale -1 mLocale; -1 private -1 final -1 int -1 mStyle; -1 ---- -1 ---private -1 ---final -1 ---TimeZone -1 ---zone; -1 private -1 final -1 String -1 mStandard; -1 private -1 final -1 String -1 mDaylight; -1 @@ -1 -1109,7 -1 +1108,6 -1 @@ -1 static -1 String -1 getTimeZoneDisplay(TimeZone -1 tz, -1 boolean -1 daylight, -1 int -1 style, -1 Local -1 TimeZoneNameRule(TimeZone -1 timeZone, -1 Locale -1 locale, -1 int -1 style) -1 { -1 mLocale -1 = -1 locale; -1 mStyle -1 = -1 style; -1 ---- -1 ---zone -1 ---= -1 ---timeZone; -1 mStandard -1 = -1 getTimeZoneDisplay(timeZone, -1 false, -1 style, -1 locale); -1 mDaylight -1 = -1 getTimeZoneDisplay(timeZone, -1 true, -1 style, -1 locale); -1 @@ -1 -1131,6 -1 +1129,7 -1 @@ -1 public -1 int -1 estimateLength() -1 { -1 */ -1 @Override -1 public -1 void -1 appendTo(StringBuffer -1 buffer, -1 Calendar -1 calendar) -1 { -1 ++++ -1 +++TimeZone -1 +++zone -1 +++= -1 +++calendar.getTimeZone(); -1 if -1 (zone.useDaylightTime() -1 && -1 calendar.get(Calendar.DST_OFFSET) -1 != -1 0) -1 { -1 buffer.append(getTimeZoneDisplay(zone, -1 true, -1 mStyle, -1 mLocale)); -1 -2
public -1 Date -1 parse(String -1 source, -1 ParsePosition -1 pos) -1 { -1 * -1 @return -1 The -1 <code>StringBuilder</code> -1 */ -1 private -1 static -1 StringBuilder -1 escapeRegex(StringBuilder -1 regex, -1 String -1 value, -1 boolean -1 unquote) -1 { -1 ---- -1 ---boolean -1 ---wasWhite= -1 ---false; -1 for(int -1 i= -1 0; -1 i<value.length(); -1 ++i) -1 { -1 char -1 c= -1 value.charAt(i); -1 ---- -1 ---if(Character.isWhitespace(c)) -1 ---{ -1 ---- -1 ---if(!wasWhite) -1 ---{ -1 ---- -1 ---wasWhite= -1 ---true; -1 ---- -1 ---regex.append("\\s*+"); -1 ---- -1 ---} -1 ---- -1 ---continue; -1 ---- -1 ---} -1 ---- -1 ---wasWhite= -1 ---false; -1 switch(c) -1 { -1 case -1 '\'': -1 if(unquote) -1 { -1 -2
public -1 static -1 String -1 random(int -1 count, -1 int -1 start, -1 int -1 end, -1 boolean -1 letters, -1 bool -1 start -1 = -1 ' -1 '; -1 } -1 } -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++if -1 +++(end -1 +++<= -1 +++start) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Parameter -1 +++end -1 +++(" -1 ++++ -1 +++end -1 ++++ -1 +++") -1 +++must -1 +++be -1 +++greater -1 +++than -1 +++start -1 +++(" -1 ++++ -1 +++start -1 ++++ -1 +++")"); -1 ++++ -1 +++} -1 } -1 char[] -1 buffer -1 = -1 new -1 char[count]; -1 -2
private -1 void -1 init() -1 { -1 currentFormatField= -1 nextFormatField; -1 currentStrategy= -1 nextStrategy; -1 } -1 ++++ -1 +++if -1 +++(patternMatcher.regionStart() -1 +++!= -1 +++patternMatcher.regionEnd()) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Failed -1 +++to -1 +++parse -1 +++\""+pattern+"\" -1 +++; -1 +++gave -1 +++up -1 +++at -1 +++index -1 +++"+patternMatcher.regionStart()); -1 ++++ -1 +++} -1 if(currentStrategy.addRegex(this, -1 regex)) -1 { -1 collector.add(currentStrategy); -1 } -1 -2
public -1 static -1 Object -1 deserialize(InputStream -1 inputStream) -1 { -1 public -1 static -1 Object -1 deserialize(byte[] -1 objectData) -1 { -1 if -1 (objectData -1 == -1 null) -1 { -1 throw -1 new -1 IllegalArgumentException("The -1 byte[] -1 must -1 not -1 be -1 null"); -1 } -1 ByteArrayInputStream -1 bais -1 = -1 new -1 ByteArrayInputStream(objectData); -1 return -1 deserialize(bais); -1 } -1 /** -1 * -1 <p>Custom -1 specialization -1 of -1 the -1 standard -1 JDK -1 {@link -1 java.io.ObjectInputStream} -1 * -1 that -1 uses -1 a -1 custom -1 <code>ClassLoader</code> -1 to -1 resolve -1 a -1 class. -1 * -1 If -1 the -1 specified -1 <code>ClassLoader</code> -1 is -1 not -1 able -1 to -1 resolve -1 the -1 class, -1 * -1 the -1 context -1 classloader -1 of -1 the -1 current -1 thread -1 will -1 be -1 used. -1 * -1 This -1 way, -1 the -1 standard -1 deserialization -1 work -1 also -1 in -1 web-application -1 * -1 containers -1 and -1 application -1 servers, -1 no -1 matter -1 in -1 which -1 of -1 the -1 * -1 <code>ClassLoader</code> -1 the -1 particular -1 class -1 that -1 encapsulates -1 * -1 serialization/deserialization -1 lives. -1 </p> -1 * -1 * -1 <p>For -1 more -1 in-depth -1 information -1 about -1 the -1 problem -1 for -1 which -1 this -1 * -1 class -1 here -1 is -1 a -1 workaround, -1 see -1 the -1 JIRA -1 issue -1 LANG-626. -1 </p> -1 */ -1 static -1 class -1 ClassLoaderAwareObjectInputStream -1 extends -1 ObjectInputStream -1 { -1 ++++ -1 +++private -1 +++static -1 +++final -1 +++Map<String, -1 +++Class<?>> -1 +++primitiveTypes -1 +++= -1 ++++ -1 +++new -1 +++HashMap<String, -1 +++Class<?>>(); -1 private -1 ClassLoader -1 classLoader; -1 /** -1 * -1 Constructor. -1 * -1 @param -1 in -1 The -1 <code>InputStream</code>. -1 * -1 @param -1 classLoader -1 classloader -1 to -1 use -1 * -1 @throws -1 IOException -1 if -1 an -1 I/O -1 error -1 occurs -1 while -1 reading -1 stream -1 header. -1 * -1 @see -1 java.io.ObjectInputStream -1 */ -1 public -1 ClassLoaderAwareObjectInputStream(InputStream -1 in, -1 ClassLoader -1 classLoader) -1 throws -1 IOException -1 { -1 super(in); -1 this.classLoader -1 = -1 classLoader; -1 ++++ -1 +++primitiveTypes.put("byte", -1 +++byte.class); -1 ++++ -1 +++primitiveTypes.put("short", -1 +++short.class); -1 ++++ -1 +++primitiveTypes.put("int", -1 +++int.class); -1 ++++ -1 +++primitiveTypes.put("long", -1 +++long.class); -1 ++++ -1 +++primitiveTypes.put("float", -1 +++float.class); -1 ++++ -1 +++primitiveTypes.put("double", -1 +++double.class); -1 ++++ -1 +++primitiveTypes.put("boolean", -1 +++boolean.class); -1 ++++ -1 +++primitiveTypes.put("char", -1 +++char.class); -1 ++++ -1 +++primitiveTypes.put("void", -1 +++void.class); -1 } -1 /** -1 * -1 Overriden -1 version -1 that -1 uses -1 the -1 parametrized -1 <code>ClassLoader</code> -1 or -1 the -1 <code>ClassLoader</code> -1 * -1 of -1 the -1 current -1 <code>Thread</code> -1 to -1 resolve -1 the -1 class. -1 * -1 @param -1 desc -1 An -1 instance -1 of -1 class -1 <code>ObjectStreamClass</code>. -1 * -1 @return -1 A -1 <code>Class</code> -1 object -1 corresponding -1 to -1 <code>desc</code>. -1 * -1 @throws -1 IOException -1 Any -1 of -1 the -1 usual -1 Input/Output -1 exceptions. -1 * -1 @throws -1 ClassNotFoundException -1 If -1 class -1 of -1 a -1 serialized -1 object -1 cannot -1 be -1 found. -1 */ -1 @Override -1 protected -1 Class<?> -1 resolveClass(ObjectStreamClass -1 desc) -1 throws -1 IOException, -1 ClassNotFoundException -1 { -1 String -1 name -1 = -1 desc.getName(); -1 try -1 { -1 return -1 Class.forName(name, -1 false, -1 classLoader); -1 } -1 catch -1 (ClassNotFoundException -1 ex) -1 { -1 ++++ -1 +++try -1 +++{ -1 return -1 Class.forName(name, -1 false, -1 Thread.currentThread().getContextClassLoader()); -1 ++++ -1 +++} -1 +++catch -1 +++(ClassNotFoundException -1 +++cnfe) -1 +++{ -1 ++++ -1 +++Class<?> -1 +++cls -1 +++= -1 +++primitiveTypes.get(name); -1 ++++ -1 +++if -1 +++(cls -1 +++!= -1 +++null) -1 ++++ -1 +++return -1 +++cls; -1 ++++ -1 +++else -1 ++++ -1 +++throw -1 +++cnfe; -1 ++++ -1 +++} -1 } -1 } -1 } -1 } -1 -2
public -1 static -1 String -1 random(int -1 count, -1 int -1 start, -1 int -1 end, -1 boolean -1 letters, -1 bool -1 } -1 else -1 if -1 (count -1 < -1 0) -1 { -1 throw -1 new -1 IllegalArgumentException("Requested -1 random -1 string -1 length -1 " -1 + -1 count -1 + -1 " -1 is -1 less -1 than -1 0."); -1 } -1 ++++ -1 +++if -1 +++(chars -1 +++!= -1 +++null -1 +++&& -1 +++chars.length -1 +++== -1 +++0) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("The -1 +++chars -1 +++array -1 +++must -1 +++not -1 +++be -1 +++empty"); -1 ++++ -1 +++} -1 if -1 (start -1 == -1 0 -1 && -1 end -1 == -1 0) -1 { -1 ++++ -1 +++if -1 +++(chars -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++end -1 +++= -1 +++chars.length; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 if -1 (!letters -1 && -1 !numbers) -1 { -1 end -1 = -1 Integer.MAX_VALUE; -1 } -1 else -1 { -1 end -1 = -1 'z' -1 + -1 1; -1 start -1 = -1 ' -1 '; -1 } -1 ++++ -1 +++} -1 } -1 char[] -1 buffer -1 = -1 new -1 char[count]; -1 -2
private -1 void -1 init() -1 { -1 rule -1 = -1 new -1 TextField(Calendar.ERA, -1 ERAs); -1 break; -1 case -1 'y': -1 // -1 year -1 (number) -1 ---- -1 ---if -1 ---(tokenLen -1 --->= -1 ---4) -1 ---{ -1 ---- -1 ---rule -1 ---= -1 ---selectNumberRule(Calendar.YEAR, -1 ---tokenLen); -1 ---- -1 ---} -1 ---else -1 ---{ -1 ++++ -1 +++if -1 +++(tokenLen -1 +++== -1 +++2) -1 +++{ -1 rule -1 = -1 TwoDigitYearField.INSTANCE; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++rule -1 +++= -1 +++selectNumberRule(Calendar.YEAR, -1 +++tokenLen -1 +++< -1 +++4 -1 +++? -1 +++4 -1 +++: -1 +++tokenLen); -1 } -1 break; -1 case -1 'M': -1 // -1 month -1 in -1 year -1 (text -1 and -1 number) -1 -2
public -1 final -1 void -1 translate(CharSequence -1 input, -1 Writer -1 out) -1 throws -1 IOException -1 { -1 return; -1 } -1 int -1 pos -1 = -1 0; -1 ---- -1 ---int -1 ---len -1 ---= -1 ---Character.codePointCount(input, -1 ---0, -1 ---input.length()); -1 ++++ -1 +++int -1 +++len -1 +++= -1 +++input.length(); -1 while -1 (pos -1 < -1 len) -1 { -1 int -1 consumed -1 = -1 translate(input, -1 pos, -1 out); -1 if -1 (consumed -1 == -1 0) -1 { -1 char[] -1 c -1 = -1 Character.toChars(Character.codePointAt(input, -1 pos)); -1 out.write(c); -1 ++++ -1 +++pos+= -1 +++c.length; -1 ++++ -1 +++continue; -1 } -1 ---- -1 ---else -1 ---{ -1 // -1 // -1 contract -1 with -1 translators -1 is -1 that -1 they -1 have -1 to -1 understand -1 codepoints -1 // -1 // -1 and -1 they -1 just -1 took -1 care -1 of -1 a -1 surrogate -1 pair -1 for -1 (int -1 pt -1 = -1 0; -1 pt -1 < -1 consumed; -1 pt++) -1 { -1 ---- -1 ---if -1 ---(pos -1 ---< -1 ---len -1 ---- -1 ---2) -1 ---{ -1 pos -1 += -1 Character.charCount(Character.codePointAt(input, -1 pos)); -1 ---- -1 ---} -1 ---else -1 ---{ -1 ---- -1 ---pos++; -1 ---- -1 ---} -1 ---- -1 ---} -1 ---- -1 ---pos--; -1 } -1 ---- -1 ---pos++; -1 } -1 } -1 -2
public -1 static -1 boolean -1 equals(CharSequence -1 cs1, -1 CharSequence -1 cs2) -1 { -1 if -1 (cs1 -1 == -1 null -1 || -1 cs2 -1 == -1 null) -1 { -1 return -1 false; -1 } -1 ++++ -1 +++if -1 +++(cs1 -1 +++instanceof -1 +++String -1 +++&& -1 +++cs2 -1 +++instanceof -1 +++String) -1 +++{ -1 return -1 cs1.equals(cs2); -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++CharSequenceUtils.regionMatches(cs1, -1 +++false, -1 +++0, -1 +++cs2, -1 +++0, -1 +++Math.max(cs1.length(), -1 +++cs2.length())); -1 } -1 /** -1 -2
public -1 static -1 Number -1 createNumber(String -1 str) -1 throws -1 NumberFormatException -1 { -1 // -1 a -1 wrong -1 value. -1 return -1 null; -1 } -1 ---- -1 ---if -1 ---(str.startsWith("0x") -1 ---|| -1 ---str.startsWith("-0x")) -1 ---{ -1 ++++ -1 +++if -1 +++(str.startsWith("0x") -1 +++|| -1 +++str.startsWith("-0x") -1 +++|| -1 +++str.startsWith("0X") -1 +++|| -1 +++str.startsWith("-0X")) -1 +++{ -1 return -1 createInteger(str); -1 } -1 char -1 lastChar -1 = -1 str.charAt(str.length() -1 - -1 1); -1 -2
private -1 static -1 boolean -1 isAssignable(Type -1 type, -1 ParameterizedType -1 toParameterized -1 toClass, -1 typeVarAssigns); -1 // -1 now -1 to -1 check -1 each -1 type -1 argument -1 ---- -1 ---for -1 ---(Map.Entry<TypeVariable<?>, -1 ---Type> -1 ---entry -1 ---: -1 ---toTypeVarAssigns.entrySet()) -1 ---{ -1 ---- -1 ---Type -1 ---toTypeArg -1 ---= -1 ---entry.getValue(); -1 ---- -1 ---Type -1 ---fromTypeArg -1 ---= -1 ---fromTypeVarAssigns.get(entry.getKey()); -1 ++++ -1 +++for -1 +++(TypeVariable<?> -1 +++var -1 +++: -1 +++toTypeVarAssigns.keySet()) -1 +++{ -1 ++++ -1 +++Type -1 +++toTypeArg -1 +++= -1 +++unrollVariableAssignments(var, -1 +++toTypeVarAssigns); -1 ++++ -1 +++Type -1 +++fromTypeArg -1 +++= -1 +++unrollVariableAssignments(var, -1 +++fromTypeVarAssigns); -1 // -1 parameters -1 must -1 either -1 be -1 absent -1 from -1 the -1 subject -1 type, -1 within -1 // -1 the -1 bounds -1 of -1 the -1 wildcard -1 type, -1 or -1 be -1 an -1 exact -1 match -1 to -1 the -1 @@ -1 -672,7 -1 +672,7 -1 @@ -1 private -1 static -1 Type -1 substituteTypeVariables(Type -1 type, -1 Map<TypeVariable<?>, -1 Type -1 : -1 new -1 HashMap<TypeVariable<?>, -1 Type>(subtypeVarAssigns); -1 // -1 has -1 target -1 class -1 been -1 reached? -1 ---- -1 ---if -1 ---(cls.getTypeParameters().length -1 ---> -1 ---0 -1 ---|| -1 ---toClass.equals(cls)) -1 ---{ -1 ++++ -1 +++if -1 +++(toClass.equals(cls)) -1 +++{ -1 return -1 typeVarAssigns; -1 } -1 -2
public -1 static -1 boolean -1 isSameLocalTime(Calendar -1 cal1, -1 Calendar -1 cal2) -1 { -1 return -1 (cal1.get(Calendar.MILLISECOND) -1 == -1 cal2.get(Calendar.MILLISECOND) -1 && -1 cal1.get(Calendar.SECOND) -1 == -1 cal2.get(Calendar.SECOND) -1 && -1 cal1.get(Calendar.MINUTE) -1 == -1 cal2.get(Calendar.MINUTE) -1 && -1 ---- -1 ---cal1.get(Calendar.HOUR) -1 ---== -1 ---cal2.get(Calendar.HOUR) -1 ---&& -1 ++++ -1 +++cal1.get(Calendar.HOUR_OF_DAY) -1 +++== -1 +++cal2.get(Calendar.HOUR_OF_DAY) -1 +++&& -1 cal1.get(Calendar.DAY_OF_YEAR) -1 == -1 cal2.get(Calendar.DAY_OF_YEAR) -1 && -1 cal1.get(Calendar.YEAR) -1 == -1 cal2.get(Calendar.YEAR) -1 && -1 cal1.get(Calendar.ERA) -1 == -1 cal2.get(Calendar.ERA) -1 && -1 -2
public -1 int -1 translate(CharSequence -1 input, -1 int -1 index, -1 Writer -1 out) -1 throws -1 IOException -1 { -1 int -1 seqEnd -1 = -1 input.length(); -1 // -1 Uses -1 -2 -1 to -1 ensure -1 there -1 is -1 something -1 after -1 the -1 &# -1 ---- -1 ---if(input.charAt(index) -1 ---== -1 ---'&' -1 ---&& -1 ---index -1 ---< -1 ---seqEnd -1 ---- -1 ---1 -1 ---&& -1 ---input.charAt(index -1 ---+ -1 ---1) -1 ---== -1 ---'#') -1 ---{ -1 ++++ -1 +++if(input.charAt(index) -1 +++== -1 +++'&' -1 +++&& -1 +++index -1 +++< -1 +++seqEnd -1 +++- -1 +++2 -1 +++&& -1 +++input.charAt(index -1 ++++ -1 +++1) -1 +++== -1 +++'#') -1 +++{ -1 int -1 start -1 = -1 index -1 + -1 2; -1 boolean -1 isHex -1 = -1 false; -1 @@ -1 -47,11 -1 +47,16 -1 @@ -1 public -1 int -1 translate(CharSequence -1 input, -1 int -1 index, -1 Writer -1 out) -1 throws -1 IOExcepti -1 isHex -1 = -1 true; -1 // -1 Check -1 there's -1 more -1 than -1 just -1 an -1 x -1 after -1 the -1 &# -1 ++++ -1 +++if(start -1 +++== -1 +++seqEnd) -1 +++{ -1 ++++ -1 +++return -1 +++0; -1 ++++ -1 +++} -1 } -1 int -1 end -1 = -1 start; -1 // -1 Note -1 that -1 this -1 supports -1 character -1 codes -1 without -1 a -1 ; -1 on -1 the -1 end -1 ---- -1 ---while(input.charAt(end) -1 ---!= -1 ---';') -1 ++++ -1 +++while(end -1 +++< -1 +++seqEnd -1 +++&& -1 +++( -1 +++(input.charAt(end) -1 +++>= -1 +++'0' -1 +++&& -1 +++input.charAt(end) -1 +++<= -1 +++'9') -1 +++|| -1 ++++ -1 +++(input.charAt(end) -1 +++>= -1 +++'a' -1 +++&& -1 +++input.charAt(end) -1 +++<= -1 +++'f') -1 +++|| -1 ++++ -1 +++(input.charAt(end) -1 +++>= -1 +++'A' -1 +++&& -1 +++input.charAt(end) -1 +++<= -1 +++'F') -1 +++) -1 +++) -1 { -1 end++; -1 } -1 @@ -1 -76,8 -1 +81,9 -1 @@ -1 public -1 int -1 translate(CharSequence -1 input, -1 int -1 index, -1 Writer -1 out) -1 throws -1 IOExcepti -1 out.write(entityValue); -1 } -1 ++++ -1 +++boolean -1 +++semiNext -1 +++= -1 +++(end -1 +++!= -1 +++seqEnd) -1 +++&& -1 +++(input.charAt(end) -1 +++== -1 +++';'); -1 ---- -1 ---return -1 ---2 -1 ---+ -1 ---(end -1 ---- -1 ---start) -1 ---+ -1 ---(isHex -1 ---? -1 ---1 -1 ---: -1 ---0) -1 ---+ -1 ---1; -1 ++++ -1 +++return -1 +++2 -1 ++++ -1 +++(end -1 +++- -1 +++start) -1 ++++ -1 +++(isHex -1 +++? -1 +++1 -1 +++: -1 +++0) -1 ++++ -1 +++(semiNext -1 +++? -1 +++1 -1 +++: -1 +++0); -1 } -1 return -1 0; -1 } -1 -2
*/ -1 public -1 class -1 ExtendedMessageFormat -1 extends -1 MessageFormat -1 { -1 private -1 static -1 final -1 long -1 serialVersionUID -1 = -1 -2362048321261811743L; -1 ++++ -1 +++private -1 +++static -1 +++final -1 +++int -1 +++HASH_SEED -1 +++= -1 +++31; -1 private -1 static -1 final -1 String -1 DUMMY_PATTERN -1 = -1 ""; -1 private -1 static -1 final -1 String -1 ESCAPED_QUOTE -1 = -1 "''"; -1 @@ -1 -260,12 -1 +261,42 -1 @@ -1 public -1 void -1 setFormatsByArgumentIndex(Format[] -1 newFormats) -1 { -1 * -1 @param -1 obj -1 the -1 object -1 to -1 compare -1 to -1 * -1 @return -1 true -1 if -1 this -1 object -1 equals -1 the -1 other, -1 otherwise -1 false -1 */ -1 ++++ -1 +++@Override -1 ++++ -1 +++public -1 +++boolean -1 +++equals(Object -1 +++obj) -1 +++{ -1 ++++ -1 +++if -1 +++(obj -1 +++== -1 +++this) -1 +++{ -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(obj -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(!super.equals(obj)) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(ObjectUtils.notEqual(getClass(), -1 +++obj.getClass())) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++ExtendedMessageFormat -1 +++rhs -1 +++= -1 +++(ExtendedMessageFormat)obj; -1 ++++ -1 +++if -1 +++(ObjectUtils.notEqual(toPattern, -1 +++rhs.toPattern)) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(ObjectUtils.notEqual(registry, -1 +++rhs.registry)) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 /** -1 * -1 Return -1 the -1 hashcode. -1 * -1 * -1 @return -1 the -1 hashcode -1 */ -1 ++++ -1 +++@Override -1 ++++ -1 +++public -1 +++int -1 +++hashCode() -1 +++{ -1 ++++ -1 +++int -1 +++result -1 +++= -1 +++super.hashCode(); -1 ++++ -1 +++result -1 +++= -1 +++HASH_SEED -1 +++* -1 +++result -1 ++++ -1 +++ObjectUtils.hashCode(registry); -1 ++++ -1 +++result -1 +++= -1 +++HASH_SEED -1 +++* -1 +++result -1 ++++ -1 +++ObjectUtils.hashCode(toPattern); -1 ++++ -1 +++return -1 +++result; -1 ++++ -1 +++} -1 /** -1 * -1 Get -1 a -1 custom -1 format -1 from -1 a -1 format -1 description. -1 -2
public -1 Fraction -1 pow(int -1 power) -1 { -1 */ -1 private -1 static -1 int -1 greatestCommonDivisor(int -1 u, -1 int -1 v) -1 { -1 // -1 From -1 Commons -1 Math: -1 ++++ -1 +++if -1 +++((u -1 +++== -1 +++0) -1 +++|| -1 +++(v -1 +++== -1 +++0)) -1 +++{ -1 ++++ -1 +++if -1 +++((u -1 +++== -1 +++Integer.MIN_VALUE) -1 +++|| -1 +++(v -1 +++== -1 +++Integer.MIN_VALUE)) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++ArithmeticException("overflow: -1 +++gcd -1 +++is -1 +++2^31"); -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++Math.abs(u) -1 ++++ -1 +++Math.abs(v); -1 ++++ -1 +++} -1 //if -1 either -1 operand -1 is -1 abs -1 1, -1 return -1 1: -1 ---- -1 ---if -1 ---(Math.abs(u) -1 ---<= -1 ---1 -1 ---|| -1 ---Math.abs(v) -1 ---<= -1 ---1) -1 ---{ -1 ++++ -1 +++if -1 +++(Math.abs(u) -1 +++== -1 +++1 -1 +++|| -1 +++Math.abs(v) -1 +++== -1 +++1) -1 +++{ -1 return -1 1; -1 } -1 // -1 keep -1 u -1 and -1 v -1 negative, -1 as -1 negative -1 integers -1 range -1 down -1 to -1 -2
public -1 static -1 String -1 join(Object[] -1 array, -1 char -1 separator, -1 int -1 startIndex, -1 int -1 en -1 return -1 EMPTY; -1 } -1 ---- -1 ---StringBuilder -1 ---buf -1 ---= -1 ---new -1 ---StringBuilder((array[startIndex] -1 ---== -1 ---null -1 ---? -1 ---16 -1 ---: -1 ---array[startIndex].toString().length()) -1 ---+ -1 ---1); -1 ++++ -1 +++StringBuilder -1 +++buf -1 +++= -1 +++new -1 +++StringBuilder(noOfItems -1 +++* -1 +++16); -1 for -1 (int -1 i -1 = -1 startIndex; -1 i -1 < -1 endIndex; -1 i++) -1 { -1 if -1 (i -1 > -1 startIndex) -1 { -1 @@ -1 -3380,7 -1 +3380,7 -1 @@ -1 public -1 static -1 String -1 join(Object[] -1 array, -1 String -1 separator, -1 int -1 startIndex, -1 int -1 return -1 EMPTY; -1 } -1 ---- -1 ---StringBuilder -1 ---buf -1 ---= -1 ---new -1 ---StringBuilder((array[startIndex] -1 ---== -1 ---null -1 ---? -1 ---16 -1 ---: -1 ---array[startIndex].toString().length()) -1 ---+ -1 ---separator.length()); -1 ++++ -1 +++StringBuilder -1 +++buf -1 +++= -1 +++new -1 +++StringBuilder(noOfItems -1 +++* -1 +++16); -1 for -1 (int -1 i -1 = -1 startIndex; -1 i -1 < -1 endIndex; -1 i++) -1 { -1 if -1 (i -1 > -1 startIndex) -1 { -1 -2
public -1 static -1 boolean -1 isNumber(String -1 str) -1 { -1 if -1 (chars[i] -1 == -1 'l' -1 || -1 chars[i] -1 == -1 'L') -1 { -1 // -1 not -1 allowing -1 L -1 with -1 an -1 exponent -1 or -1 decimal -1 point -1 ---- -1 ---return -1 ---foundDigit -1 ---&& -1 ---!hasExp; -1 ++++ -1 +++return -1 +++foundDigit -1 +++&& -1 +++!hasExp -1 +++&& -1 +++!hasDecPoint; -1 } -1 // -1 last -1 character -1 is -1 illegal -1 return -1 false; -1 -2
public -1 String -1 format(long -1 millis) -1 { -1 * -1 @return -1 the -1 formatted -1 string -1 */ -1 public -1 String -1 format(Date -1 date) -1 { -1 ---- -1 ---Calendar -1 ---c -1 ---= -1 ---new -1 ---GregorianCalendar(mTimeZone); -1 ++++ -1 +++Calendar -1 +++c -1 +++= -1 +++new -1 +++GregorianCalendar(mTimeZone, -1 +++mLocale); -1 c.setTime(date); -1 return -1 applyRules(c, -1 new -1 StringBuffer(mMaxLengthEstimate)).toString(); -1 } -1 -2
{"\u00C7", -1 "&Ccedil;"}, -1 // -1  -1 - -1 uppercase -1 C, -1 cedilla -1 {"\u00C8", -1 "&Egrave;"}, -1 // -1  -1 - -1 uppercase -1 E, -1 grave -1 accent -1 {"\u00C9", -1 "&Eacute;"}, -1 // -1  -1 - -1 uppercase -1 E, -1 acute -1 accent -1 ---- -1 ---{"\u00CB", -1 ---"&Ecirc;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---E, -1 ---circumflex -1 ---accent -1 ---- -1 ---{"\u00CC", -1 ---"&Euml;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---E, -1 ---umlaut -1 ---- -1 ---{"\u00CD", -1 ---"&Igrave;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---I, -1 ---grave -1 ---accent -1 ---- -1 ---{"\u00CE", -1 ---"&Iacute;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---I, -1 ---acute -1 ---accent -1 ---- -1 ---{"\u00CF", -1 ---"&Icirc;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---I, -1 ---circumflex -1 ---accent -1 ---- -1 ---{"\u00D0", -1 ---"&Iuml;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---I, -1 ---umlaut -1 ---- -1 ---{"\u00D1", -1 ---"&ETH;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---Eth, -1 ---Icelandic -1 ---- -1 ---{"\u00D2", -1 ---"&Ntilde;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---N, -1 ---tilde -1 ---- -1 ---{"\u00D3", -1 ---"&Ograve;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---O, -1 ---grave -1 ---accent -1 ---- -1 ---{"\u00D4", -1 ---"&Oacute;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---O, -1 ---acute -1 ---accent -1 ---- -1 ---{"\u00D5", -1 ---"&Ocirc;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---O, -1 ---circumflex -1 ---accent -1 ---- -1 ---{"\u00D6", -1 ---"&Otilde;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---O, -1 ---tilde -1 ---- -1 ---{"\u00D7", -1 ---"&Ouml;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---O, -1 ---umlaut -1 ---- -1 ---{"\u00D8", -1 ---"&times;"}, -1 ---// -1 ---multiplication -1 ---sign -1 ---- -1 ---{"\u00D9", -1 ---"&Oslash;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---O, -1 ---slash -1 ---- -1 ---{"\u00DA", -1 ---"&Ugrave;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---U, -1 ---grave -1 ---accent -1 ---- -1 ---{"\u00DB", -1 ---"&Uacute;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---U, -1 ---acute -1 ---accent -1 ---- -1 ---{"\u00DC", -1 ---"&Ucirc;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---U, -1 ---circumflex -1 ---accent -1 ---- -1 ---{"\u00DD", -1 ---"&Uuml;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---U, -1 ---umlaut -1 ---- -1 ---{"\u00DE", -1 ---"&Yacute;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---Y, -1 ---acute -1 ---accent -1 ---- -1 ---{"\u00DF", -1 ---"&THORN;"}, -1 ---// -1 --- -1 ---- -1 ---uppercase -1 ---THORN, -1 ---Icelandic -1 ---- -1 ---{"\u00E0", -1 ---"&szlig;"}, -1 ---// -1 --- -1 ---- -1 ---lowercase -1 ---sharps, -1 ---German -1 ---- -1 ---{"\u00E1", -1 ---"&agrave;"}, -1 ---// -1 --- -1 ---- -1 ---lowercase -1 ---a, -1 ---grave -1 ---accent -1 ---- -1 ---{"\u00E2", -1 ---"&aacute;"}, -1 ---// -1 --- -1 ---- -1 ---lowercase -1 ---a, -1 ---acute -1 ---accent -1 ---- -1 ---{"\u00E3", -1 ---"&acirc;"}, -1 ---// -1 --- -1 ---- -1 ---lowercase -1 ---a, -1 ---circumflex -1 ---accent -1 ---- -1 ---{"\u00E4", -1 ---"&atilde;"}, -1 ---// -1 --- -1 ---- -1 ---lowercase -1 ---a, -1 ---tilde -1 ---- -1 ---{"\u00E5", -1 ---"&auml;"}, -1 ---// -1 --- -1 ---- -1 ---lowercase -1 ---a, -1 ---umlaut -1 ++++ -1 +++{"\u00CA", -1 +++"&Ecirc;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++E, -1 +++circumflex -1 +++accent -1 ++++ -1 +++{"\u00CB", -1 +++"&Euml;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++E, -1 +++umlaut -1 ++++ -1 +++{"\u00CC", -1 +++"&Igrave;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++I, -1 +++grave -1 +++accent -1 ++++ -1 +++{"\u00CD", -1 +++"&Iacute;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++I, -1 +++acute -1 +++accent -1 ++++ -1 +++{"\u00CE", -1 +++"&Icirc;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++I, -1 +++circumflex -1 +++accent -1 ++++ -1 +++{"\u00CF", -1 +++"&Iuml;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++I, -1 +++umlaut -1 ++++ -1 +++{"\u00D0", -1 +++"&ETH;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++Eth, -1 +++Icelandic -1 ++++ -1 +++{"\u00D1", -1 +++"&Ntilde;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++N, -1 +++tilde -1 ++++ -1 +++{"\u00D2", -1 +++"&Ograve;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++O, -1 +++grave -1 +++accent -1 ++++ -1 +++{"\u00D3", -1 +++"&Oacute;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++O, -1 +++acute -1 +++accent -1 ++++ -1 +++{"\u00D4", -1 +++"&Ocirc;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++O, -1 +++circumflex -1 +++accent -1 ++++ -1 +++{"\u00D5", -1 +++"&Otilde;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++O, -1 +++tilde -1 ++++ -1 +++{"\u00D6", -1 +++"&Ouml;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++O, -1 +++umlaut -1 ++++ -1 +++{"\u00D7", -1 +++"&times;"}, -1 +++// -1 +++multiplication -1 +++sign -1 ++++ -1 +++{"\u00D8", -1 +++"&Oslash;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++O, -1 +++slash -1 ++++ -1 +++{"\u00D9", -1 +++"&Ugrave;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++U, -1 +++grave -1 +++accent -1 ++++ -1 +++{"\u00DA", -1 +++"&Uacute;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++U, -1 +++acute -1 +++accent -1 ++++ -1 +++{"\u00DB", -1 +++"&Ucirc;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++U, -1 +++circumflex -1 +++accent -1 ++++ -1 +++{"\u00DC", -1 +++"&Uuml;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++U, -1 +++umlaut -1 ++++ -1 +++{"\u00DD", -1 +++"&Yacute;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++Y, -1 +++acute -1 +++accent -1 ++++ -1 +++{"\u00DE", -1 +++"&THORN;"}, -1 +++// -1 +++ -1 +++- -1 +++uppercase -1 +++THORN, -1 +++Icelandic -1 ++++ -1 +++{"\u00DF", -1 +++"&szlig;"}, -1 +++// -1 +++ -1 +++- -1 +++lowercase -1 +++sharps, -1 +++German -1 ++++ -1 +++{"\u00E0", -1 +++"&agrave;"}, -1 +++// -1 +++ -1 +++- -1 +++lowercase -1 +++a, -1 +++grave -1 +++accent -1 ++++ -1 +++{"\u00E1", -1 +++"&aacute;"}, -1 +++// -1 +++ -1 +++- -1 +++lowercase -1 +++a, -1 +++acute -1 +++accent -1 ++++ -1 +++{"\u00E2", -1 +++"&acirc;"}, -1 +++// -1 +++ -1 +++- -1 +++lowercase -1 +++a, -1 +++circumflex -1 +++accent -1 ++++ -1 +++{"\u00E3", -1 +++"&atilde;"}, -1 +++// -1 +++ -1 +++- -1 +++lowercase -1 +++a, -1 +++tilde -1 ++++ -1 +++{"\u00E4", -1 +++"&auml;"}, -1 +++// -1 +++ -1 +++- -1 +++lowercase -1 +++a, -1 +++umlaut -1 {"\u00E5", -1 "&aring;"}, -1 // -1  -1 - -1 lowercase -1 a, -1 ring -1 {"\u00E6", -1 "&aelig;"}, -1 // -1  -1 - -1 lowercase -1 ae -1 {"\u00E7", -1 "&ccedil;"}, -1 // -1  -1 - -1 lowercase -1 c, -1 cedilla -1 -2
static -1 float -1 toJavaVersionFloat(String -1 version) -1 { -1 * -1 * -1 @return -1 the -1 version, -1 for -1 example -1 131 -1 for -1 Java -1 1.3.1 -1 */ -1 ---- -1 ---static -1 ---float -1 ---toJavaVersionInt(String -1 ---version) -1 ---{ -1 ++++ -1 +++static -1 +++int -1 +++toJavaVersionInt(String -1 +++version) -1 +++{ -1 return -1 toVersionInt(toJavaVersionIntArray(version, -1 JAVA_VERSION_TRIM_SIZE)); -1 } -1 -2
public -1 static -1 int -1 indexOfAny(CharSequence -1 cs, -1 char[] -1 searchChars) -1 { -1 return -1 INDEX_NOT_FOUND; -1 } -1 int -1 csLen -1 = -1 cs.length(); -1 ++++ -1 +++int -1 +++csLast -1 +++= -1 +++csLen -1 +++- -1 +++1; -1 int -1 searchLen -1 = -1 searchChars.length; -1 ++++ -1 +++int -1 +++searchLast -1 +++= -1 +++searchLen -1 +++- -1 +++1; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 csLen; -1 i++) -1 { -1 char -1 ch -1 = -1 cs.charAt(i); -1 for -1 (int -1 j -1 = -1 0; -1 j -1 < -1 searchLen; -1 j++) -1 { -1 if -1 (searchChars[j] -1 == -1 ch) -1 { -1 ++++ -1 +++if -1 +++(i -1 +++< -1 +++csLast -1 +++&& -1 +++j -1 +++< -1 +++searchLast -1 +++&& -1 +++Character.isHighSurrogate(ch)) -1 +++{ -1 // -1 ch -1 is -1 a -1 supplementary -1 character -1 ++++ -1 +++if -1 +++(searchChars[j -1 ++++ -1 +++1] -1 +++== -1 +++cs.charAt(i -1 ++++ -1 +++1)) -1 +++{ -1 ++++ -1 +++return -1 +++i; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 +++else -1 +++{ -1 return -1 i; -1 ++++ -1 +++} -1 } -1 } -1 } -1 @@ -1 -1440,7 -1 +1448,7 -1 @@ -1 public -1 static -1 int -1 indexOfAny(CharSequence -1 cs, -1 String -1 searchChars) -1 { -1 * -1 <code>false</code> -1 if -1 no -1 match -1 or -1 null -1 input -1 * -1 @since -1 2.4 -1 */ -1 ---- -1 ---public -1 ---static -1 ---boolean -1 ---containsAny(CharSequence -1 ---cs, -1 ---char[] -1 ---searchChars) -1 ---{ -1 ++++ -1 +++public -1 +++static -1 +++boolean -1 +++containsAny(String -1 +++cs, -1 +++char[] -1 +++searchChars) -1 +++{ -1 if -1 (isEmpty(cs) -1 || -1 ArrayUtils.isEmpty(searchChars)) -1 { -1 return -1 false; -1 } -1 @@ -1 -1452,9 -1 +1460,12 -1 @@ -1 public -1 static -1 boolean -1 containsAny(CharSequence -1 cs, -1 char[] -1 searchChars) -1 { -1 char -1 ch -1 = -1 cs.charAt(i); -1 for -1 (int -1 j -1 = -1 0; -1 j -1 < -1 searchLength; -1 j++) -1 { -1 if -1 (searchChars[j] -1 == -1 ch) -1 { -1 ---- -1 ---if -1 ---(i -1 ---< -1 ---csLast -1 ---&& -1 ---j -1 ---< -1 ---searchLast -1 ---&& -1 ---ch -1 --->= -1 ---Character.MIN_HIGH_SURROGATE -1 ---&& -1 ---ch -1 ---<= -1 ---Character.MAX_HIGH_SURROGATE) -1 ---{ -1 ++++ -1 +++if -1 +++(Character.isHighSurrogate(ch)) -1 +++{ -1 ++++ -1 +++if -1 +++(j -1 +++== -1 +++searchLast) -1 +++{ -1 // -1 missing -1 low -1 surrogate, -1 fine, -1 like -1 String.indexOf(String) -1 ---- -1 ---if -1 ---(searchChars[j -1 ---+ -1 ---1] -1 ---== -1 ---cs.charAt(i -1 ---+ -1 ---1)) -1 ---{ -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(i -1 +++< -1 +++csLast -1 +++&& -1 +++searchChars[j -1 ++++ -1 +++1] -1 +++== -1 +++cs.charAt(i -1 ++++ -1 +++1)) -1 +++{ -1 return -1 true; -1 } -1 } -1 else -1 { -1 @@ -1 -1494,7 -1 +1505,7 -1 @@ -1 public -1 static -1 boolean -1 containsAny(CharSequence -1 cs, -1 char[] -1 searchChars) -1 { -1 * -1 @return -1 the -1 <code>true</code> -1 if -1 any -1 of -1 the -1 chars -1 are -1 found, -1 <code>false</code> -1 if -1 no -1 match -1 or -1 null -1 input -1 * -1 @since -1 2.4 -1 */ -1 ---- -1 ---public -1 ---static -1 ---boolean -1 ---containsAny(CharSequence -1 ---cs, -1 ---String -1 ---searchChars) -1 ---{ -1 ++++ -1 +++public -1 +++static -1 +++boolean -1 +++containsAny(String -1 +++cs, -1 +++String -1 +++searchChars) -1 +++{ -1 if -1 (searchChars -1 == -1 null) -1 { -1 return -1 false; -1 } -1 @@ -1 -1530,13 -1 +1541,21 -1 @@ -1 public -1 static -1 int -1 indexOfAnyBut(CharSequence -1 cs, -1 char[] -1 searchChars) -1 { -1 return -1 INDEX_NOT_FOUND; -1 } -1 int -1 csLen -1 = -1 cs.length(); -1 ++++ -1 +++int -1 +++csLast -1 +++= -1 +++csLen -1 +++- -1 +++1; -1 int -1 searchLen -1 = -1 searchChars.length; -1 ++++ -1 +++int -1 +++searchLast -1 +++= -1 +++searchLen -1 +++- -1 +++1; -1 outer: -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 csLen; -1 i++) -1 { -1 char -1 ch -1 = -1 cs.charAt(i); -1 for -1 (int -1 j -1 = -1 0; -1 j -1 < -1 searchLen; -1 j++) -1 { -1 if -1 (searchChars[j] -1 == -1 ch) -1 { -1 ++++ -1 +++if -1 +++(i -1 +++< -1 +++csLast -1 +++&& -1 +++j -1 +++< -1 +++searchLast -1 +++&& -1 +++Character.isHighSurrogate(ch)) -1 +++{ -1 ++++ -1 +++if -1 +++(searchChars[j -1 ++++ -1 +++1] -1 +++== -1 +++cs.charAt(i -1 ++++ -1 +++1)) -1 +++{ -1 ++++ -1 +++continue -1 +++outer; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 +++else -1 +++{ -1 continue -1 outer; -1 ++++ -1 +++} -1 } -1 } -1 return -1 i; -1 @@ -1 -1573,8 -1 +1592,16 -1 @@ -1 public -1 static -1 int -1 indexOfAnyBut(String -1 str, -1 String -1 searchChars) -1 { -1 int -1 strLen -1 = -1 str.length(); -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 strLen; -1 i++) -1 { -1 char -1 ch -1 = -1 str.charAt(i); -1 ---- -1 ---if -1 ---(searchChars.indexOf(ch) -1 ---< -1 ---0) -1 ---{ -1 ++++ -1 +++boolean -1 +++chFound -1 +++= -1 +++searchChars.indexOf(ch) -1 +++>= -1 +++0; -1 ++++ -1 +++if -1 +++(i -1 ++++ -1 +++1 -1 +++< -1 +++strLen -1 +++&& -1 +++Character.isHighSurrogate(ch)) -1 +++{ -1 ++++ -1 +++char -1 +++ch2 -1 +++= -1 +++str.charAt(i -1 ++++ -1 +++1); -1 ++++ -1 +++if -1 +++(chFound -1 +++&& -1 +++searchChars.indexOf(ch2) -1 +++< -1 +++0) -1 +++{ -1 return -1 i; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++if -1 +++(!chFound) -1 +++{ -1 ++++ -1 +++return -1 +++i; -1 ++++ -1 +++} -1 } -1 } -1 return -1 INDEX_NOT_FOUND; -1 @@ -1 -1675,14 -1 +1702,25 -1 @@ -1 public -1 static -1 boolean -1 containsNone(CharSequence -1 cs, -1 char[] -1 searchChars) -1 { -1 return -1 true; -1 } -1 int -1 csLen -1 = -1 cs.length(); -1 ++++ -1 +++int -1 +++csLast -1 +++= -1 +++csLen -1 +++- -1 +++1; -1 int -1 searchLen -1 = -1 searchChars.length; -1 ++++ -1 +++int -1 +++searchLast -1 +++= -1 +++searchLen -1 +++- -1 +++1; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 csLen; -1 i++) -1 { -1 char -1 ch -1 = -1 cs.charAt(i); -1 for -1 (int -1 j -1 = -1 0; -1 j -1 < -1 searchLen; -1 j++) -1 { -1 if -1 (searchChars[j] -1 == -1 ch) -1 { -1 ++++ -1 +++if -1 +++(Character.isHighSurrogate(ch)) -1 +++{ -1 ++++ -1 +++if -1 +++(j -1 +++== -1 +++searchLast) -1 +++{ -1 // -1 missing -1 low -1 surrogate, -1 fine, -1 like -1 String.indexOf(String) -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(i -1 +++< -1 +++csLast -1 +++&& -1 +++searchChars[j -1 ++++ -1 +++1] -1 +++== -1 +++cs.charAt(i -1 ++++ -1 +++1)) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 +++else -1 +++{ -1 // -1 ch -1 is -1 in -1 the -1 Basic -1 Multilingual -1 Plane -1 return -1 false; -1 ++++ -1 +++} -1 } -1 } -1 } -1 -2
public -1 int -1 translate(CharSequence -1 input, -1 int -1 index, -1 Writer -1 out) -1 throws -1 IOExcepti -1 return -1 0; -1 } -1 ++++ -1 +++if(entityValue -1 +++> -1 +++0xFFFF) -1 +++{ -1 ++++ -1 +++char[] -1 +++chrs -1 +++= -1 +++Character.toChars(entityValue); -1 ++++ -1 +++out.write(chrs[0]); -1 ++++ -1 +++out.write(chrs[1]); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 out.write(entityValue); -1 ++++ -1 +++} -1 return -1 2 -1 + -1 (end -1 - -1 start) -1 + -1 (isHex -1 ? -1 1 -1 : -1 0) -1 + -1 1; -1 } -1 return -1 0; -1 -2
public -1 static -1 Number -1 createNumber(String -1 str) -1 throws -1 NumberFormatException -1 { -1 if -1 (decPos -1 > -1 -1) -1 { -1 if -1 (expPos -1 > -1 -1) -1 { -1 ---- -1 ---if -1 ---(expPos -1 ---< -1 ---decPos) -1 ---{ -1 ++++ -1 +++if -1 +++(expPos -1 +++< -1 +++decPos -1 +++|| -1 +++expPos -1 +++> -1 +++str.length()) -1 +++{ -1 throw -1 new -1 NumberFormatException(str -1 + -1 " -1 is -1 not -1 a -1 valid -1 number."); -1 } -1 dec -1 = -1 str.substring(decPos -1 + -1 1, -1 expPos); -1 @@ -1 -486,6 -1 +486,9 -1 @@ -1 public -1 static -1 Number -1 createNumber(String -1 str) -1 throws -1 NumberFormatException -1 { -1 mant -1 = -1 str.substring(0, -1 decPos); -1 } -1 else -1 { -1 if -1 (expPos -1 > -1 -1) -1 { -1 ++++ -1 +++if -1 +++(expPos -1 +++> -1 +++str.length()) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++NumberFormatException(str -1 ++++ -1 +++" -1 +++is -1 +++not -1 +++a -1 +++valid -1 +++number."); -1 ++++ -1 +++} -1 mant -1 = -1 str.substring(0, -1 expPos); -1 } -1 else -1 { -1 mant -1 = -1 str; -1 -2
public -1 static -1 boolean -1 containsAny(CharSequence -1 cs, -1 char[] -1 searchChars) -1 { -1 } -1 int -1 csLength -1 = -1 cs.length(); -1 int -1 searchLength -1 = -1 searchChars.length; -1 ++++ -1 +++int -1 +++csLastIndex -1 +++= -1 +++csLength -1 +++- -1 +++1; -1 ++++ -1 +++int -1 +++searchLastIndex -1 +++= -1 +++searchLength -1 +++- -1 +++1; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 csLength; -1 i++) -1 { -1 char -1 ch -1 = -1 cs.charAt(i); -1 for -1 (int -1 j -1 = -1 0; -1 j -1 < -1 searchLength; -1 j++) -1 { -1 if -1 (searchChars[j] -1 == -1 ch) -1 { -1 ++++ -1 +++if -1 +++(i -1 +++< -1 +++csLastIndex -1 +++&& -1 +++j -1 +++< -1 +++searchLastIndex -1 +++&& -1 +++ch -1 +++>= -1 +++Character.MIN_HIGH_SURROGATE -1 +++&& -1 +++ch -1 +++<= -1 +++Character.MAX_HIGH_SURROGATE) -1 +++{ -1 // -1 ch -1 is -1 a -1 supplementary -1 character -1 ++++ -1 +++if -1 +++(searchChars[j -1 ++++ -1 +++1] -1 +++== -1 +++cs.charAt(i -1 ++++ -1 +++1)) -1 +++{ -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 +++else -1 +++{ -1 // -1 ch -1 is -1 in -1 the -1 Basic -1 Multilingual -1 Plane -1 return -1 true; -1 ++++ -1 +++} -1 } -1 } -1 } -1 -2
* -1 * -1 @since -1 2.3 -1 */ -1 ---- -1 ---private -1 ---static -1 ---final -1 ---ThreadLocal<Set<IDKey>> -1 ---REGISTRY -1 ---= -1 ---new -1 ---ThreadLocal<Set<IDKey>>() -1 ---{ -1 ---- -1 ---@Override -1 ---- -1 ---protected -1 ---Set<IDKey> -1 ---initialValue() -1 ---{ -1 ---- -1 ---return -1 ---new -1 ---HashSet<IDKey>(); -1 ---- -1 ---} -1 ---- -1 ---}; -1 ++++ -1 +++private -1 +++static -1 +++final -1 +++ThreadLocal<Set<IDKey>> -1 +++REGISTRY -1 +++= -1 +++new -1 +++ThreadLocal<Set<IDKey>>(); -1 /* -1 * -1 N.B. -1 we -1 cannot -1 store -1 the -1 actual -1 objects -1 in -1 a -1 HashSet, -1 as -1 that -1 would -1 use -1 the -1 very -1 hashCode() -1 @@ -1 -149,7 -1 +144,8 -1 @@ -1 * -1 @since -1 2.3 -1 */ -1 static -1 boolean -1 isRegistered(Object -1 value) -1 { -1 ---- -1 ---return -1 ---getRegistry().contains(new -1 ---IDKey(value)); -1 ++++ -1 +++Set<IDKey> -1 +++registry -1 +++= -1 +++getRegistry(); -1 ++++ -1 +++return -1 +++registry -1 +++!= -1 +++null -1 +++&& -1 +++registry.contains(new -1 +++IDKey(value)); -1 } -1 /** -1 @@ -1 -519,6 -1 +515,11 -1 @@ -1 public -1 static -1 int -1 reflectionHashCode(Object -1 object, -1 String[] -1 excludeFields) -1 { -1 * -1 The -1 object -1 to -1 register. -1 */ -1 static -1 void -1 register(Object -1 value) -1 { -1 ++++ -1 +++synchronized -1 +++(HashCodeBuilder.class) -1 +++{ -1 ++++ -1 +++if -1 +++(getRegistry() -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++REGISTRY.set(new -1 +++HashSet<IDKey>()); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 getRegistry().add(new -1 IDKey(value)); -1 } -1 @@ -1 -535,7 -1 +536,15 -1 @@ -1 static -1 void -1 register(Object -1 value) -1 { -1 * -1 @since -1 2.3 -1 */ -1 static -1 void -1 unregister(Object -1 value) -1 { -1 ---- -1 ---getRegistry().remove(new -1 ---IDKey(value)); -1 ++++ -1 +++Set<IDKey> -1 +++s -1 +++= -1 +++getRegistry(); -1 ++++ -1 +++if -1 +++(s -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++s.remove(new -1 +++IDKey(value)); -1 ++++ -1 +++synchronized -1 +++(HashCodeBuilder.class) -1 +++{ -1 ++++ -1 +++if -1 +++(s.isEmpty()) -1 +++{ -1 ++++ -1 +++REGISTRY.remove(); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++} -1 } -1 /** -1 -2
private -1 static -1 String -1 toCanonicalName(String -1 className) -1 { -1 } -1 Class<?>[] -1 classes -1 = -1 new -1 Class[array.length]; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 array.length; -1 i++) -1 { -1 ---- -1 ---classes[i] -1 ---= -1 ---array[i].getClass(); -1 ++++ -1 +++classes[i] -1 +++= -1 +++array[i] -1 +++== -1 +++null -1 +++? -1 +++null -1 +++: -1 +++array[i].getClass(); -1 } -1 return -1 classes; -1 } -1 -2
* -1 @return -1 Set -1 the -1 registry -1 of -1 objects -1 being -1 traversed -1 */ -1 static -1 Map<Object, -1 Object> -1 getRegistry() -1 { -1 ---- -1 ---return -1 ---REGISTRY.get() -1 ---!= -1 ---null -1 ---? -1 ---REGISTRY.get() -1 ---: -1 ---Collections.<Object, -1 ---Object>emptyMap(); -1 ++++ -1 +++return -1 +++REGISTRY.get(); -1 } -1 /** -1 @@ -1 -161,7 -1 +161,7 -1 @@ -1 */ -1 static -1 boolean -1 isRegistered(Object -1 value) -1 { -1 Map<Object, -1 Object> -1 m -1 = -1 getRegistry(); -1 ---- -1 ---return -1 ---m.containsKey(value); -1 ++++ -1 +++return -1 +++m -1 +++!= -1 +++null -1 +++&& -1 +++m.containsKey(value); -1 } -1 /** -1 -2
public -1 static -1 boolean -1 isEmpty(boolean[] -1 array) -1 { -1 final -1 Class<?> -1 type1 -1 = -1 array1.getClass().getComponentType(); -1 T[] -1 joinedArray -1 = -1 (T[]) -1 Array.newInstance(type1, -1 array1.length -1 + -1 array2.length); -1 System.arraycopy(array1, -1 0, -1 joinedArray, -1 0, -1 array1.length); -1 ++++ -1 +++try -1 +++{ -1 System.arraycopy(array2, -1 0, -1 joinedArray, -1 array1.length, -1 array2.length); -1 ++++ -1 +++} -1 +++catch -1 +++(ArrayStoreException -1 +++ase) -1 +++{ -1 // -1 Check -1 if -1 problem -1 is -1 incompatible -1 types -1 ++++ -1 +++final -1 +++Class<?> -1 +++type2 -1 +++= -1 +++array2.getClass().getComponentType(); -1 ++++ -1 +++if -1 +++(!type1.isAssignableFrom(type2)){ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Cannot -1 +++store -1 +++"+type2.getName()+" -1 +++in -1 +++an -1 +++array -1 +++of -1 +++"+type1.getName()); -1 ++++ -1 +++} -1 ++++ -1 +++throw -1 +++ase; -1 +++// -1 +++No, -1 +++so -1 +++rethrow -1 +++original -1 ++++ -1 +++} -1 return -1 joinedArray; -1 } -1 -2
public -1 static -1 boolean -1 isEmpty(boolean[] -1 array) -1 { -1 } -1 else -1 if -1 (element -1 != -1 null) -1 { -1 type -1 = -1 element.getClass(); -1 } -1 else -1 { -1 ---- -1 ---type -1 ---= -1 ---Object.class; -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Arguments -1 +++cannot -1 +++both -1 +++be -1 +++null"); -1 } -1 @SuppressWarnings("unchecked") -1 // -1 type -1 must -1 be -1 T -1 T[] -1 newArray -1 = -1 (T[]) -1 copyArrayGrow1(array, -1 type); -1 @@ -1 -3571,7 -1 +3571,7 -1 @@ -1 private -1 static -1 Object -1 copyArrayGrow1(Object -1 array, -1 Class<?> -1 newArrayComponentTyp -1 } -1 else -1 if -1 (element -1 != -1 null) -1 { -1 clss -1 = -1 element.getClass(); -1 } -1 else -1 { -1 ---- -1 ---return -1 ---(T[]) -1 ---new -1 ---Object[] -1 ---{ -1 ---null -1 ---}; -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Array -1 +++and -1 +++element -1 +++cannot -1 +++both -1 +++be -1 +++null"); -1 } -1 @SuppressWarnings("unchecked") -1 // -1 the -1 add -1 method -1 creates -1 an -1 array -1 of -1 type -1 clss, -1 which -1 is -1 type -1 T -1 final -1 T[] -1 newArray -1 = -1 (T[]) -1 add(array, -1 index, -1 element, -1 clss); -1 -2
public -1 StringBuffer -1 format(Date -1 date, -1 StringBuffer -1 buf) -1 { -1 */ -1 public -1 StringBuffer -1 format(Calendar -1 calendar, -1 StringBuffer -1 buf) -1 { -1 if -1 (mTimeZoneForced) -1 { -1 ++++ -1 +++calendar.getTime(); -1 +++/// -1 +++LANG-538 -1 calendar -1 = -1 (Calendar) -1 calendar.clone(); -1 calendar.setTimeZone(mTimeZone); -1 } -1 -2
public -1 String -1 escape(String -1 str) -1 { -1 public -1 void -1 escape(Writer -1 writer, -1 String -1 str) -1 throws -1 IOException -1 { -1 int -1 len -1 = -1 str.length(); -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 len; -1 i++) -1 { -1 ---- -1 ---char -1 ---c -1 ---= -1 ---str.charAt(i); -1 ++++ -1 +++int -1 +++c -1 +++= -1 +++Character.codePointAt(str, -1 +++i); -1 String -1 entityName -1 = -1 this.entityName(c); -1 if -1 (entityName -1 == -1 null) -1 { -1 ---- -1 ---if -1 ---(c -1 ---> -1 ---0x7F) -1 ---{ -1 ++++ -1 +++if -1 +++(c -1 +++>= -1 +++0x010000 -1 +++&& -1 +++i -1 +++< -1 +++len -1 +++- -1 +++1) -1 +++{ -1 ++++ -1 +++writer.write("&#"); -1 ++++ -1 +++writer.write(Integer.toString(c, -1 +++10)); -1 ++++ -1 +++writer.write(';'); -1 ++++ -1 +++i++; -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(c -1 +++> -1 +++0x7F) -1 +++{ -1 writer.write("&#"); -1 writer.write(Integer.toString(c, -1 10)); -1 writer.write(';'); -1 -2
private -1 StringBuffer -1 appendQuotedString(String -1 pattern, -1 ParsePosition -1 pos, -1 int -1 start -1 = -1 pos.getIndex(); -1 char[] -1 c -1 = -1 pattern.toCharArray(); -1 if -1 (escapingOn -1 && -1 c[start] -1 == -1 QUOTE) -1 { -1 ++++ -1 +++next(pos); -1 return -1 appendTo -1 == -1 null -1 ? -1 null -1 : -1 appendTo.append(QUOTE); -1 } -1 int -1 lastHold -1 = -1 start; -1 -2
public -1 static -1 Number -1 createNumber(String -1 str) -1 throws -1 NumberFormatException -1 { -1 } -1 dec -1 = -1 null; -1 } -1 ---- -1 ---if -1 ---(!Character.isDigit(lastChar)) -1 ---{ -1 ++++ -1 +++if -1 +++(!Character.isDigit(lastChar) -1 +++&& -1 +++lastChar -1 +++!= -1 +++'.') -1 +++{ -1 if -1 (expPos -1 > -1 -1 -1 && -1 expPos -1 < -1 str.length() -1 - -1 1) -1 { -1 exp -1 = -1 str.substring(expPos -1 + -1 1, -1 str.length() -1 - -1 1); -1 } -1 else -1 { -1 @@ -1 -1385,6 -1 +1385,14 -1 @@ -1 public -1 static -1 boolean -1 isNumber(String -1 str) -1 { -1 // -1 can't -1 have -1 an -1 E -1 at -1 the -1 last -1 byte -1 return -1 false; -1 } -1 ++++ -1 +++if -1 +++(chars[i] -1 +++== -1 +++'.') -1 +++{ -1 ++++ -1 +++if -1 +++(hasDecPoint -1 +++|| -1 +++hasExp) -1 +++{ -1 ++++ -1 +++// -1 +++two -1 +++decimal -1 +++points -1 +++or -1 +++dec -1 +++in -1 +++exponent -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++// -1 +++single -1 +++trailing -1 +++decimal -1 +++point -1 +++after -1 +++non-exponent -1 +++is -1 +++ok -1 ++++ -1 +++return -1 +++foundDigit; -1 ++++ -1 +++} -1 if -1 (!allowSigns -1 && -1 (chars[i] -1 == -1 'd' -1 || -1 chars[i] -1 == -1 'D' -1 -2
private -1 static -1 String -1 replaceEach(String -1 text, -1 String[] -1 searchList, -1 String[] -1 rep -1 // -1 count -1 the -1 replacement -1 text -1 elements -1 that -1 are -1 larger -1 than -1 their -1 corresponding -1 text -1 being -1 replaced -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 searchList.length; -1 i++) -1 { -1 ++++ -1 +++if -1 +++(searchList[i] -1 +++== -1 +++null -1 +++|| -1 +++replacementList[i] -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++continue; -1 ++++ -1 +++} -1 int -1 greater -1 = -1 replacementList[i].length() -1 - -1 searchList[i].length(); -1 if -1 (greater -1 > -1 0) -1 { -1 increase -1 += -1 3 -1 * -1 greater; -1 // -1 assume -1 3 -1 matches -1 -2
public -1 static -1 String -1 getShortClassName(String -1 className) -1 { -1 return -1 StringUtils.EMPTY; -1 } -1 ++++ -1 +++StringBuffer -1 +++arrayPrefix -1 +++= -1 +++new -1 +++StringBuffer(); -1 // -1 Handle -1 array -1 encoding -1 ++++ -1 +++if -1 +++(className.startsWith("[")) -1 +++{ -1 ++++ -1 +++while -1 +++(className.charAt(0) -1 +++== -1 +++'[') -1 +++{ -1 ++++ -1 +++className -1 +++= -1 +++className.substring(1); -1 ++++ -1 +++arrayPrefix.append("[]"); -1 ++++ -1 +++} -1 // -1 Strip -1 Object -1 type -1 encoding -1 ++++ -1 +++if -1 +++(className.charAt(0) -1 +++== -1 +++'L' -1 +++&& -1 +++className.charAt(className.length() -1 +++- -1 +++1) -1 +++== -1 +++';') -1 +++{ -1 ++++ -1 +++className -1 +++= -1 +++className.substring(1, -1 +++className.length() -1 +++- -1 +++1); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(reverseAbbreviationMap.containsKey(className)) -1 +++{ -1 ++++ -1 +++className -1 +++= -1 +++reverseAbbreviationMap.get(className); -1 ++++ -1 +++} -1 int -1 lastDotIdx -1 = -1 className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); -1 int -1 innerIdx -1 = -1 className.indexOf( -1 @@ -1 -200,7 -1 +213,7 -1 @@ -1 public -1 static -1 String -1 getShortClassName(String -1 className) -1 { -1 if -1 (innerIdx -1 != -1 -1) -1 { -1 out -1 = -1 out.replace(INNER_CLASS_SEPARATOR_CHAR, -1 PACKAGE_SEPARATOR_CHAR); -1 } -1 ---- -1 ---return -1 ---out; -1 ++++ -1 +++return -1 +++out -1 ++++ -1 +++arrayPrefix; -1 } -1 // -1 Package -1 name -1 @@ -1 -242,12 -1 +255,18 -1 @@ -1 public -1 static -1 String -1 getPackageName(Class<?> -1 cls) -1 { -1 * -1 @return -1 the -1 package -1 name -1 or -1 an -1 empty -1 string -1 */ -1 public -1 static -1 String -1 getPackageName(String -1 className) -1 { -1 ---- -1 ---if -1 ---(className -1 ---== -1 ---null) -1 ---{ -1 ++++ -1 +++if -1 +++(className -1 +++== -1 +++null -1 +++|| -1 +++className.length() -1 +++== -1 +++0) -1 +++{ -1 return -1 StringUtils.EMPTY; -1 } -1 // -1 Strip -1 array -1 encoding -1 ++++ -1 +++while -1 +++(className.charAt(0) -1 +++== -1 +++'[') -1 +++{ -1 ++++ -1 +++className -1 +++= -1 +++className.substring(1); -1 ++++ -1 +++} -1 // -1 Strip -1 Object -1 type -1 encoding -1 ++++ -1 +++if -1 +++(className.charAt(0) -1 +++== -1 +++'L' -1 +++&& -1 +++className.charAt(className.length() -1 +++- -1 +++1) -1 +++== -1 +++';') -1 +++{ -1 ++++ -1 +++className -1 +++= -1 +++className.substring(1); -1 ++++ -1 +++} -1 int -1 i -1 = -1 className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); -1 if -1 (i -1 == -1 -1) -1 { -1 -2
public -1 static -1 boolean -1 containsIgnoreCase(String -1 str, -1 String -1 searchStr) -1 { -1 if -1 (str -1 == -1 null -1 || -1 searchStr -1 == -1 null) -1 { -1 return -1 false; -1 } -1 ---- -1 ---return -1 ---contains(str.toUpperCase(), -1 ---searchStr.toUpperCase()); -1 ++++ -1 +++int -1 +++len -1 +++= -1 +++searchStr.length(); -1 ++++ -1 +++int -1 +++max -1 +++= -1 +++str.length() -1 +++- -1 +++len; -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++<= -1 +++max; -1 +++i++) -1 +++{ -1 ++++ -1 +++if -1 +++(str.regionMatches(true, -1 +++i, -1 +++searchStr, -1 +++0, -1 +++len)) -1 +++{ -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++false; -1 } -1 // -1 IndexOfAny -1 chars -1 -2
public -1 static -1 Number -1 createNumber(String -1 val) -1 throws -1 NumberFormatException -1 { -1 if -1 (val.length() -1 == -1 0) -1 { -1 throw -1 new -1 NumberFormatException("\"\" -1 is -1 not -1 a -1 valid -1 number."); -1 } -1 ++++ -1 +++if -1 +++(val.length() -1 +++== -1 +++1 -1 +++&& -1 +++!Character.isDigit(val.charAt(0))) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++NumberFormatException(val -1 ++++ -1 +++" -1 +++is -1 +++not -1 +++a -1 +++valid -1 +++number."); -1 ++++ -1 +++} -1 if -1 (val.startsWith("--")) -1 { -1 // -1 this -1 is -1 protection -1 for -1 poorness -1 in -1 java.lang.BigDecimal. -1 // -1 it -1 accepts -1 this -1 as -1 a -1 legal -1 value, -1 but -1 it -1 does -1 not -1 appear -1 -2
public -1 static -1 String -1 abbreviate(String -1 str, -1 int -1 lower, -1 int -1 upper, -1 String -1 appendT -1 // -1 if -1 the -1 lower -1 value -1 is -1 greater -1 than -1 the -1 length -1 of -1 the -1 string, -1 // -1 set -1 to -1 the -1 length -1 of -1 the -1 string -1 ++++ -1 +++if -1 +++(lower -1 +++> -1 +++str.length()) -1 +++{ -1 ++++ -1 +++lower -1 +++= -1 +++str.length(); -1 ++++ -1 +++} -1 // -1 if -1 the -1 upper -1 value -1 is -1 -1 -1 (i.e. -1 no -1 limit) -1 or -1 is -1 greater -1 // -1 than -1 the -1 length -1 of -1 the -1 string, -1 set -1 to -1 the -1 length -1 of -1 the -1 string -1 if -1 (upper -1 == -1 -1 -1 || -1 upper -1 > -1 str.length()) -1 { -1 -2
public -1 StrBuilder -1 appendFixedWidthPadLeft(Object -1 obj, -1 int -1 width, -1 char -1 padChar) -1 { -1 if -1 (width -1 > -1 0) -1 { -1 ensureCapacity(size -1 + -1 width); -1 String -1 str -1 = -1 (obj -1 == -1 null -1 ? -1 getNullText() -1 : -1 obj.toString()); -1 ++++ -1 +++if -1 +++(str -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++str -1 +++= -1 +++""; -1 ++++ -1 +++} -1 int -1 strLen -1 = -1 str.length(); -1 if -1 (strLen -1 >= -1 width) -1 { -1 str.getChars(strLen -1 - -1 width, -1 strLen, -1 buffer, -1 size); -1 @@ -1 -1227,6 -1 +1230,9 -1 @@ -1 public -1 StrBuilder -1 appendFixedWidthPadRight(Object -1 obj, -1 int -1 width, -1 char -1 padChar) -1 if -1 (width -1 > -1 0) -1 { -1 ensureCapacity(size -1 + -1 width); -1 String -1 str -1 = -1 (obj -1 == -1 null -1 ? -1 getNullText() -1 : -1 obj.toString()); -1 ++++ -1 +++if -1 +++(str -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++str -1 +++= -1 +++""; -1 ++++ -1 +++} -1 int -1 strLen -1 = -1 str.length(); -1 if -1 (strLen -1 >= -1 width) -1 { -1 str.getChars(0, -1 width, -1 buffer, -1 size); -1 -2
public -1 EqualsBuilder -1 append(Object -1 lhs, -1 Object -1 rhs) -1 { -1 } -1 Class -1 lhsClass -1 = -1 lhs.getClass(); -1 if -1 (!lhsClass.isArray()) -1 { -1 ++++ -1 +++if -1 +++(lhs -1 +++instanceof -1 +++java.math.BigDecimal) -1 +++{ -1 ++++ -1 +++isEquals -1 +++= -1 +++(((java.math.BigDecimal)lhs).compareTo(rhs) -1 +++== -1 +++0); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 // -1 The -1 simple -1 case, -1 not -1 an -1 array, -1 just -1 test -1 the -1 element -1 isEquals -1 = -1 lhs.equals(rhs); -1 ++++ -1 +++} -1 } -1 else -1 if -1 (lhs.getClass() -1 != -1 rhs.getClass()) -1 { -1 // -1 Here -1 when -1 we -1 compare -1 different -1 dimensions, -1 for -1 example: -1 a -1 boolean[][] -1 to -1 a -1 boolean[] -1 this.setEquals(false); -1 -2
private -1 static -1 void -1 escapeJavaStyleString(Writer -1 out, -1 String -1 str, -1 boolean -1 escape -1 out.write('\\'); -1 out.write('\\'); -1 break; -1 ++++ -1 +++case -1 +++'/': -1 ++++ -1 +++out.write('\\'); -1 ++++ -1 +++out.write('/'); -1 ++++ -1 +++break; -1 default -1 : -1 out.write(ch); -1 break; -1 -2
private -1 static -1 void -1 modify(Calendar -1 val, -1 int -1 field, -1 boolean -1 round) -1 { -1 int -1 millisecs -1 = -1 val.get(Calendar.MILLISECOND); -1 if -1 (!round -1 || -1 millisecs -1 < -1 500) -1 { -1 time -1 = -1 time -1 - -1 millisecs; -1 ++++ -1 +++} -1 if -1 (field -1 == -1 Calendar.SECOND) -1 { -1 done -1 = -1 true; -1 ---- -1 ---} -1 } -1 // -1 truncate -1 seconds -1 int -1 seconds -1 = -1 val.get(Calendar.SECOND); -1 if -1 (!done -1 && -1 (!round -1 || -1 seconds -1 < -1 30)) -1 { -1 time -1 = -1 time -1 - -1 (seconds -1 * -1 1000L); -1 ++++ -1 +++} -1 if -1 (field -1 == -1 Calendar.MINUTE) -1 { -1 done -1 = -1 true; -1 ---- -1 ---} -1 } -1 // -1 truncate -1 minutes -1 -2
public -1 StringEscapeUtils() -1 { -1 * -1 @return -1 String -1 with -1 escaped -1 values, -1 <code>null</code> -1 if -1 null -1 string -1 input -1 */ -1 public -1 static -1 String -1 escapeJava(String -1 str) -1 { -1 ---- -1 ---return -1 ---escapeJavaStyleString(str, -1 ---false); -1 ++++ -1 +++return -1 +++escapeJavaStyleString(str, -1 +++false, -1 +++false); -1 } -1 /** -1 @@ -1 -99,7 -1 +99,7 -1 @@ -1 public -1 static -1 String -1 escapeJava(String -1 str) -1 { -1 * -1 @throws -1 IOException -1 if -1 error -1 occurs -1 on -1 underlying -1 Writer -1 */ -1 public -1 static -1 void -1 escapeJava(Writer -1 out, -1 String -1 str) -1 throws -1 IOException -1 { -1 ---- -1 ---escapeJavaStyleString(out, -1 ---str, -1 ---false); -1 ++++ -1 +++escapeJavaStyleString(out, -1 +++str, -1 +++false, -1 +++false); -1 } -1 /** -1 @@ -1 -124,7 -1 +124,7 -1 @@ -1 public -1 static -1 void -1 escapeJava(Writer -1 out, -1 String -1 str) -1 throws -1 IOException -1 { -1 * -1 @return -1 String -1 with -1 escaped -1 values, -1 <code>null</code> -1 if -1 null -1 string -1 input -1 */ -1 public -1 static -1 String -1 escapeJavaScript(String -1 str) -1 { -1 ---- -1 ---return -1 ---escapeJavaStyleString(str, -1 ---true); -1 ++++ -1 +++return -1 +++escapeJavaStyleString(str, -1 +++true, -1 +++true); -1 } -1 /** -1 @@ -1 -140,7 -1 +140,7 -1 @@ -1 public -1 static -1 String -1 escapeJavaScript(String -1 str) -1 { -1 * -1 @throws -1 IOException -1 if -1 error -1 occurs -1 on -1 underlying -1 Writer -1 **/ -1 public -1 static -1 void -1 escapeJavaScript(Writer -1 out, -1 String -1 str) -1 throws -1 IOException -1 { -1 ---- -1 ---escapeJavaStyleString(out, -1 ---str, -1 ---true); -1 ++++ -1 +++escapeJavaStyleString(out, -1 +++str, -1 +++true, -1 +++true); -1 } -1 /** -1 @@ -1 -151,13 -1 +151,13 -1 @@ -1 public -1 static -1 void -1 escapeJavaScript(Writer -1 out, -1 String -1 str) -1 throws -1 IOException -1 { -1 * -1 @param -1 escapeForwardSlash -1 TODO -1 * -1 @return -1 the -1 escaped -1 string -1 */ -1 ---- -1 ---private -1 ---static -1 ---String -1 ---escapeJavaStyleString(String -1 ---str, -1 ---boolean -1 ---escapeSingleQuotes) -1 ---{ -1 ++++ -1 +++private -1 +++static -1 +++String -1 +++escapeJavaStyleString(String -1 +++str, -1 +++boolean -1 +++escapeSingleQuotes, -1 +++boolean -1 +++escapeForwardSlash) -1 +++{ -1 if -1 (str -1 == -1 null) -1 { -1 return -1 null; -1 } -1 try -1 { -1 StringWriter -1 writer -1 = -1 new -1 StringWriter(str.length() -1 * -1 2); -1 ---- -1 ---escapeJavaStyleString(writer, -1 ---str, -1 ---escapeSingleQuotes); -1 ++++ -1 +++escapeJavaStyleString(writer, -1 +++str, -1 +++escapeSingleQuotes, -1 +++escapeForwardSlash); -1 return -1 writer.toString(); -1 } -1 catch -1 (IOException -1 ioe) -1 { -1 // -1 this -1 should -1 never -1 ever -1 happen -1 while -1 writing -1 to -1 a -1 StringWriter -1 @@ -1 -175,7 -1 +175,8 -1 @@ -1 private -1 static -1 String -1 escapeJavaStyleString(String -1 str, -1 boolean -1 escapeSingleQuot -1 * -1 @param -1 escapeForwardSlash -1 TODO -1 * -1 @throws -1 IOException -1 if -1 an -1 IOException -1 occurs -1 */ -1 ---- -1 ---private -1 ---static -1 ---void -1 ---escapeJavaStyleString(Writer -1 ---out, -1 ---String -1 ---str, -1 ---boolean -1 ---escapeSingleQuote) -1 ---throws -1 ---IOException -1 ---{ -1 ++++ -1 +++private -1 +++static -1 +++void -1 +++escapeJavaStyleString(Writer -1 +++out, -1 +++String -1 +++str, -1 +++boolean -1 +++escapeSingleQuote, -1 ++++ -1 +++boolean -1 +++escapeForwardSlash) -1 +++throws -1 +++IOException -1 +++{ -1 if -1 (out -1 == -1 null) -1 { -1 throw -1 new -1 IllegalArgumentException("The -1 Writer -1 must -1 not -1 be -1 null"); -1 } -1 @@ -1 -241,7 -1 +242,9 -1 @@ -1 private -1 static -1 void -1 escapeJavaStyleString(Writer -1 out, -1 String -1 str, -1 boolean -1 escape -1 out.write('\\'); -1 break; -1 case -1 '/' -1 : -1 ++++ -1 +++if -1 +++(escapeForwardSlash) -1 +++{ -1 out.write('\\'); -1 ++++ -1 +++} -1 out.write('/'); -1 break; -1 default -1 : -1 -2
public -1 static -1 synchronized -1 FastDateFormat -1 getDateInstance(int -1 style, -1 TimeZone -1 ti -1 key -1 = -1 new -1 Pair(key, -1 timeZone); -1 } -1 ---- -1 ---if -1 ---(locale -1 ---!= -1 ---null) -1 ---{ -1 ---- -1 ---key -1 ---= -1 ---new -1 ---Pair(key, -1 ---locale); -1 ++++ -1 +++if -1 +++(locale -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++locale -1 +++= -1 +++Locale.getDefault(); -1 } -1 ++++ -1 +++key -1 +++= -1 +++new -1 +++Pair(key, -1 +++locale); -1 FastDateFormat -1 format -1 = -1 (FastDateFormat) -1 cDateInstanceCache.get(key); -1 if -1 (format -1 == -1 null) -1 { -1 ---- -1 ---if -1 ---(locale -1 ---== -1 ---null) -1 ---{ -1 ---- -1 ---locale -1 ---= -1 ---Locale.getDefault(); -1 ---- -1 ---} -1 try -1 { -1 SimpleDateFormat -1 formatter -1 = -1 (SimpleDateFormat) -1 DateFormat.getDateInstance(style, -1 locale); -1 String -1 pattern -1 = -1 formatter.toPattern(); -1 @@ -1 -462,15 -1 +460,13 -1 @@ -1 public -1 static -1 synchronized -1 FastDateFormat -1 getDateTimeInstance(int -1 dateStyle, -1 int -1 if -1 (timeZone -1 != -1 null) -1 { -1 key -1 = -1 new -1 Pair(key, -1 timeZone); -1 } -1 ---- -1 ---if -1 ---(locale -1 ---!= -1 ---null) -1 ---{ -1 ---- -1 ---key -1 ---= -1 ---new -1 ---Pair(key, -1 ---locale); -1 ++++ -1 +++if -1 +++(locale -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++locale -1 +++= -1 +++Locale.getDefault(); -1 } -1 ++++ -1 +++key -1 +++= -1 +++new -1 +++Pair(key, -1 +++locale); -1 FastDateFormat -1 format -1 = -1 (FastDateFormat) -1 cDateTimeInstanceCache.get(key); -1 if -1 (format -1 == -1 null) -1 { -1 ---- -1 ---if -1 ---(locale -1 ---== -1 ---null) -1 ---{ -1 ---- -1 ---locale -1 ---= -1 ---Locale.getDefault(); -1 ---- -1 ---} -1 try -1 { -1 SimpleDateFormat -1 formatter -1 = -1 (SimpleDateFormat) -1 DateFormat.getDateTimeInstance(dateStyle, -1 timeStyle, -1 locale); -1 -2
public -1 static -1 boolean -1 toBoolean(String -1 str) -1 { -1 (str.charAt(1) -1 == -1 'E' -1 || -1 str.charAt(1) -1 == -1 'e') -1 && -1 (str.charAt(2) -1 == -1 'S' -1 || -1 str.charAt(2) -1 == -1 's'); -1 } -1 ++++ -1 +++return -1 +++false; -1 } -1 case -1 4: -1 { -1 char -1 ch -1 = -1 str.charAt(0); -1 -2
public -1 double -1 doubleValue() -1 { -1 * -1 @return -1 a -1 new -1 reduced -1 fraction -1 instance, -1 or -1 this -1 if -1 no -1 simplification -1 possible -1 */ -1 public -1 Fraction -1 reduce() -1 { -1 ++++ -1 +++if -1 +++(numerator -1 +++== -1 +++0) -1 +++{ -1 ++++ -1 +++return -1 +++equals(ZERO) -1 +++? -1 +++this -1 +++: -1 +++ZERO; -1 ++++ -1 +++} -1 int -1 gcd -1 = -1 greatestCommonDivisor(Math.abs(numerator), -1 denominator); -1 if -1 (gcd -1 == -1 1) -1 { -1 return -1 this; -1 -2
public -1 static -1 Locale -1 toLocale(String -1 str) -1 { -1 throw -1 new -1 IllegalArgumentException("Invalid -1 locale -1 format: -1 " -1 + -1 str); -1 } -1 char -1 ch3 -1 = -1 str.charAt(3); -1 ++++ -1 +++if -1 +++(ch3 -1 +++== -1 +++'_') -1 +++{ -1 ++++ -1 +++return -1 +++new -1 +++Locale(str.substring(0, -1 +++2), -1 +++"", -1 +++str.substring(4)); -1 ++++ -1 +++} -1 char -1 ch4 -1 = -1 str.charAt(4); -1 if -1 (ch3 -1 < -1 'A' -1 || -1 ch3 -1 > -1 'Z' -1 || -1 ch4 -1 < -1 'A' -1 || -1 ch4 -1 > -1 'Z') -1 { -1 throw -1 new -1 IllegalArgumentException("Invalid -1 locale -1 format: -1 " -1 + -1 str); -1 -2
public -1 static -1 Set -1 availableLocaleSet() -1 { -1 * -1 @return -1 true -1 if -1 the -1 locale -1 is -1 a -1 known -1 locale -1 */ -1 public -1 static -1 boolean -1 isAvailableLocale(Locale -1 locale) -1 { -1 ---- -1 ---return -1 ---cAvailableLocaleSet.contains(locale); -1 ++++ -1 +++return -1 +++availableLocaleList().contains(locale); -1 } -1 //----------------------------------------------------------------------- -1 -2
public -1 static -1 Number -1 createNumber(String -1 str) -1 throws -1 NumberFormatException -1 { -1 case -1 'L' -1 : -1 if -1 (dec -1 == -1 null -1 && -1 exp -1 == -1 null -1 ---- -1 ---&& -1 ---isDigits(numeric.substring(1)) -1 ---- -1 ---&& -1 ---(numeric.charAt(0) -1 ---== -1 ---'-' -1 ---|| -1 ---Character.isDigit(numeric.charAt(0)))) -1 ---{ -1 ++++ -1 +++&& -1 +++(numeric.charAt(0) -1 +++== -1 +++'-' -1 +++&& -1 +++isDigits(numeric.substring(1)) -1 +++|| -1 +++isDigits(numeric))) -1 +++{ -1 try -1 { -1 return -1 createLong(numeric); -1 } -1 catch -1 (NumberFormatException -1 nfe) -1 { -1 -2
/* -1 * -1 Licensed -1 to -1 the -1 Apache -1 Software -1 Foundation -1 (ASF) -1 under -1 one -1 or -1 more -1 * -1 contributor -1 license -1 agreements. -1 See -1 the -1 NOTICE -1 file -1 distributed -1 with -1 * -1 this -1 work -1 for -1 additional -1 information -1 regarding -1 copyright -1 ownership. -1 * -1 The -1 ASF -1 licenses -1 this -1 file -1 to -1 You -1 under -1 the -1 Apache -1 License, -1 Version -1 2.0 -1 * -1 (the -1 "License"); -1 you -1 may -1 not -1 use -1 this -1 file -1 except -1 in -1 compliance -1 with -1 * -1 the -1 License. -1 You -1 may -1 obtain -1 a -1 copy -1 of -1 the -1 License -1 at -1 * -1 * -1 http://www.apache.org/licenses/LICENSE-2.0 -1 * -1 * -1 Unless -1 required -1 by -1 applicable -1 law -1 or -1 agreed -1 to -1 in -1 writing, -1 software -1 * -1 distributed -1 under -1 the -1 License -1 is -1 distributed -1 on -1 an -1 "AS -1 IS" -1 BASIS, -1 * -1 WITHOUT -1 WARRANTIES -1 OR -1 CONDITIONS -1 OF -1 ANY -1 KIND, -1 either -1 express -1 or -1 implied. -1 * -1 See -1 the -1 License -1 for -1 the -1 specific -1 language -1 governing -1 permissions -1 and -1 * -1 limitations -1 under -1 the -1 License. -1 */ -1 package -1 org.apache.commons.lang.time; -1 import -1 java.io.IOException; -1 import -1 java.io.ObjectInputStream; -1 import -1 java.text.DateFormat; -1 import -1 java.text.DateFormatSymbols; -1 import -1 java.text.FieldPosition; -1 import -1 java.text.Format; -1 import -1 java.text.ParsePosition; -1 import -1 java.text.SimpleDateFormat; -1 import -1 java.util.ArrayList; -1 import -1 java.util.Calendar; -1 import -1 java.util.Date; -1 import -1 java.util.GregorianCalendar; -1 import -1 java.util.HashMap; -1 import -1 java.util.List; -1 import -1 java.util.Locale; -1 import -1 java.util.Map; -1 import -1 java.util.TimeZone; -1 import -1 org.apache.commons.lang.Validate; -1 /** -1 * -1 <p>FastDateFormat -1 is -1 a -1 fast -1 and -1 thread-safe -1 version -1 of -1 * -1 {@link -1 java.text.SimpleDateFormat}.</p> -1 * -1 * -1 <p>This -1 class -1 can -1 be -1 used -1 as -1 a -1 direct -1 replacement -1 to -1 * -1 <code>SimpleDateFormat</code> -1 in -1 most -1 formatting -1 situations. -1 * -1 This -1 class -1 is -1 especially -1 useful -1 in -1 multi-threaded -1 server -1 environments. -1 * -1 <code>SimpleDateFormat</code> -1 is -1 not -1 thread-safe -1 in -1 any -1 JDK -1 version, -1 * -1 nor -1 will -1 it -1 be -1 as -1 Sun -1 have -1 closed -1 the -1 bug/RFE. -1 * -1 </p> -1 * -1 * -1 <p>Only -1 formatting -1 is -1 supported, -1 but -1 all -1 patterns -1 are -1 compatible -1 with -1 * -1 SimpleDateFormat -1 (except -1 time -1 zones -1 - -1 see -1 below).</p> -1 * -1 * -1 <p>Java -1 1.4 -1 introduced -1 a -1 new -1 pattern -1 letter, -1 <code>'Z'</code>, -1 to -1 represent -1 * -1 time -1 zones -1 in -1 RFC822 -1 format -1 (eg. -1 <code>+0800</code> -1 or -1 <code>-1100</code>). -1 * -1 This -1 pattern -1 letter -1 can -1 be -1 used -1 here -1 (on -1 all -1 JDK -1 versions).</p> -1 * -1 * -1 <p>In -1 addition, -1 the -1 pattern -1 <code>'ZZ'</code> -1 has -1 been -1 made -1 to -1 represent -1 * -1 ISO8601 -1 full -1 format -1 time -1 zones -1 (eg. -1 <code>+08:00</code> -1 or -1 <code>-11:00</code>). -1 * -1 This -1 introduces -1 a -1 minor -1 incompatibility -1 with -1 Java -1 1.4, -1 but -1 at -1 a -1 gain -1 of -1 * -1 useful -1 functionality.</p> -1 * -1 * -1 @author -1 TeaTrove -1 project -1 * -1 @author -1 Brian -1 S -1 O'Neill -1 * -1 @author -1 Sean -1 Schofield -1 * -1 @author -1 Gary -1 Gregory -1 * -1 @author -1 Stephen -1 Colebourne -1 * -1 @author -1 Nikolay -1 Metchev -1 * -1 @since -1 2.0 -1 * -1 @version -1 $Id$ -1 */ -1 public -1 class -1 FastDateFormat -1 extends -1 Format -1 { -1 // -1 A -1 lot -1 of -1 the -1 speed -1 in -1 this -1 class -1 comes -1 from -1 caching, -1 but -1 some -1 comes -1 // -1 from -1 the -1 special -1 int -1 to -1 StringBuffer -1 conversion. -1 // -1 // -1 The -1 following -1 produces -1 a -1 padded -1 2 -1 digit -1 number: -1 // -1 buffer.append((char)(value -1 / -1 10 -1 + -1 '0')); -1 // -1 buffer.append((char)(value -1 % -1 10 -1 + -1 '0')); -1 // -1 // -1 Note -1 that -1 the -1 fastest -1 append -1 to -1 StringBuffer -1 is -1 a -1 single -1 char -1 (used -1 here). -1 // -1 Note -1 that -1 Integer.toString() -1 is -1 not -1 called, -1 the -1 conversion -1 is -1 simply -1 // -1 taking -1 the -1 value -1 and -1 adding -1 (mathematically) -1 the -1 ASCII -1 value -1 for -1 '0'. -1 // -1 So, -1 don't -1 change -1 this -1 code! -1 It -1 works -1 and -1 is -1 very -1 fast. -1 /** -1 * -1 Required -1 for -1 serialization -1 support. -1 * -1 * -1 @see -1 java.io.Serializable -1 */ -1 private -1 static -1 final -1 long -1 serialVersionUID -1 = -1 1L; -1 /** -1 * -1 FULL -1 locale -1 dependent -1 date -1 or -1 time -1 style. -1 */ -1 public -1 static -1 final -1 int -1 FULL -1 = -1 DateFormat.FULL; -1 /** -1 * -1 LONG -1 locale -1 dependent -1 date -1 or -1 time -1 style. -1 */ -1 public -1 static -1 final -1 int -1 LONG -1 = -1 DateFormat.LONG; -1 /** -1 * -1 MEDIUM -1 locale -1 dependent -1 date -1 or -1 time -1 style. -1 */ -1 public -1 static -1 final -1 int -1 MEDIUM -1 = -1 DateFormat.MEDIUM; -1 /** -1 * -1 SHORT -1 locale -1 dependent -1 date -1 or -1 time -1 style. -1 */ -1 public -1 static -1 final -1 int -1 SHORT -1 = -1 DateFormat.SHORT; -1 private -1 static -1 String -1 cDefaultPattern; -1 private -1 static -1 Map -1 cInstanceCache -1 = -1 new -1 HashMap(7); -1 private -1 static -1 Map -1 cDateInstanceCache -1 = -1 new -1 HashMap(7); -1 private -1 static -1 Map -1 cTimeInstanceCache -1 = -1 new -1 HashMap(7); -1 private -1 static -1 Map -1 cDateTimeInstanceCache -1 = -1 new -1 HashMap(7); -1 private -1 static -1 Map -1 cTimeZoneDisplayCache -1 = -1 new -1 HashMap(7); -1 /** -1 * -1 The -1 pattern. -1 */ -1 private -1 final -1 String -1 mPattern; -1 /** -1 * -1 The -1 time -1 zone. -1 */ -1 private -1 final -1 TimeZone -1 mTimeZone; -1 /** -1 * -1 Whether -1 the -1 time -1 zone -1 overrides -1 any -1 on -1 Calendars. -1 */ -1 private -1 final -1 boolean -1 mTimeZoneForced; -1 /** -1 * -1 The -1 locale. -1 */ -1 private -1 final -1 Locale -1 mLocale; -1 /** -1 * -1 Whether -1 the -1 locale -1 overrides -1 the -1 default. -1 */ -1 private -1 final -1 boolean -1 mLocaleForced; -1 /** -1 * -1 The -1 parsed -1 rules. -1 */ -1 ---- -1 ---private -1 ---Rule[] -1 ---mRules; -1 ++++ -1 +++private -1 +++transient -1 +++Rule[] -1 +++mRules; -1 /** -1 * -1 The -1 estimated -1 maximum -1 length. -1 */ -1 ---- -1 ---private -1 ---int -1 ---mMaxLengthEstimate; -1 ++++ -1 +++private -1 +++transient -1 +++int -1 +++mMaxLengthEstimate; -1 //----------------------------------------------------------------------- -1 /** -1 * -1 <p>Gets -1 a -1 formatter -1 instance -1 using -1 the -1 default -1 pattern -1 in -1 the -1 * -1 default -1 locale.</p> -1 * -1 * -1 @return -1 a -1 date/time -1 formatter -1 */ -1 @@ -1 -1016,37 -1 +1016,41 -1 @@ -1 public -1 int -1 hashCode() -1 { -1 public -1 String -1 toString() -1 { -1 return -1 "FastDateFormat[" -1 + -1 mPattern -1 + -1 "]"; -1 } -1 // -1 Serializing -1 //----------------------------------------------------------------------- -1 ++++ -1 +++private -1 +++void -1 +++readObject(ObjectInputStream -1 +++in) -1 +++throws -1 +++IOException, -1 +++ClassNotFoundException -1 +++{ -1 ++++ -1 +++in.defaultReadObject(); -1 ++++ -1 +++init(); -1 ++++ -1 +++} -1 // -1 Rules -1 //----------------------------------------------------------------------- -1 /** -1 * -1 <p>Inner -1 class -1 defining -1 a -1 rule.</p> -1 */ -1 private -1 interface -1 Rule -1 { -1 /** -1 * -1 Returns -1 the -1 estimated -1 lentgh -1 of -1 the -1 result. -1 * -1 * -1 @return -1 the -1 estimated -1 length -1 */ -1 int -1 estimateLength(); -1 /** -1 * -1 Appends -1 the -1 value -1 of -1 the -1 specified -1 calendar -1 to -1 the -1 output -1 buffer -1 based -1 on -1 the -1 rule -1 implementation. -1 * -1 * -1 @param -1 buffer -1 the -1 output -1 buffer -1 * -1 @param -1 calendar -1 calendar -1 to -1 be -1 appended -1 */ -1 void -1 appendTo(StringBuffer -1 buffer, -1 Calendar -1 calendar); -1 } -1 /** -1 * -1 <p>Inner -1 class -1 defining -1 a -1 numeric -1 rule.</p> -1 */ -1 private -1 interface -1 NumberRule -1 extends -1 Rule -1 { -1 /** -1 * -1 Appends -1 the -1 specified -1 value -1 to -1 the -1 output -1 buffer -1 based -1 on -1 the -1 rule -1 implementation. -1 * -1 * -1 @param -1 buffer -1 the -1 output -1 buffer -1 -2
public -1 final -1 int -1 getValue() -1 { -1 * -1 @throws -1 NullPointerException -1 if -1 other -1 is -1 <code>null</code> -1 */ -1 public -1 int -1 compareTo(Object -1 other) -1 { -1 ++++ -1 +++if -1 +++(other -1 +++== -1 +++this) -1 +++{ -1 ++++ -1 +++return -1 +++0; -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(other.getClass() -1 +++!= -1 +++this.getClass()) -1 +++{ -1 ++++ -1 +++if -1 +++(other.getClass().getName().equals(this.getClass().getName())) -1 +++{ -1 ++++ -1 +++return -1 +++iValue -1 +++- -1 +++getValueInOtherClassLoader(other); -1 ++++ -1 +++} -1 ++++ -1 +++throw -1 +++new -1 +++ClassCastException( -1 ++++ -1 +++"Different -1 +++enum -1 +++class -1 +++'" -1 ++++ -1 +++ClassUtils.getShortClassName(other.getClass()) -1 ++++ -1 +++"'"); -1 ++++ -1 +++} -1 return -1 iValue -1 - -1 ((ValuedEnum) -1 other).iValue; -1 } -1 @@ -1 -189,9 -1 +199,20 -1 @@ -1 public -1 int -1 compareTo(Object -1 other) -1 { -1 * -1 @param -1 other -1 the -1 object -1 to -1 determine -1 the -1 value -1 for -1 * -1 @return -1 the -1 value -1 */ -1 ++++ -1 +++private -1 +++int -1 +++getValueInOtherClassLoader(Object -1 +++other) -1 +++{ -1 ++++ -1 +++try -1 +++{ -1 ++++ -1 +++Method -1 +++mth -1 +++= -1 +++other.getClass().getMethod("getValue", -1 +++null); -1 ++++ -1 +++Integer -1 +++value -1 +++= -1 +++(Integer) -1 +++mth.invoke(other, -1 +++null); -1 ++++ -1 +++return -1 +++value.intValue(); -1 ++++ -1 +++} -1 +++catch -1 +++(NoSuchMethodException -1 +++e) -1 +++{ -1 // -1 ignore -1 - -1 should -1 never -1 happen -1 ++++ -1 +++} -1 +++catch -1 +++(IllegalAccessException -1 +++e) -1 +++{ -1 // -1 ignore -1 - -1 should -1 never -1 happen -1 ++++ -1 +++} -1 +++catch -1 +++(InvocationTargetException -1 +++e) -1 +++{ -1 // -1 ignore -1 - -1 should -1 never -1 happen -1 ++++ -1 +++} -1 ++++ -1 +++throw -1 +++new -1 +++IllegalStateException("This -1 +++should -1 +++not -1 +++happen"); -1 ++++ -1 +++} -1 /** -1 * -1 <p>Human -1 readable -1 description -1 of -1 this -1 <code>Enum</code> -1 item.</p> -1 -2
public -1 void -1 stop() -1 { -1 if(this.runningState -1 != -1 STATE_RUNNING -1 && -1 this.runningState -1 != -1 STATE_SUSPENDED) -1 { -1 throw -1 new -1 IllegalStateException("Stopwatch -1 is -1 not -1 running. -1 "); -1 } -1 ++++ -1 +++if(this.runningState -1 +++== -1 +++STATE_RUNNING) -1 +++{ -1 stopTime -1 = -1 System.currentTimeMillis(); -1 ++++ -1 +++} -1 this.runningState -1 = -1 STATE_STOPPED; -1 } -1 -2
public -1 StrBuilder -1 appendFixedWidthPadRight(Object -1 obj, -1 int -1 width, -1 char -1 padChar) -1 String -1 str -1 = -1 (obj -1 == -1 null -1 ? -1 getNullText() -1 : -1 obj.toString()); -1 int -1 strLen -1 = -1 str.length(); -1 if -1 (strLen -1 >= -1 width) -1 { -1 ---- -1 ---str.getChars(0, -1 ---strLen, -1 ---buffer, -1 ---size); -1 ++++ -1 +++str.getChars(0, -1 +++width, -1 +++buffer, -1 +++size); -1 } -1 else -1 { -1 int -1 padLen -1 = -1 width -1 - -1 strLen; -1 str.getChars(0, -1 strLen, -1 buffer, -1 size); -1 -2
public -1 String -1 unescape(String -1 str) -1 { -1 } -1 else -1 { -1 entityValue -1 = -1 Integer.parseInt(entityName.substring(1)); -1 } -1 ++++ -1 +++if -1 +++(entityValue -1 +++> -1 +++0xFFFF) -1 +++{ -1 ++++ -1 +++entityValue -1 +++= -1 +++-1; -1 ++++ -1 +++} -1 } -1 catch -1 (NumberFormatException -1 ex) -1 { -1 entityValue -1 = -1 -1; -1 } -1 @@ -1 -917,12 -1 +920,17 -1 @@ -1 public -1 void -1 unescape(Writer -1 writer, -1 String -1 string) -1 throws -1 IOException -1 { -1 case -1 'X' -1 : -1 case -1 'x' -1 : -1 { -1 entityValue -1 = -1 Integer.parseInt(entityContent.substring(2), -1 16); -1 ++++ -1 +++break; -1 } -1 default -1 : -1 { -1 entityValue -1 = -1 Integer.parseInt(entityContent.substring(1), -1 10); -1 } -1 } -1 ++++ -1 +++if -1 +++(entityValue -1 +++> -1 +++0xFFFF) -1 +++{ -1 ++++ -1 +++entityValue -1 +++= -1 +++-1; -1 ++++ -1 +++} -1 } -1 catch -1 (NumberFormatException -1 e) -1 { -1 ++++ -1 +++entityValue -1 +++= -1 +++-1; -1 } -1 } -1 } -1 else -1 { -1 //escaped -1 value -1 content -1 is -1 an -1 entity -1 name -1 -2
public -1 String -1 midString(int -1 index, -1 int -1 length) -1 { -1 */ -1 public -1 boolean -1 contains(char -1 ch) -1 { -1 char[] -1 thisBuf -1 = -1 buffer; -1 ---- -1 ---for -1 ---(int -1 ---i -1 ---= -1 ---0; -1 ---i -1 ---< -1 ---thisBuf.length; -1 ---i++) -1 ---{ -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++this.size; -1 +++i++) -1 +++{ -1 if -1 (thisBuf[i] -1 == -1 ch) -1 { -1 return -1 true; -1 } -1 @@ -1 -1727,7 -1 +1727,7 -1 @@ -1 public -1 int -1 indexOf(char -1 ch, -1 int -1 startIndex) -1 { -1 return -1 -1; -1 } -1 char[] -1 thisBuf -1 = -1 buffer; -1 ---- -1 ---for -1 ---(int -1 ---i -1 ---= -1 ---startIndex; -1 ---i -1 ---< -1 ---thisBuf.length; -1 ---i++) -1 ---{ -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++startIndex; -1 +++i -1 +++< -1 +++size; -1 +++i++) -1 +++{ -1 if -1 (thisBuf[i] -1 == -1 ch) -1 { -1 return -1 i; -1 } -1 -2
public -1 int -1 indexOf(String -1 str, -1 int -1 startIndex) -1 { -1 return -1 -1; -1 } -1 char[] -1 thisBuf -1 = -1 buffer; -1 ---- -1 ---int -1 ---len -1 ---= -1 ---thisBuf.length -1 ---- -1 ---strLen; -1 ++++ -1 +++int -1 +++len -1 +++= -1 +++size -1 +++- -1 +++strLen -1 ++++ -1 +++1; -1 outer: -1 for -1 (int -1 i -1 = -1 startIndex; -1 i -1 < -1 len; -1 i++) -1 { -1 for -1 (int -1 j -1 = -1 0; -1 j -1 < -1 strLen; -1 j++) -1 { -1 -2
public -1 static -1 String -1 formatPeriod(long -1 startMillis, -1 long -1 endMillis, -1 String -1 forma -1 days -1 -= -1 1; -1 } -1 while -1 (days -1 < -1 0) -1 { -1 ---- -1 ---days -1 ---+= -1 ---31; -1 ++++ -1 +++end.add(Calendar.MONTH, -1 +++-1); -1 ++++ -1 +++days -1 ++++= -1 +++end.getActualMaximum(Calendar.DAY_OF_MONTH); -1 //days -1 += -1 31; -1 // -1 TODO: -1 Need -1 tests -1 to -1 show -1 this -1 is -1 bad -1 and -1 the -1 new -1 code -1 is -1 good. -1 // -1 HEN: -1 It's -1 a -1 tricky -1 subject. -1 Jan -1 15th -1 to -1 March -1 10th. -1 If -1 I -1 count -1 days-first -1 it -1 is -1 // -1 1 -1 month -1 and -1 26 -1 days, -1 but -1 if -1 I -1 count -1 month-first -1 then -1 it -1 is -1 1 -1 month -1 and -1 23 -1 days. -1 // -1 Also -1 it's -1 contextual -1 - -1 if -1 asked -1 for -1 no -1 M -1 in -1 the -1 format -1 then -1 I -1 should -1 probably -1 // -1 be -1 doing -1 no -1 calculating -1 here. -1 months -1 -= -1 1; -1 ++++ -1 +++end.add(Calendar.MONTH, -1 +++1); -1 } -1 while -1 (months -1 < -1 0) -1 { -1 months -1 += -1 12; -1 years -1 -= -1 1; -1 } -1 ---- -1 ---milliseconds -1 ----= -1 ---reduceAndCorrect(start, -1 ---end, -1 ---Calendar.MILLISECOND, -1 ---milliseconds); -1 ---- -1 ---seconds -1 ----= -1 ---reduceAndCorrect(start, -1 ---end, -1 ---Calendar.SECOND, -1 ---seconds); -1 ---- -1 ---minutes -1 ----= -1 ---reduceAndCorrect(start, -1 ---end, -1 ---Calendar.MINUTE, -1 ---minutes); -1 ---- -1 ---hours -1 ----= -1 ---reduceAndCorrect(start, -1 ---end, -1 ---Calendar.HOUR_OF_DAY, -1 ---hours); -1 ---- -1 ---days -1 ----= -1 ---reduceAndCorrect(start, -1 ---end, -1 ---Calendar.DAY_OF_MONTH, -1 ---days); -1 ---- -1 ---months -1 ----= -1 ---reduceAndCorrect(start, -1 ---end, -1 ---Calendar.MONTH, -1 ---months); -1 ---- -1 ---years -1 ----= -1 ---reduceAndCorrect(start, -1 ---end, -1 ---Calendar.YEAR, -1 ---years); -1 // -1 This -1 next -1 block -1 of -1 code -1 adds -1 in -1 values -1 that -1 // -1 aren't -1 requested. -1 This -1 allows -1 the -1 user -1 to -1 ask -1 for -1 the -1 @@ -1 -429,18 -1 +424,6 -1 @@ -1 static -1 String -1 format(Token[] -1 tokens, -1 int -1 years, -1 int -1 months, -1 int -1 days, -1 int -1 hours, -1 } -1 return -1 buffer.toString(); -1 } -1 ---- -1 ---static -1 ---int -1 ---reduceAndCorrect(Calendar -1 ---start, -1 ---Calendar -1 ---end, -1 ---int -1 ---field, -1 ---int -1 ---difference) -1 ---{ -1 ---- -1 ---end.add( -1 ---field, -1 ----1 -1 ---* -1 ---difference -1 ---); -1 ---- -1 ---int -1 ---endValue -1 ---= -1 ---end.get(field); -1 ---- -1 ---int -1 ---startValue -1 ---= -1 ---start.get(field); -1 ---- -1 ---if -1 ---(endValue -1 ---< -1 ---startValue) -1 ---{ -1 ---- -1 ---int -1 ---newdiff -1 ---= -1 ---startValue -1 ---- -1 ---endValue; -1 ---- -1 ---end.add( -1 ---field, -1 ---newdiff -1 ---); -1 ---- -1 ---return -1 ---newdiff; -1 ---- -1 ---} -1 ---else -1 ---{ -1 ---- -1 ---return -1 ---0; -1 ---- -1 ---} -1 ---- -1 ---} -1 static -1 final -1 Object -1 y -1 = -1 "y"; -1 static -1 final -1 Object -1 M -1 = -1 "M"; -1 -2
private -1 static -1 void -1 modify(Calendar -1 val, -1 int -1 field, -1 boolean -1 round) -1 { -1 throw -1 new -1 ArithmeticException("Calendar -1 value -1 too -1 large -1 for -1 accurate -1 calculations"); -1 } -1 ++++ -1 +++if -1 +++(field -1 +++== -1 +++Calendar.MILLISECOND) -1 +++{ -1 ++++ -1 +++return; -1 ++++ -1 +++} -1 // -1 ----------------- -1 Fix -1 for -1 LANG-59 -1 ---------------------- -1 START -1 --------------- -1 // -1 see -1 http://issues.apache.org/jira/browse/LANG-59 -1 @@ -1 -628,14 -1 +631,39 -1 @@ -1 private -1 static -1 void -1 modify(Calendar -1 val, -1 int -1 field, -1 boolean -1 round) -1 { -1 // -1 Manually -1 truncate -1 milliseconds, -1 seconds -1 and -1 minutes, -1 rather -1 than -1 using -1 // -1 Calendar -1 methods. -1 ++++ -1 +++Date -1 +++date -1 +++= -1 +++val.getTime(); -1 ++++ -1 +++long -1 +++time -1 +++= -1 +++date.getTime(); -1 ++++ -1 +++boolean -1 +++done -1 +++= -1 +++false; -1 // -1 truncate -1 milliseconds -1 ++++ -1 +++int -1 +++millisecs -1 +++= -1 +++val.get(Calendar.MILLISECOND); -1 ++++ -1 +++if -1 +++(!round -1 +++|| -1 +++millisecs -1 +++< -1 +++500) -1 +++{ -1 ++++ -1 +++time -1 +++= -1 +++time -1 +++- -1 +++millisecs; -1 ++++ -1 +++if -1 +++(field -1 +++== -1 +++Calendar.SECOND) -1 +++{ -1 ++++ -1 +++done -1 +++= -1 +++true; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 // -1 truncate -1 seconds -1 ++++ -1 +++int -1 +++seconds -1 +++= -1 +++val.get(Calendar.SECOND); -1 ++++ -1 +++if -1 +++(!done -1 +++&& -1 +++(!round -1 +++|| -1 +++seconds -1 +++< -1 +++30)) -1 +++{ -1 ++++ -1 +++time -1 +++= -1 +++time -1 +++- -1 +++(seconds -1 +++* -1 +++1000L); -1 ++++ -1 +++if -1 +++(field -1 +++== -1 +++Calendar.MINUTE) -1 +++{ -1 ++++ -1 +++done -1 +++= -1 +++true; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 // -1 truncate -1 minutes -1 ++++ -1 +++int -1 +++minutes -1 +++= -1 +++val.get(Calendar.MINUTE); -1 ++++ -1 +++if -1 +++(!done -1 +++&& -1 +++(!round -1 +++|| -1 +++minutes -1 +++< -1 +++30)) -1 +++{ -1 ++++ -1 +++time -1 +++= -1 +++time -1 +++- -1 +++(minutes -1 +++* -1 +++60000L); -1 ++++ -1 +++} -1 // -1 reset -1 time -1 ++++ -1 +++if -1 +++(date.getTime() -1 +++!= -1 +++time) -1 +++{ -1 ++++ -1 +++date.setTime(time); -1 ++++ -1 +++val.setTime(date); -1 ++++ -1 +++} -1 // -1 ----------------- -1 Fix -1 for -1 LANG-59 -1 ----------------------- -1 END -1 ---------------- -1 boolean -1 roundUp -1 = -1 false; -1 @@ -1 -706,7 -1 +734,9 -1 @@ -1 private -1 static -1 void -1 modify(Calendar -1 val, -1 int -1 field, -1 boolean -1 round) -1 { -1 roundUp -1 = -1 offset -1 > -1 ((max -1 - -1 min) -1 / -1 2); -1 } -1 //We -1 need -1 to -1 remove -1 this -1 field -1 ++++ -1 +++if -1 +++(offset -1 +++!= -1 +++0) -1 +++{ -1 val.set(fields[i][0], -1 val.get(fields[i][0]) -1 - -1 offset); -1 ++++ -1 +++} -1 } -1 throw -1 new -1 IllegalArgumentException("The -1 field -1 " -1 + -1 field -1 + -1 " -1 is -1 not -1 supported"); -1 -2
private -1 double -1 innerCumulativeProbability(int -1 x0, -1 int -1 x1, -1 int -1 dx) -1 { -1 * -1 size -1 {@code -1 n}, -1 the -1 mean -1 is -1 {@code -1 n -1 * -1 m -1 / -1 N}. -1 */ -1 public -1 double -1 getNumericalMean() -1 { -1 ---- -1 ---return -1 ---(double) -1 ---(getSampleSize() -1 ---* -1 ---getNumberOfSuccesses()) -1 ---/ -1 ---(double) -1 ---getPopulationSize(); -1 ++++ -1 +++return -1 +++getSampleSize() -1 +++* -1 +++(getNumberOfSuccesses() -1 +++/ -1 +++(double) -1 +++getPopulationSize()); -1 } -1 /** -1 -2
private -1 BigFraction(final -1 double -1 value, -1 final -1 double -1 epsilon, -1 if -1 ((p2 -1 > -1 overflow) -1 || -1 (q2 -1 > -1 overflow)) -1 { -1 // -1 in -1 maxDenominator -1 mode, -1 if -1 the -1 last -1 fraction -1 was -1 very -1 close -1 to -1 the -1 actual -1 value -1 // -1 q2 -1 may -1 overflow -1 in -1 the -1 next -1 iteration; -1 in -1 this -1 case -1 return -1 the -1 last -1 one. -1 ++++ -1 +++if -1 +++(epsilon -1 +++== -1 +++0.0 -1 +++&& -1 +++FastMath.abs(q1) -1 +++< -1 +++maxDenominator) -1 +++{ -1 ++++ -1 +++break; -1 ++++ -1 +++} -1 throw -1 new -1 FractionConversionException(value, -1 p2, -1 q2); -1 } -1 ------ -1 ---a/src/main/java/org/apache/commons/math3/fraction/Fraction.java -1 ++++++ -1 +++b/src/main/java/org/apache/commons/math3/fraction/Fraction.java -1 @@ -1 -212,6 -1 +212,9 -1 @@ -1 private -1 Fraction(double -1 value, -1 double -1 epsilon, -1 int -1 maxDenominator, -1 int -1 maxIterat -1 if -1 ((FastMath.abs(p2) -1 > -1 overflow) -1 || -1 (FastMath.abs(q2) -1 > -1 overflow)) -1 { -1 // -1 in -1 maxDenominator -1 mode, -1 if -1 the -1 last -1 fraction -1 was -1 very -1 close -1 to -1 the -1 actual -1 value -1 // -1 q2 -1 may -1 overflow -1 in -1 the -1 next -1 iteration; -1 in -1 this -1 case -1 return -1 the -1 last -1 one. -1 ++++ -1 +++if -1 +++(epsilon -1 +++== -1 +++0.0 -1 +++&& -1 +++FastMath.abs(q1) -1 +++< -1 +++maxDenominator) -1 +++{ -1 ++++ -1 +++break; -1 ++++ -1 +++} -1 throw -1 new -1 FractionConversionException(value, -1 p2, -1 q2); -1 } -1 -2
public -1 static -1 double -1 linearCombination(final -1 double[] -1 a, -1 final -1 double[] -1 b) -1 throw -1 new -1 DimensionMismatchException(len, -1 b.length); -1 } -1 ++++ -1 +++if -1 +++(len -1 +++== -1 +++1) -1 +++{ -1 // -1 Revert -1 to -1 scalar -1 multiplication. -1 ++++ -1 +++return -1 +++a[0] -1 +++* -1 +++b[0]; -1 ++++ -1 +++} -1 final -1 double[] -1 prodHigh -1 = -1 new -1 double[len]; -1 double -1 prodLowSum -1 = -1 0; -1 -2
public -1 Complex -1 reciprocal() -1 { -1 } -1 if -1 (real -1 == -1 0.0 -1 && -1 imaginary -1 == -1 0.0) -1 { -1 ---- -1 ---return -1 ---NaN; -1 ++++ -1 +++return -1 +++INF; -1 } -1 if -1 (isInfinite) -1 { -1 -2
public -1 T -1 sample() -1 { -1 * -1 @throws -1 NotStrictlyPositiveException -1 if -1 {@code -1 sampleSize} -1 is -1 not -1 * -1 positive. -1 */ -1 ---- -1 ---public -1 ---T[] -1 ---sample(int -1 ---sampleSize) -1 ---throws -1 ---NotStrictlyPositiveException -1 ---{ -1 ++++ -1 +++public -1 +++Object[] -1 +++sample(int -1 +++sampleSize) -1 +++throws -1 +++NotStrictlyPositiveException -1 +++{ -1 if -1 (sampleSize -1 <= -1 0) -1 { -1 throw -1 new -1 NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, -1 sampleSize); -1 } -1 ---- -1 ---final -1 ---T[]out -1 ---= -1 ---(T[]) -1 ---java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), -1 ---sampleSize); -1 ++++ -1 +++final -1 +++Object[] -1 +++out -1 +++= -1 +++new -1 +++Object[sampleSize]; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 sampleSize; -1 i++) -1 { -1 out[i] -1 = -1 sample(); -1 -2
public -1 double -1 density(final -1 double[] -1 vals) -1 throws -1 DimensionMismatchException -1 { -1 throw -1 new -1 DimensionMismatchException(vals.length, -1 dim); -1 } -1 ---- -1 ---return -1 ---FastMath.pow(2 -1 ---* -1 ---FastMath.PI, -1 ----dim -1 ---/ -1 ---2) -1 ---* -1 ++++ -1 +++return -1 +++FastMath.pow(2 -1 +++* -1 +++FastMath.PI, -1 +++-0.5 -1 +++* -1 +++dim) -1 +++* -1 FastMath.pow(covarianceMatrixDeterminant, -1 -0.5) -1 * -1 getExponentTerm(vals); -1 } -1 -2
protected -1 BaseOptimizer(ConvergenceChecker<PAIR> -1 checker) -1 { -1 this.checker -1 = -1 checker; -1 evaluations -1 = -1 new -1 Incrementor(0, -1 new -1 MaxEvalCallback()); -1 ---- -1 ---iterations -1 ---= -1 ---new -1 ---Incrementor(0, -1 ---new -1 ---MaxIterCallback()); -1 ++++ -1 +++iterations -1 +++= -1 +++new -1 +++Incrementor(Integer.MAX_VALUE, -1 +++new -1 +++MaxIterCallback()); -1 } -1 /** -1 ------ -1 ---a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java -1 ++++++ -1 +++b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java -1 @@ -1 -211,16 -1 +211,15 -1 @@ -1 protected -1 PointValuePair -1 doOptimize() -1 { -1 } -1 PointValuePair -1 current -1 = -1 null; -1 ---- -1 ---int -1 ---iter -1 ---= -1 ---0; -1 int -1 maxEval -1 = -1 getMaxEvaluations(); -1 while -1 (true) -1 { -1 ---- -1 ---++iter; -1 ++++ -1 +++incrementIterationCount(); -1 final -1 double -1 objective -1 = -1 computeObjectiveValue(point); -1 PointValuePair -1 previous -1 = -1 current; -1 current -1 = -1 new -1 PointValuePair(point, -1 objective); -1 if -1 (previous -1 != -1 null) -1 { -1 ---- -1 ---if -1 ---(checker.converged(iter, -1 ---previous, -1 ---current)) -1 ---{ -1 ++++ -1 +++if -1 +++(checker.converged(getIterations(), -1 +++previous, -1 +++current)) -1 +++{ -1 // -1 We -1 have -1 found -1 an -1 optimum. -1 return -1 current; -1 } -1 @@ -1 -274,7 -1 +273,7 -1 @@ -1 protected -1 PointValuePair -1 doOptimize() -1 { -1 steepestDescent -1 = -1 newSteepestDescent; -1 // -1 Compute -1 conjugate -1 search -1 direction. -1 ---- -1 ---if -1 ---(iter -1 ---% -1 ---n -1 ---== -1 ---0 -1 ---|| -1 ++++ -1 +++if -1 +++(getIterations() -1 +++% -1 +++n -1 +++== -1 +++0 -1 +++|| -1 beta -1 < -1 0) -1 { -1 // -1 Break -1 conjugation: -1 reset -1 search -1 direction. -1 searchDirection -1 = -1 steepestDescent.clone(); -1 ------ -1 ---a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java -1 ++++++ -1 +++b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java -1 @@ -1 -385,6 -1 +385,7 -1 @@ -1 protected -1 PointValuePair -1 doOptimize() -1 { -1 generationLoop: -1 for -1 (iterations -1 = -1 1; -1 iterations -1 <= -1 maxIterations; -1 iterations++) -1 { -1 ++++ -1 +++incrementIterationCount(); -1 // -1 Generate -1 and -1 evaluate -1 lambda -1 offspring -1 final -1 RealMatrix -1 arz -1 = -1 randn1(dimension, -1 lambda); -1 ------ -1 ---a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java -1 ++++++ -1 +++b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java -1 @@ -1 -188,9 -1 +188,8 -1 @@ -1 protected -1 PointValuePair -1 doOptimize() -1 { -1 double[] -1 x -1 = -1 guess; -1 double -1 fVal -1 = -1 computeObjectiveValue(x); -1 double[] -1 x1 -1 = -1 x.clone(); -1 ---- -1 ---int -1 ---iter -1 ---= -1 ---0; -1 while -1 (true) -1 { -1 ---- -1 ---++iter; -1 ++++ -1 +++incrementIterationCount(); -1 double -1 fX -1 = -1 fVal; -1 double -1 fX2 -1 = -1 0; -1 @@ -1 -224,7 -1 +223,7 -1 @@ -1 protected -1 PointValuePair -1 doOptimize() -1 { -1 final -1 PointValuePair -1 current -1 = -1 new -1 PointValuePair(x, -1 fVal); -1 if -1 (!stop) -1 { -1 // -1 User-defined -1 stopping -1 criteria. -1 if -1 (checker -1 != -1 null) -1 { -1 ---- -1 ---stop -1 ---= -1 ---checker.converged(iter, -1 ---previous, -1 ---current); -1 ++++ -1 +++stop -1 +++= -1 +++checker.converged(getIterations(), -1 +++previous, -1 +++current); -1 } -1 } -1 if -1 (stop) -1 { -1 ------ -1 ---a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java -1 ++++++ -1 +++b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java -1 @@ -1 -155,7 -1 +155,7 -1 @@ -1 public -1 int -1 compare(final -1 PointValuePair -1 o1, -1 int -1 iteration -1 = -1 0; -1 final -1 ConvergenceChecker<PointValuePair> -1 checker -1 = -1 getConvergenceChecker(); -1 while -1 (true) -1 { -1 ---- -1 ---if -1 ---(iteration -1 ---> -1 ---0) -1 ---{ -1 ++++ -1 +++if -1 +++(getIterations() -1 +++> -1 +++0) -1 +++{ -1 boolean -1 converged -1 = -1 true; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 simplex.getSize(); -1 i++) -1 { -1 PointValuePair -1 prev -1 = -1 previous[i]; -1 @@ -1 -172,7 -1 +172,7 -1 @@ -1 public -1 int -1 compare(final -1 PointValuePair -1 o1, -1 previous -1 = -1 simplex.getPoints(); -1 simplex.iterate(evalFunc, -1 comparator); -1 ---- -1 ---++iteration; -1 ++++ -1 +++incrementIterationCount(); -1 } -1 } -1 ------ -1 ---a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java -1 ++++++ -1 +++b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java -1 @@ -1 -103,9 -1 +103,8 -1 @@ -1 public -1 PointVectorValuePair -1 doOptimize() -1 { -1 // -1 iterate -1 until -1 convergence -1 is -1 reached -1 PointVectorValuePair -1 current -1 = -1 null; -1 ---- -1 ---int -1 ---iter -1 ---= -1 ---0; -1 for -1 (boolean -1 converged -1 = -1 false; -1 !converged;) -1 { -1 ---- -1 ---++iter; -1 ++++ -1 +++incrementIterationCount(); -1 // -1 evaluate -1 the -1 objective -1 function -1 and -1 its -1 jacobian -1 PointVectorValuePair -1 previous -1 = -1 current; -1 @@ -1 -157,7 -1 +156,7 -1 @@ -1 public -1 PointVectorValuePair -1 doOptimize() -1 { -1 // -1 Check -1 convergence. -1 if -1 (previous -1 != -1 null) -1 { -1 ---- -1 ---converged -1 ---= -1 ---checker.converged(iter, -1 ---previous, -1 ---current); -1 ++++ -1 +++converged -1 +++= -1 +++checker.converged(getIterations(), -1 +++previous, -1 +++current); -1 if -1 (converged) -1 { -1 setCost(computeCost(currentResiduals)); -1 return -1 current; -1 ------ -1 ---a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java -1 ++++++ -1 +++b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java -1 @@ -1 -319,10 -1 +319,10 -1 @@ -1 protected -1 PointVectorValuePair -1 doOptimize() -1 { -1 // -1 Outer -1 loop. -1 lmPar -1 = -1 0; -1 boolean -1 firstIteration -1 = -1 true; -1 ---- -1 ---int -1 ---iter -1 ---= -1 ---0; -1 final -1 ConvergenceChecker<PointVectorValuePair> -1 checker -1 = -1 getConvergenceChecker(); -1 while -1 (true) -1 { -1 ---- -1 ---++iter; -1 ++++ -1 +++incrementIterationCount(); -1 ++++ -1 final -1 PointVectorValuePair -1 previous -1 = -1 current; -1 // -1 QR -1 decomposition -1 of -1 the -1 jacobian -1 matrix -1 @@ -1 -486,7 -1 +486,7 -1 @@ -1 protected -1 PointVectorValuePair -1 doOptimize() -1 { -1 // -1 tests -1 for -1 convergence. -1 if -1 (checker -1 != -1 null) -1 { -1 // -1 we -1 use -1 the -1 vectorial -1 convergence -1 checker -1 ---- -1 ---if -1 ---(checker.converged(iter, -1 ---previous, -1 ---current)) -1 ---{ -1 ++++ -1 +++if -1 +++(checker.converged(getIterations(), -1 +++previous, -1 +++current)) -1 +++{ -1 setCost(currentCost); -1 return -1 current; -1 } -1 -2
public -1 void -1 atan2(final -1 double[] -1 y, -1 final -1 int -1 yOffset, -1 } -1 // -1 fix -1 value -1 to -1 take -1 special -1 cases -1 (+0/+0, -1 +0/-0, -1 -0/+0, -1 -0/-0, -1 +/-infinity) -1 correctly -1 ++++ -1 +++result[resultOffset] -1 +++= -1 +++FastMath.atan2(y[yOffset], -1 +++x[xOffset]); -1 } -1 -2
public -1 int -1 compare(EventState -1 es0, -1 EventState -1 es1) -1 { -1 final -1 double[] -1 eventY -1 = -1 interpolator.getInterpolatedState().clone(); -1 // -1 advance -1 all -1 event -1 states -1 to -1 current -1 time -1 ---- -1 ---currentEvent.stepAccepted(eventT, -1 ---eventY); -1 ---- -1 ---isLastStep -1 ---= -1 ---currentEvent.stop(); -1 ++++ -1 +++for -1 +++(final -1 +++EventState -1 +++state -1 +++: -1 +++eventsStates) -1 +++{ -1 ++++ -1 +++state.stepAccepted(eventT, -1 +++eventY); -1 ++++ -1 +++isLastStep -1 +++= -1 +++isLastStep -1 +++|| -1 +++state.stop(); -1 ++++ -1 +++} -1 // -1 handle -1 the -1 first -1 part -1 of -1 the -1 step, -1 up -1 to -1 the -1 event -1 for -1 (final -1 StepHandler -1 handler -1 : -1 stepHandlers) -1 { -1 @@ -1 -354,22 -1 +356,19 -1 @@ -1 public -1 int -1 compare(EventState -1 es0, -1 EventState -1 es1) -1 { -1 if -1 (isLastStep) -1 { -1 // -1 the -1 event -1 asked -1 to -1 stop -1 integration -1 System.arraycopy(eventY, -1 0, -1 y, -1 0, -1 y.length); -1 ---- -1 ---for -1 ---(final -1 ---EventState -1 ---remaining -1 ---: -1 ---occuringEvents) -1 ---{ -1 ---- -1 ---remaining.stepAccepted(eventT, -1 ---eventY); -1 ---- -1 ---} -1 return -1 eventT; -1 } -1 ---- -1 ---boolean -1 ---needReset -1 ---= -1 ---currentEvent.reset(eventT, -1 ---eventY); -1 ++++ -1 +++boolean -1 +++needReset -1 +++= -1 +++false; -1 ++++ -1 +++for -1 +++(final -1 +++EventState -1 +++state -1 +++: -1 +++eventsStates) -1 +++{ -1 ++++ -1 +++needReset -1 +++= -1 +++needReset -1 +++|| -1 +++state.reset(eventT, -1 +++eventY); -1 ++++ -1 +++} -1 if -1 (needReset) -1 { -1 // -1 some -1 event -1 handler -1 has -1 triggered -1 changes -1 that -1 // -1 invalidate -1 the -1 derivatives, -1 we -1 need -1 to -1 recompute -1 them -1 System.arraycopy(eventY, -1 0, -1 y, -1 0, -1 y.length); -1 computeDerivatives(eventT, -1 y, -1 yDot); -1 resetOccurred -1 = -1 true; -1 ---- -1 ---for -1 ---(final -1 ---EventState -1 ---remaining -1 ---: -1 ---occuringEvents) -1 ---{ -1 ---- -1 ---remaining.stepAccepted(eventT, -1 ---eventY); -1 ---- -1 ---} -1 return -1 eventT; -1 } -1 -2
*/ -1 package -1 org.apache.commons.math3.random; -1 ++++import -1 +++java.io.Serializable; -1 import -1 org.apache.commons.math3.exception.NotStrictlyPositiveException; -1 import -1 org.apache.commons.math3.util.FastMath; -1 @@ -1 -26,8 -1 +27,10 -1 @@ -1 * -1 @since -1 2.0 -1 */ -1 public -1 abstract -1 class -1 BitsStreamGenerator -1 ---- -1 ---implements -1 ---RandomGenerator -1 ---{ -1 ++++ -1 +++implements -1 +++RandomGenerator, -1 ++++ -1 +++Serializable -1 +++{ -1 /** -1 Serializable -1 version -1 identifier -1 */ -1 ++++ -1 +++private -1 +++static -1 +++final -1 +++long -1 +++serialVersionUID -1 +++= -1 +++20130104L; -1 /** -1 Next -1 gaussian. -1 */ -1 private -1 double -1 nextGaussian; -1 -2
public -1 void -1 reset(final -1 Vector3D -1 p1, -1 final -1 Vector3D -1 p2) -1 throws -1 MathIllegalArgume -1 * -1 @return -1 a -1 new -1 instance, -1 with -1 reversed -1 direction -1 */ -1 public -1 Line -1 revert() -1 { -1 ---- -1 ---final -1 ---Line -1 ---reverted -1 ---= -1 ---new -1 ---Line(zero, -1 ---zero.subtract(direction)); -1 ++++ -1 +++final -1 +++Line -1 +++reverted -1 +++= -1 +++new -1 +++Line(this); -1 ++++ -1 +++reverted.direction -1 +++= -1 +++reverted.direction.negate(); -1 return -1 reverted; -1 } -1 -2
public -1 Vector3D -1 intersection(final -1 SubLine -1 subLine, -1 final -1 boolean -1 includeEndPoin -1 // -1 compute -1 the -1 intersection -1 on -1 infinite -1 line -1 Vector3D -1 v1D -1 = -1 line.intersection(subLine.line); -1 ++++ -1 +++if -1 +++(v1D -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++return -1 +++null; -1 ++++ -1 +++} -1 // -1 check -1 location -1 of -1 point -1 with -1 respect -1 to -1 first -1 sub-line -1 Location -1 loc1 -1 = -1 remainingRegion.checkPoint(line.toSubSpace(v1D)); -1 ------ -1 ---a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java -1 ++++++ -1 +++b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java -1 @@ -1 -115,6 -1 +115,9 -1 @@ -1 public -1 Vector2D -1 intersection(final -1 SubLine -1 subLine, -1 final -1 boolean -1 includeEndPoin -1 // -1 compute -1 the -1 intersection -1 on -1 infinite -1 line -1 Vector2D -1 v2D -1 = -1 line1.intersection(line2); -1 ++++ -1 +++if -1 +++(v2D -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++return -1 +++null; -1 ++++ -1 +++} -1 // -1 check -1 location -1 of -1 point -1 with -1 respect -1 to -1 first -1 sub-line -1 Location -1 loc1 -1 = -1 getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); -1 -2
protected -1 void -1 setUp() -1 { -1 * -1 @return -1 the -1 square-root -1 of -1 the -1 weight -1 matrix. -1 */ -1 private -1 RealMatrix -1 squareRoot(RealMatrix -1 m) -1 { -1 ++++ -1 +++if -1 +++(m -1 +++instanceof -1 +++DiagonalMatrix) -1 +++{ -1 ++++ -1 +++final -1 +++int -1 +++dim -1 +++= -1 +++m.getRowDimension(); -1 ++++ -1 +++final -1 +++RealMatrix -1 +++sqrtM -1 +++= -1 +++new -1 +++DiagonalMatrix(dim); -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++dim; -1 +++i++) -1 +++{ -1 ++++ -1 +++sqrtM.setEntry(i, -1 +++i, -1 +++FastMath.sqrt(m.getEntry(i, -1 +++i))); -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++sqrtM; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 final -1 EigenDecomposition -1 dec -1 = -1 new -1 EigenDecomposition(m); -1 return -1 dec.getSquareRoot(); -1 ++++ -1 +++} -1 } -1 } -1 -2
*/ -1 public -1 Weight(double[] -1 weight) -1 { -1 final -1 int -1 dim -1 = -1 weight.length; -1 ---- -1 ---weightMatrix -1 ---= -1 ---org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, -1 ---dim); -1 ---- -1 ---for -1 ---(int -1 ---i -1 ---= -1 ---0; -1 ---i -1 ---< -1 ---dim; -1 ---i++) -1 ---{ -1 ---- -1 ---weightMatrix.setEntry(i, -1 ---i, -1 ---weight[i]); -1 ---- -1 ---} -1 ++++ -1 +++weightMatrix -1 +++= -1 +++new -1 +++DiagonalMatrix(weight); -1 } -1 /** -1 ------ -1 ---a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java -1 ++++++ -1 +++b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java -1 @@ -1 -264,7 -1 +264,16 -1 @@ -1 private -1 void -1 parseOptimizationData(OptimizationData... -1 optData) -1 { -1 * -1 @return -1 the -1 square-root -1 of -1 the -1 weight -1 matrix. -1 */ -1 private -1 RealMatrix -1 squareRoot(RealMatrix -1 m) -1 { -1 ++++ -1 +++if -1 +++(m -1 +++instanceof -1 +++DiagonalMatrix) -1 +++{ -1 ++++ -1 +++final -1 +++int -1 +++dim -1 +++= -1 +++m.getRowDimension(); -1 ++++ -1 +++final -1 +++RealMatrix -1 +++sqrtM -1 +++= -1 +++new -1 +++DiagonalMatrix(dim); -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++dim; -1 +++i++) -1 +++{ -1 ++++ -1 +++sqrtM.setEntry(i, -1 +++i, -1 +++FastMath.sqrt(m.getEntry(i, -1 +++i))); -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++sqrtM; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 final -1 EigenDecomposition -1 dec -1 = -1 new -1 EigenDecomposition(m); -1 return -1 dec.getSquareRoot(); -1 ++++ -1 +++} -1 } -1 } -1 -2
/** -1 2^52 -1 - -1 double -1 numbers -1 this -1 large -1 must -1 be -1 integral -1 (no -1 fraction) -1 or -1 NaN -1 or -1 Infinite -1 */ -1 private -1 static -1 final -1 double -1 TWO_POWER_52 -1 = -1 4503599627370496.0; -1 /** -1 2^53 -1 - -1 double -1 numbers -1 this -1 large -1 must -1 be -1 even. -1 */ -1 ++++ -1 +++private -1 +++static -1 +++final -1 +++double -1 +++TWO_POWER_53 -1 +++= -1 +++2 -1 +++* -1 +++TWO_POWER_52; -1 /** -1 Constant: -1 {@value}. -1 */ -1 private -1 static -1 final -1 double -1 F_1_3 -1 = -1 1d -1 / -1 3d; -1 @@ -1 -1538,7 -1 +1539,7 -1 @@ -1 public -1 static -1 double -1 pow(double -1 x, -1 double -1 y) -1 { -1 /* -1 Handle -1 special -1 case -1 x<0 -1 */ -1 if -1 (x -1 < -1 0) -1 { -1 // -1 y -1 is -1 an -1 even -1 integer -1 in -1 this -1 case -1 ---- -1 ---if -1 ---(y -1 --->= -1 ---TWO_POWER_52 -1 ---|| -1 ---y -1 ---<= -1 ----TWO_POWER_52) -1 ---{ -1 ++++ -1 +++if -1 +++(y -1 +++>= -1 +++TWO_POWER_53 -1 +++|| -1 +++y -1 +++<= -1 +++-TWO_POWER_53) -1 +++{ -1 return -1 pow(-x, -1 y); -1 } -1 -2
public -1 Dfp -1 multiply(final -1 Dfp -1 x) -1 { -1 * -1 @return -1 product -1 of -1 this -1 and -1 x -1 */ -1 public -1 Dfp -1 multiply(final -1 int -1 x) -1 { -1 ++++ -1 +++if -1 +++(x -1 +++>= -1 +++0 -1 +++&& -1 +++x -1 +++< -1 +++RADIX) -1 +++{ -1 return -1 multiplyFast(x); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++return -1 +++multiply(newInstance(x)); -1 ++++ -1 +++} -1 } -1 /** -1 Multiply -1 this -1 by -1 a -1 single -1 digit -1 0&lt;=x&lt;radix. -1 -2
public -1 double -1 getSupportUpperBound() -1 { -1 /** -1 {@inheritDoc} -1 */ -1 public -1 boolean -1 isSupportLowerBoundInclusive() -1 { -1 ---- -1 ---return -1 ---true; -1 ++++ -1 +++return -1 +++false; -1 } -1 /** -1 {@inheritDoc} -1 */ -1 ------ -1 ---a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java -1 ++++++ -1 +++b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java -1 @@ -1 -181,7 -1 +181,7 -1 @@ -1 public -1 boolean -1 isSupportLowerBoundInclusive() -1 { -1 /** -1 {@inheritDoc} -1 */ -1 public -1 boolean -1 isSupportUpperBoundInclusive() -1 { -1 ---- -1 ---return -1 ---false; -1 ++++ -1 +++return -1 +++true; -1 } -1 /** -1 -2
*/ -1 public -1 class -1 FastMath -1 { -1 /** -1 StrictMath.log(Double.MAX_VALUE): -1 {@value} -1 */ -1 ++++ -1 +++private -1 +++static -1 +++final -1 +++double -1 +++LOG_MAX_VALUE -1 +++= -1 +++StrictMath.log(Double.MAX_VALUE); -1 /** -1 Archimede's -1 constant -1 PI, -1 ratio -1 of -1 circle -1 circumference -1 to -1 diameter. -1 */ -1 public -1 static -1 final -1 double -1 PI -1 = -1 105414357.0 -1 / -1 33554432.0 -1 + -1 1.984187159361080883e-9; -1 @@ -1 -391,12 -1 +392,21 -1 @@ -1 public -1 static -1 double -1 cosh(double -1 x) -1 { -1 // -1 exp(-z) -1 can -1 be -1 ignored -1 in -1 comparison -1 with -1 exp(z) -1 if -1 (x -1 > -1 20) -1 { -1 ++++ -1 +++if -1 +++(x -1 +++>= -1 +++LOG_MAX_VALUE) -1 +++{ -1 // -1 Avoid -1 overflow -1 (MATH-905). -1 ++++ -1 +++final -1 +++double -1 +++t -1 +++= -1 +++exp(0.5 -1 +++* -1 +++x); -1 ++++ -1 +++return -1 +++(0.5 -1 +++* -1 +++t) -1 +++* -1 +++t; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 return -1 0.5 -1 * -1 exp(x); -1 } -1 ---- -1 ---if -1 ---(x -1 ---< -1 ----20) -1 ---{ -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(x -1 +++< -1 +++-20) -1 +++{ -1 ++++ -1 +++if -1 +++(x -1 +++<= -1 +++-LOG_MAX_VALUE) -1 +++{ -1 // -1 Avoid -1 overflow -1 (MATH-905). -1 ++++ -1 +++final -1 +++double -1 +++t -1 +++= -1 +++exp(-0.5 -1 +++* -1 +++x); -1 ++++ -1 +++return -1 +++(0.5 -1 +++* -1 +++t) -1 +++* -1 +++t; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 return -1 0.5 -1 * -1 exp(-x); -1 ++++ -1 +++} -1 } -1 final -1 double -1 hiPrec[] -1 = -1 new -1 double[2]; -1 @@ -1 -452,12 -1 +462,21 -1 @@ -1 public -1 static -1 double -1 sinh(double -1 x) -1 { -1 // -1 exp(-z) -1 can -1 be -1 ignored -1 in -1 comparison -1 with -1 exp(z) -1 if -1 (x -1 > -1 20) -1 { -1 ++++ -1 +++if -1 +++(x -1 +++>= -1 +++LOG_MAX_VALUE) -1 +++{ -1 // -1 Avoid -1 overflow -1 (MATH-905). -1 ++++ -1 +++final -1 +++double -1 +++t -1 +++= -1 +++exp(0.5 -1 +++* -1 +++x); -1 ++++ -1 +++return -1 +++(0.5 -1 +++* -1 +++t) -1 +++* -1 +++t; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 return -1 0.5 -1 * -1 exp(x); -1 } -1 ---- -1 ---if -1 ---(x -1 ---< -1 ----20) -1 ---{ -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(x -1 +++< -1 +++-20) -1 +++{ -1 ++++ -1 +++if -1 +++(x -1 +++<= -1 +++-LOG_MAX_VALUE) -1 +++{ -1 // -1 Avoid -1 overflow -1 (MATH-905). -1 ++++ -1 +++final -1 +++double -1 +++t -1 +++= -1 +++exp(-0.5 -1 +++* -1 +++x); -1 ++++ -1 +++return -1 +++(-0.5 -1 +++* -1 +++t) -1 +++* -1 +++t; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 return -1 -0.5 -1 * -1 exp(-x); -1 ++++ -1 +++} -1 } -1 if -1 (x -1 == -1 0) -1 { -1 -2
public -1 FitnessFunction() -1 { -1 double[] -1 res -1 = -1 new -1 double[x.length]; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 x.length; -1 i++) -1 { -1 double -1 diff -1 = -1 boundaries[1][i] -1 - -1 boundaries[0][i]; -1 ---- -1 ---res[i] -1 ---= -1 ---(x[i] -1 ---- -1 ---boundaries[0][i]) -1 ---/ -1 ---diff; -1 ++++ -1 +++res[i] -1 +++= -1 +++x[i] -1 +++/ -1 +++diff; -1 } -1 return -1 res; -1 } -1 @@ -1 -955,7 -1 +955,7 -1 @@ -1 public -1 FitnessFunction() -1 { -1 double[] -1 res -1 = -1 new -1 double[x.length]; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 x.length; -1 i++) -1 { -1 double -1 diff -1 = -1 boundaries[1][i] -1 - -1 boundaries[0][i]; -1 ---- -1 ---res[i] -1 ---= -1 ---diff -1 ---* -1 ---x[i] -1 ---+ -1 ---boundaries[0][i]; -1 ++++ -1 +++res[i] -1 +++= -1 +++diff -1 +++* -1 +++x[i]; -1 } -1 return -1 res; -1 } -1 @@ -1 -987,12 -1 +987,14 -1 @@ -1 public -1 boolean -1 isFeasible(final -1 double[] -1 x) -1 { -1 return -1 true; -1 } -1 ++++ -1 +++final -1 +++double[] -1 +++bLoEnc -1 +++= -1 +++encode(boundaries[0]); -1 ++++ -1 +++final -1 +++double[] -1 +++bHiEnc -1 +++= -1 +++encode(boundaries[1]); -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 x.length; -1 i++) -1 { -1 ---- -1 ---if -1 ---(x[i] -1 ---< -1 ---0) -1 ---{ -1 ++++ -1 +++if -1 +++(x[i] -1 +++< -1 +++bLoEnc[i]) -1 +++{ -1 return -1 false; -1 } -1 ---- -1 ---if -1 ---(x[i] -1 ---> -1 ---1.0) -1 ---{ -1 ++++ -1 +++if -1 +++(x[i] -1 +++> -1 +++bHiEnc[i]) -1 +++{ -1 return -1 false; -1 } -1 } -1 -2
public -1 FitnessFunction() -1 { -1 * -1 @return -1 the -1 original -1 objective -1 variables, -1 possibly -1 repaired. -1 */ -1 public -1 double[] -1 repairAndDecode(final -1 double[] -1 x) -1 { -1 ---- -1 ---return -1 ++++ -1 +++return -1 +++boundaries -1 +++!= -1 +++null -1 +++&& -1 +++isRepairMode -1 +++? -1 ++++ -1 +++decode(repair(x)) -1 +++: -1 decode(x); -1 } -1 -2
private -1 void -1 checkParameters() -1 { -1 boundaries[1] -1 = -1 uB; -1 // -1 Abort -1 early -1 if -1 the -1 normalization -1 will -1 overflow -1 (cf. -1 "encode" -1 method). -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++lB.length; -1 +++i++) -1 +++{ -1 ++++ -1 +++if -1 +++(Double.isInfinite(boundaries[1][i] -1 +++- -1 +++boundaries[0][i])) -1 +++{ -1 ++++ -1 +++final -1 +++double -1 +++max -1 +++= -1 +++Double.MAX_VALUE -1 ++++ -1 +++boundaries[0][i]; -1 ++++ -1 +++final -1 +++NumberIsTooLargeException -1 +++e -1 ++++ -1 +++= -1 +++new -1 +++NumberIsTooLargeException(boundaries[1][i], -1 ++++ -1 +++max, -1 ++++ -1 +++true); -1 ++++ -1 +++e.getContext().addMessage(LocalizedFormats.OVERFLOW); -1 ++++ -1 +++e.getContext().addMessage(LocalizedFormats.INDEX, -1 +++i); -1 ++++ -1 ++++ -1 +++throw -1 +++e; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 } -1 } -1 else -1 { -1 // -1 Convert -1 API -1 to -1 internal -1 handling -1 of -1 boundaries. -1 -2
protected -1 UnivariatePointValuePair -1 doOptimize() -1 { -1 UnivariatePointValuePair -1 current -1 = -1 new -1 UnivariatePointValuePair(x, -1 isMinim -1 ? -1 fx -1 : -1 -fx); -1 // -1 Best -1 point -1 encountered -1 so -1 far -1 (which -1 is -1 the -1 initial -1 guess). -1 ++++ -1 +++UnivariatePointValuePair -1 +++best -1 +++= -1 +++current; -1 int -1 iter -1 = -1 0; -1 while -1 (true) -1 { -1 @@ -1 -231,10 -1 +232,15 -1 @@ -1 protected -1 UnivariatePointValuePair -1 doOptimize() -1 { -1 // -1 User-defined -1 convergence -1 checker. -1 previous -1 = -1 current; -1 current -1 = -1 new -1 UnivariatePointValuePair(u, -1 isMinim -1 ? -1 fu -1 : -1 -fu); -1 ++++ -1 +++best -1 +++= -1 +++best(best, -1 ++++ -1 +++best(current, -1 ++++ -1 +++previous, -1 ++++ -1 +++isMinim), -1 ++++ -1 +++isMinim); -1 if -1 (checker -1 != -1 null) -1 { -1 if -1 (checker.converged(iter, -1 previous, -1 current)) -1 { -1 ---- -1 ---return -1 ---best(current, -1 ---previous, -1 ---isMinim); -1 ++++ -1 +++return -1 +++best; -1 } -1 } -1 @@ -1 -271,9 -1 +277,10 -1 @@ -1 protected -1 UnivariatePointValuePair -1 doOptimize() -1 { -1 } -1 } -1 } -1 else -1 { -1 // -1 Default -1 termination -1 (Brent's -1 criterion). -1 ---- -1 ---return -1 ++++ -1 +++return -1 +++best(best, -1 best(current, -1 previous, -1 ++++ -1 +++isMinim), -1 isMinim); -1 } -1 ++iter; -1 -2
public -1 RectangularCholeskyDecomposition(RealMatrix -1 matrix, -1 double -1 small) -1 final -1 double[][] -1 c -1 = -1 matrix.getData(); -1 final -1 double[][] -1 b -1 = -1 new -1 double[order][order]; -1 ---- -1 ---int[] -1 ---swap -1 ---= -1 ---new -1 ---int[order]; -1 int[] -1 index -1 = -1 new -1 int[order]; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 order; -1 ++i) -1 { -1 index[i] -1 = -1 i; -1 @@ -1 -76,21 -1 +75,24 -1 @@ -1 public -1 RectangularCholeskyDecomposition(RealMatrix -1 matrix, -1 double -1 small) -1 for -1 (boolean -1 loop -1 = -1 true; -1 loop;) -1 { -1 // -1 find -1 maximal -1 diagonal -1 element -1 ---- -1 ---swap[r] -1 ---= -1 ---r; -1 ++++ -1 +++int -1 +++swapR -1 +++= -1 +++r; -1 for -1 (int -1 i -1 = -1 r -1 + -1 1; -1 i -1 < -1 order; -1 ++i) -1 { -1 int -1 ii -1 = -1 index[i]; -1 ---- -1 ---int -1 ---isi -1 ---= -1 ---index[swap[i]]; -1 ---- -1 ---if -1 ---(c[ii][ii] -1 ---> -1 ---c[isi][isi]) -1 ---{ -1 ---- -1 ---swap[r] -1 ---= -1 ---i; -1 ++++ -1 +++int -1 +++isr -1 +++= -1 +++index[swapR]; -1 ++++ -1 +++if -1 +++(c[ii][ii] -1 +++> -1 +++c[isr][isr]) -1 +++{ -1 ++++ -1 +++swapR -1 +++= -1 +++i; -1 } -1 } -1 // -1 swap -1 elements -1 ---- -1 ---if -1 ---(swap[r] -1 ---!= -1 ---r) -1 ---{ -1 ---- -1 ---int -1 ---tmp -1 ---= -1 ---index[r]; -1 ---- -1 ---index[r] -1 ---= -1 ---index[swap[r]]; -1 ---- -1 ---index[swap[r]] -1 ---= -1 ---tmp; -1 ++++ -1 +++if -1 +++(swapR -1 +++!= -1 +++r) -1 +++{ -1 ++++ -1 +++final -1 +++int -1 +++tmpIndex -1 +++= -1 +++index[r]; -1 ++++ -1 +++index[r] -1 +++= -1 +++index[swapR]; -1 ++++ -1 +++index[swapR] -1 +++= -1 +++tmpIndex; -1 ++++ -1 +++final -1 +++double[] -1 +++tmpRow -1 +++= -1 +++b[r]; -1 ++++ -1 +++b[r] -1 +++= -1 +++b[swapR]; -1 ++++ -1 +++b[swapR] -1 +++= -1 +++tmpRow; -1 } -1 // -1 check -1 diagonal -1 element -1 @@ -1 -121,11 -1 +123,12 -1 @@ -1 public -1 RectangularCholeskyDecomposition(RealMatrix -1 matrix, -1 double -1 small) -1 final -1 double -1 sqrt -1 = -1 FastMath.sqrt(c[ir][ir]); -1 b[r][r] -1 = -1 sqrt; -1 final -1 double -1 inverse -1 = -1 1 -1 / -1 sqrt; -1 ++++ -1 +++final -1 +++double -1 +++inverse2 -1 +++= -1 +++1 -1 +++/ -1 +++c[ir][ir]; -1 for -1 (int -1 i -1 = -1 r -1 + -1 1; -1 i -1 < -1 order; -1 ++i) -1 { -1 final -1 int -1 ii -1 = -1 index[i]; -1 final -1 double -1 e -1 = -1 inverse -1 * -1 c[ii][ir]; -1 b[i][r] -1 = -1 e; -1 ---- -1 ---c[ii][ii] -1 ----= -1 ---e -1 ---* -1 ---e; -1 ++++ -1 +++c[ii][ii] -1 +++-= -1 +++c[ii][ir] -1 +++* -1 +++c[ii][ir] -1 +++* -1 +++inverse2; -1 for -1 (int -1 j -1 = -1 r -1 + -1 1; -1 j -1 < -1 i; -1 ++j) -1 { -1 final -1 int -1 ij -1 = -1 index[j]; -1 final -1 double -1 f -1 = -1 c[ii][ij] -1 - -1 e -1 * -1 b[j][r]; -1 -2
protected -1 UnivariatePointValuePair -1 doOptimize() -1 { -1 if -1 (checker -1 != -1 null) -1 { -1 if -1 (checker.converged(iter, -1 previous, -1 current)) -1 { -1 ---- -1 ---return -1 ---current; -1 ++++ -1 +++return -1 +++best(current, -1 +++previous, -1 +++isMinim); -1 } -1 } -1 @@ -1 -264,7 -1 +264,7 -1 @@ -1 protected -1 UnivariatePointValuePair -1 doOptimize() -1 { -1 } -1 } -1 } -1 else -1 { -1 // -1 Default -1 termination -1 (Brent's -1 criterion). -1 ---- -1 ---return -1 ---current; -1 ++++ -1 +++return -1 +++best(current, -1 +++previous, -1 +++isMinim); -1 } -1 ++iter; -1 } -1 -2
private -1 double -1 calculateAsymptoticPValue(final -1 double -1 Umin, -1 final -1 int -1 n2) -1 throws -1 ConvergenceException, -1 MaxCountExceededException -1 { -1 ---- -1 ---final -1 ---int -1 ---n1n2prod -1 ---= -1 ---n1 -1 ---* -1 ---n2; -1 ++++ -1 +++final -1 +++double -1 +++n1n2prod -1 +++= -1 +++n1 -1 +++* -1 +++n2; -1 // -1 http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation -1 final -1 double -1 EU -1 = -1 n1n2prod -1 / -1 2.0; -1 -2
private -1 void -1 guessAOmega() -1 { -1 } -1 a -1 = -1 0.5 -1 * -1 (yMax -1 - -1 yMin); -1 } -1 else -1 { -1 ++++ -1 +++if -1 +++(c2 -1 +++== -1 +++0) -1 +++{ -1 // -1 In -1 some -1 ill-conditioned -1 cases -1 (cf. -1 MATH-844), -1 the -1 guesser -1 // -1 procedure -1 cannot -1 produce -1 sensible -1 results. -1 ++++ -1 +++throw -1 +++new -1 +++MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR); -1 ++++ -1 +++} -1 a -1 = -1 FastMath.sqrt(c1 -1 / -1 c2); -1 omega -1 = -1 FastMath.sqrt(c2 -1 / -1 c3); -1 -2
private -1 Fraction(double -1 value, -1 double -1 epsilon, -1 int -1 maxDenominator, -1 int -1 maxIterat -1 long -1 overflow -1 = -1 Integer.MAX_VALUE; -1 double -1 r0 -1 = -1 value; -1 long -1 a0 -1 = -1 (long)FastMath.floor(r0); -1 ---- -1 ---if -1 ---(a0 -1 ---> -1 ---overflow) -1 ---{ -1 ++++ -1 +++if -1 +++(FastMath.abs(a0) -1 +++> -1 +++overflow) -1 +++{ -1 throw -1 new -1 FractionConversionException(value, -1 a0, -1 1l); -1 } -1 @@ -1 -206,7 -1 +206,7 -1 @@ -1 private -1 Fraction(double -1 value, -1 double -1 epsilon, -1 int -1 maxDenominator, -1 int -1 maxIterat -1 long -1 a1 -1 = -1 (long)FastMath.floor(r1); -1 p2 -1 = -1 (a1 -1 * -1 p1) -1 + -1 p0; -1 q2 -1 = -1 (a1 -1 * -1 q1) -1 + -1 q0; -1 ---- -1 ---if -1 ---((p2 -1 ---> -1 ---overflow) -1 ---|| -1 ---(q2 -1 ---> -1 ---overflow)) -1 ---{ -1 ++++ -1 +++if -1 +++((FastMath.abs(p2) -1 +++> -1 +++overflow) -1 +++|| -1 +++(FastMath.abs(q2) -1 +++> -1 +++overflow)) -1 +++{ -1 throw -1 new -1 FractionConversionException(value, -1 p2, -1 q2); -1 } -1 -2
public -1 Fraction -1 divide(final -1 int -1 i) -1 { -1 * -1 @return -1 the -1 fraction -1 percentage -1 as -1 a -1 <tt>double</tt>. -1 */ -1 public -1 double -1 percentageValue() -1 { -1 ---- -1 ---return -1 ---multiply(100).doubleValue(); -1 ++++ -1 +++return -1 +++100 -1 +++* -1 +++doubleValue(); -1 } -1 /** -1 -2
public -1 OpenMapRealVector -1 ebeDivide(RealVector -1 v) -1 { -1 * -1 this -1 only. -1 Indeed, -1 if -1 this[i] -1 = -1 0d -1 and -1 v[i] -1 = -1 0d, -1 then -1 * -1 this[i] -1 / -1 v[i] -1 = -1 NaN, -1 and -1 not -1 0d. -1 */ -1 ---- -1 ---Iterator -1 ---iter -1 ---= -1 ---entries.iterator(); -1 ---- -1 ---while -1 ---(iter.hasNext()) -1 ---{ -1 ---- -1 ---iter.advance(); -1 ---- -1 ---res.setEntry(iter.key(), -1 ---iter.value() -1 ---/ -1 ---v.getEntry(iter.key())); -1 ++++ -1 +++final -1 +++int -1 +++n -1 +++= -1 +++getDimension(); -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++n; -1 +++i++) -1 +++{ -1 ++++ -1 +++res.setEntry(i, -1 +++this.getEntry(i) -1 +++/ -1 +++v.getEntry(i)); -1 } -1 return -1 res; -1 } -1 @@ -1 -371,6 -1 +370,18 -1 @@ -1 public -1 OpenMapRealVector -1 ebeMultiply(RealVector -1 v) -1 { -1 * -1 * -1 These -1 special -1 cases -1 are -1 handled -1 below. -1 */ -1 ++++ -1 +++if -1 +++(v.isNaN() -1 +++|| -1 +++v.isInfinite()) -1 +++{ -1 ++++ -1 +++final -1 +++int -1 +++n -1 +++= -1 +++getDimension(); -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++n; -1 +++i++) -1 +++{ -1 ++++ -1 +++final -1 +++double -1 +++y -1 +++= -1 +++v.getEntry(i); -1 ++++ -1 +++if -1 +++(Double.isNaN(y)) -1 +++{ -1 ++++ -1 +++res.setEntry(i, -1 +++Double.NaN); -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(Double.isInfinite(y)) -1 +++{ -1 ++++ -1 +++final -1 +++double -1 +++x -1 +++= -1 +++this.getEntry(i); -1 ++++ -1 +++res.setEntry(i, -1 +++x -1 +++* -1 +++y); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++} -1 return -1 res; -1 } -1 -2
private -1 Integer -1 getPivotRow(SimplexTableau -1 tableau, -1 final -1 int -1 col) -1 { -1 // -1 there's -1 a -1 degeneracy -1 as -1 indicated -1 by -1 a -1 tie -1 in -1 the -1 minimum -1 ratio -1 test -1 // -1 1. -1 check -1 if -1 there's -1 an -1 artificial -1 variable -1 that -1 can -1 be -1 forced -1 out -1 of -1 the -1 basis -1 ++++ -1 +++if -1 +++(tableau.getNumArtificialVariables() -1 +++> -1 +++0) -1 +++{ -1 for -1 (Integer -1 row -1 : -1 minRatioPositions) -1 { -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 tableau.getNumArtificialVariables(); -1 i++) -1 { -1 int -1 column -1 = -1 i -1 + -1 tableau.getArtificialVariableOffset(); -1 @@ -1 -125,6 -1 +126,7 -1 @@ -1 private -1 Integer -1 getPivotRow(SimplexTableau -1 tableau, -1 final -1 int -1 col) -1 { -1 } -1 } -1 } -1 ++++ -1 +++} -1 // -1 2. -1 apply -1 Bland's -1 rule -1 to -1 prevent -1 cycling: -1 // -1 take -1 the -1 row -1 for -1 which -1 the -1 corresponding -1 basic -1 variable -1 has -1 the -1 smallest -1 index -1 @@ -1 -135,6 -1 +137,7 -1 @@ -1 private -1 Integer -1 getPivotRow(SimplexTableau -1 tableau, -1 final -1 int -1 col) -1 { -1 // -1 Additional -1 heuristic: -1 if -1 we -1 did -1 not -1 get -1 a -1 solution -1 after -1 half -1 of -1 maxIterations -1 // -1 revert -1 to -1 the -1 simple -1 case -1 of -1 just -1 returning -1 the -1 top-most -1 row -1 // -1 This -1 heuristic -1 is -1 based -1 on -1 empirical -1 data -1 gathered -1 while -1 investigating -1 MATH-828. -1 ++++ -1 +++if -1 +++(getIterations() -1 +++< -1 +++getMaxIterations() -1 +++/ -1 +++2) -1 +++{ -1 Integer -1 minRow -1 = -1 null; -1 int -1 minIndex -1 = -1 tableau.getWidth(); -1 for -1 (Integer -1 row -1 : -1 minRatioPositions) -1 { -1 @@ -1 -149,6 -1 +152,7 -1 @@ -1 private -1 Integer -1 getPivotRow(SimplexTableau -1 tableau, -1 final -1 int -1 col) -1 { -1 } -1 } -1 return -1 minRow; -1 ++++ -1 +++} -1 } -1 return -1 minRatioPositions.get(0); -1 } -1 -2
public -1 double -1 evaluate(double -1 x, -1 double -1 epsilon, -1 int -1 maxIterations) -1 { -1 int -1 n -1 = -1 1; -1 double -1 dPrev -1 = -1 0.0; -1 ---- -1 ---double -1 ---p0 -1 ---= -1 ---1.0; -1 ---- -1 ---double -1 ---q1 -1 ---= -1 ---1.0; -1 double -1 cPrev -1 = -1 hPrev; -1 double -1 hN -1 = -1 hPrev; -1 @@ -1 -140,34 -1 +138,18 -1 @@ -1 public -1 double -1 evaluate(double -1 x, -1 double -1 epsilon, -1 int -1 maxIterations) -1 { -1 final -1 double -1 a -1 = -1 getA(n, -1 x); -1 final -1 double -1 b -1 = -1 getB(n, -1 x); -1 ---- -1 ---double -1 ---cN -1 ---= -1 ---a -1 ---* -1 ---hPrev -1 ---+ -1 ---b -1 ---* -1 ---p0; -1 ---- -1 ---double -1 ---q2 -1 ---= -1 ---a -1 ---* -1 ---q1 -1 ---+ -1 ---b -1 ---* -1 ---dPrev; -1 ---- -1 ---if -1 ---(Double.isInfinite(cN) -1 ---|| -1 ---Double.isInfinite(q2)) -1 ---{ -1 ---- -1 ---double -1 ---scaleFactor -1 ---= -1 ---1d; -1 ---- -1 ---double -1 ---lastScaleFactor -1 ---= -1 ---1d; -1 ---- -1 ---final -1 ---int -1 ---maxPower -1 ---= -1 ---5; -1 ---- -1 ---final -1 ---double -1 ---scale -1 ---= -1 ---FastMath.max(a,b); -1 ---- -1 ---if -1 ---(scale -1 ---<= -1 ---0) -1 ---{ -1 ---// -1 ---Can't -1 ---scale -1 ---- -1 ---throw -1 ---new -1 ---ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, -1 ---x); -1 ---- -1 ---} -1 ---- -1 ---for -1 ---(int -1 ---i -1 ---= -1 ---0; -1 ---i -1 ---< -1 ---maxPower; -1 ---i++) -1 ---{ -1 ---- -1 ---lastScaleFactor -1 ---= -1 ---scaleFactor; -1 ---- -1 ---scaleFactor -1 ---*= -1 ---scale; -1 ---- -1 ---if -1 ---(a -1 ---!= -1 ---0.0 -1 ---&& -1 ---a -1 ---> -1 ---b) -1 ---{ -1 ---- -1 ---cN -1 ---= -1 ---hPrev -1 ---/ -1 ---lastScaleFactor -1 ---+ -1 ---(b -1 ---/ -1 ---scaleFactor -1 ---* -1 ---p0); -1 ---- -1 ---q2 -1 ---= -1 ---q1 -1 ---/ -1 ---lastScaleFactor -1 ---+ -1 ---(b -1 ---/ -1 ---scaleFactor -1 ---* -1 ---dPrev); -1 ---- -1 ---} -1 ---else -1 ---if -1 ---(b -1 ---!= -1 ---0) -1 ---{ -1 ---- -1 ---cN -1 ---= -1 ---(a -1 ---/ -1 ---scaleFactor -1 ---* -1 ---hPrev) -1 ---+ -1 ---p0 -1 ---/ -1 ---lastScaleFactor; -1 ---- -1 ---q2 -1 ---= -1 ---(a -1 ---/ -1 ---scaleFactor -1 ---* -1 ---q1) -1 ---+ -1 ---dPrev -1 ---/ -1 ---lastScaleFactor; -1 ---- -1 ---} -1 ---- -1 ---if -1 ---(!(Double.isInfinite(cN) -1 ---|| -1 ---Double.isInfinite(q2))) -1 ---{ -1 ---- -1 ---break; -1 ---- -1 ---} -1 ---- -1 ---} -1 ++++ -1 +++double -1 +++dN -1 +++= -1 +++a -1 ++++ -1 +++b -1 +++* -1 +++dPrev; -1 ++++ -1 +++if -1 +++(Precision.equals(dN, -1 +++0.0, -1 +++small)) -1 +++{ -1 ++++ -1 +++dN -1 +++= -1 +++small; -1 ++++ -1 +++} -1 ++++ -1 +++double -1 +++cN -1 +++= -1 +++a -1 ++++ -1 +++b -1 +++/ -1 +++cPrev; -1 ++++ -1 +++if -1 +++(Precision.equals(cN, -1 +++0.0, -1 +++small)) -1 +++{ -1 ++++ -1 +++cN -1 +++= -1 +++small; -1 } -1 ---- -1 ---final -1 ---double -1 ---deltaN -1 ---= -1 ---cN -1 ---/ -1 ---q2 -1 ---/ -1 ---cPrev; -1 ---- -1 ---hN -1 ---= -1 ---cPrev -1 ---* -1 ---deltaN; -1 ++++ -1 +++dN -1 +++= -1 +++1 -1 +++/ -1 +++dN; -1 ++++ -1 +++final -1 +++double -1 +++deltaN -1 +++= -1 +++cN -1 +++* -1 +++dN; -1 ++++ -1 +++hN -1 +++= -1 +++hPrev -1 +++* -1 +++deltaN; -1 if -1 (Double.isInfinite(hN)) -1 { -1 throw -1 new -1 ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, -1 @@ -1 -182,11 -1 +164,9 -1 @@ -1 public -1 double -1 evaluate(double -1 x, -1 double -1 epsilon, -1 int -1 maxIterations) -1 { -1 break; -1 } -1 ---- -1 ---dPrev -1 ---= -1 ---q1; -1 ---- -1 ---cPrev -1 ---= -1 ---cN -1 ---/ -1 ---q2; -1 ---- -1 ---p0 -1 ---= -1 ---hPrev; -1 ---- -1 ---hPrev -1 ---= -1 ---cN; -1 ---- -1 ---q1 -1 ---= -1 ---q2; -1 ++++ -1 +++dPrev -1 +++= -1 +++dN; -1 ++++ -1 +++cPrev -1 +++= -1 +++cN; -1 ++++ -1 +++hPrev -1 +++= -1 +++hN; -1 n++; -1 } -1 -2
protected -1 void -1 computeGeometricalProperties() -1 { -1 if -1 (v.length -1 == -1 0) -1 { -1 final -1 BSPTree<Euclidean2D> -1 tree -1 = -1 getTree(false); -1 ---- -1 ---if -1 ---((Boolean) -1 ---tree.getAttribute()) -1 ---{ -1 ++++ -1 +++if -1 +++(tree.getCut() -1 +++== -1 +++null -1 +++&& -1 +++(Boolean) -1 +++tree.getAttribute()) -1 +++{ -1 // -1 the -1 instance -1 covers -1 the -1 whole -1 space -1 setSize(Double.POSITIVE_INFINITY); -1 setBarycenter(Vector2D.NaN); -1 -2
public -1 ElitisticListPopulation(final -1 List<Chromosome> -1 chromosomes, -1 final -1 int -1 populationLimit, -1 final -1 double -1 elitismRate) -1 { -1 super(chromosomes, -1 populationLimit); -1 ---- -1 ---this.elitismRate -1 ---= -1 ---elitismRate; -1 ++++ -1 +++setElitismRate(elitismRate); -1 } -1 /** -1 @@ -1 -62,7 -1 +62,7 -1 @@ -1 public -1 ElitisticListPopulation(final -1 List<Chromosome> -1 chromosomes, -1 */ -1 public -1 ElitisticListPopulation(final -1 int -1 populationLimit, -1 final -1 double -1 elitismRate) -1 { -1 super(populationLimit); -1 ---- -1 ---this.elitismRate -1 ---= -1 ---elitismRate; -1 ++++ -1 +++setElitismRate(elitismRate); -1 } -1 /** -1 -2
protected -1 void -1 dropPhase1Objective() -1 { -1 // -1 positive -1 cost -1 non-artificial -1 variables -1 for -1 (int -1 i -1 = -1 getNumObjectiveFunctions(); -1 i -1 < -1 getArtificialVariableOffset(); -1 i++) -1 { -1 final -1 double -1 entry -1 = -1 tableau.getEntry(0, -1 i); -1 ---- -1 ---if -1 ---(Precision.compareTo(entry, -1 ---0d, -1 ---maxUlps) -1 ---> -1 ---0) -1 ---{ -1 ++++ -1 +++if -1 +++(Precision.compareTo(entry, -1 +++0d, -1 +++epsilon) -1 +++> -1 +++0) -1 +++{ -1 columnsToDrop.add(i); -1 } -1 } -1 -2
public -1 Complex -1 sqrt1z() -1 { -1 * -1 @since -1 1.2 -1 */ -1 public -1 Complex -1 tan() -1 { -1 ---- -1 ---if -1 ---(isNaN) -1 ---{ -1 ++++ -1 +++if -1 +++(isNaN -1 +++|| -1 +++Double.isInfinite(real)) -1 +++{ -1 return -1 NaN; -1 } -1 ++++ -1 +++if -1 +++(imaginary -1 +++> -1 +++20.0) -1 +++{ -1 ++++ -1 +++return -1 +++createComplex(0.0, -1 +++1.0); -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(imaginary -1 +++< -1 +++-20.0) -1 +++{ -1 ++++ -1 +++return -1 +++createComplex(0.0, -1 +++-1.0); -1 ++++ -1 +++} -1 double -1 real2 -1 = -1 2.0 -1 * -1 real; -1 double -1 imaginary2 -1 = -1 2.0 -1 * -1 imaginary; -1 @@ -1 -1060,9 -1 +1066,15 -1 @@ -1 public -1 Complex -1 tan() -1 { -1 * -1 @since -1 1.2 -1 */ -1 public -1 Complex -1 tanh() -1 { -1 ---- -1 ---if -1 ---(isNaN) -1 ---{ -1 ++++ -1 +++if -1 +++(isNaN -1 +++|| -1 +++Double.isInfinite(imaginary)) -1 +++{ -1 return -1 NaN; -1 } -1 ++++ -1 +++if -1 +++(real -1 +++> -1 +++20.0) -1 +++{ -1 ++++ -1 +++return -1 +++createComplex(1.0, -1 +++0.0); -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(real -1 +++< -1 +++-20.0) -1 +++{ -1 ++++ -1 +++return -1 +++createComplex(-1.0, -1 +++0.0); -1 ++++ -1 +++} -1 double -1 real2 -1 = -1 2.0 -1 * -1 real; -1 double -1 imaginary2 -1 = -1 2.0 -1 * -1 imaginary; -1 double -1 d -1 = -1 FastMath.cosh(real2) -1 + -1 FastMath.cos(imaginary2); -1 -2
public -1 String -1 toString() -1 { -1 * -1 @return -1 chromosome -1 iterator -1 */ -1 public -1 Iterator<Chromosome> -1 iterator() -1 { -1 ---- -1 ---return -1 ---chromosomes.iterator(); -1 ++++ -1 +++return -1 +++getChromosomes().iterator(); -1 } -1 } -1 -2
protected -1 double -1 doSolve() -1 { -1 double -1 targetY; -1 if -1 (agingA -1 >= -1 MAXIMAL_AGING) -1 { -1 // -1 we -1 keep -1 updating -1 the -1 high -1 bracket, -1 try -1 to -1 compensate -1 this -1 ---- -1 ---targetY -1 ---= -1 ----REDUCTION_FACTOR -1 ---* -1 ---yB; -1 ++++ -1 +++final -1 +++int -1 +++p -1 +++= -1 +++agingA -1 +++- -1 +++MAXIMAL_AGING; -1 ++++ -1 +++final -1 +++double -1 +++weightA -1 +++= -1 +++(1 -1 +++<< -1 +++p) -1 +++- -1 +++1; -1 ++++ -1 +++final -1 +++double -1 +++weightB -1 +++= -1 +++p -1 ++++ -1 +++1; -1 ++++ -1 +++targetY -1 +++= -1 +++(weightA -1 +++* -1 +++yA -1 +++- -1 +++weightB -1 +++* -1 +++REDUCTION_FACTOR -1 +++* -1 +++yB) -1 +++/ -1 +++(weightA -1 ++++ -1 +++weightB); -1 } -1 else -1 if -1 (agingB -1 >= -1 MAXIMAL_AGING) -1 { -1 // -1 we -1 keep -1 updating -1 the -1 low -1 bracket, -1 try -1 to -1 compensate -1 this -1 ---- -1 ---targetY -1 ---= -1 ----REDUCTION_FACTOR -1 ---* -1 ---yA; -1 ++++ -1 +++final -1 +++int -1 +++p -1 +++= -1 +++agingB -1 +++- -1 +++MAXIMAL_AGING; -1 ++++ -1 +++final -1 +++double -1 +++weightA -1 +++= -1 +++p -1 ++++ -1 +++1; -1 ++++ -1 +++final -1 +++double -1 +++weightB -1 +++= -1 +++(1 -1 +++<< -1 +++p) -1 +++- -1 +++1; -1 ++++ -1 +++targetY -1 +++= -1 +++(weightB -1 +++* -1 +++yB -1 +++- -1 +++weightA -1 +++* -1 +++REDUCTION_FACTOR -1 +++* -1 +++yA) -1 +++/ -1 +++(weightA -1 ++++ -1 +++weightB); -1 } -1 else -1 { -1 // -1 bracketing -1 is -1 balanced, -1 try -1 to -1 find -1 the -1 root -1 itself -1 targetY -1 = -1 0; -1 -2
private -1 void -1 prelim(double[] -1 lowerBound, -1 final -1 int -1 tmp2 -1 = -1 jpt; -1 jpt -1 = -1 ipt -1 - -1 n; -1 ipt -1 = -1 tmp2; -1 ---- -1 ---throw -1 ---new -1 ---PathIsExploredException(); -1 ---// -1 ---XXX -1 ++++// -1 +++throw -1 +++new -1 +++PathIsExploredException(); -1 +++// -1 +++XXX -1 } -1 ---- -1 ---final -1 ---int -1 ---iptMinus1 -1 ---= -1 ---ipt; -1 ---- -1 ---final -1 ---int -1 ---jptMinus1 -1 ---= -1 ---jpt; -1 ++++ -1 +++final -1 +++int -1 +++iptMinus1 -1 +++= -1 +++ipt -1 +++- -1 +++1; -1 ++++ -1 +++final -1 +++int -1 +++jptMinus1 -1 +++= -1 +++jpt -1 +++- -1 +++1; -1 interpolationPoints.setEntry(nfm, -1 iptMinus1, -1 interpolationPoints.getEntry(ipt, -1 iptMinus1)); -1 interpolationPoints.setEntry(nfm, -1 jptMinus1, -1 interpolationPoints.getEntry(jpt, -1 jptMinus1)); -1 } -1 @@ -1 -1749,7 -1 +1749,7 -1 @@ -1 private -1 void -1 prelim(double[] -1 lowerBound, -1 final -1 int -1 ih -1 = -1 ipt -1 * -1 (ipt -1 - -1 1) -1 / -1 2 -1 + -1 jpt -1 - -1 1; -1 final -1 double -1 tmp -1 = -1 interpolationPoints.getEntry(nfm, -1 ipt -1 - -1 1) -1 * -1 interpolationPoints.getEntry(nfm, -1 jpt -1 - -1 1); -1 modelSecondDerivativesValues.setEntry(ih, -1 (fbeg -1 - -1 fAtInterpolationPoints.getEntry(ipt) -1 - -1 fAtInterpolationPoints.getEntry(jpt) -1 + -1 f) -1 / -1 tmp); -1 ---- -1 ---throw -1 ---new -1 ---PathIsExploredException(); -1 ---// -1 ---XXX -1 ++++// -1 +++throw -1 +++new -1 +++PathIsExploredException(); -1 +++// -1 +++XXX -1 } -1 } -1 while -1 (getEvaluations() -1 < -1 npt); -1 } -1 // -1 prelim -1 -2
public -1 void -1 integrate(final -1 ExpandableStatefulODE -1 equations, -1 final -1 double -1 t) -1 } -1 stepSize -1 = -1 hNew; -1 ++++ -1 +++if -1 +++(forward) -1 +++{ -1 ++++ -1 +++if -1 +++(stepStart -1 ++++ -1 +++stepSize -1 +++>= -1 +++t) -1 +++{ -1 ++++ -1 +++stepSize -1 +++= -1 +++t -1 +++- -1 +++stepStart; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++if -1 +++(stepStart -1 ++++ -1 +++stepSize -1 +++<= -1 +++t) -1 +++{ -1 ++++ -1 +++stepSize -1 +++= -1 +++t -1 +++- -1 +++stepStart; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 // -1 next -1 stages -1 for -1 (int -1 k -1 = -1 1; -1 k -1 < -1 stages; -1 ++k) -1 { -1 -2
public -1 BigFraction -1 divide(final -1 BigFraction -1 fraction) -1 { -1 @Override -1 public -1 double -1 doubleValue() -1 { -1 double -1 result -1 = -1 numerator.doubleValue() -1 / -1 denominator.doubleValue(); -1 ++++ -1 +++if -1 +++(Double.isNaN(result)) -1 +++{ -1 // -1 Numerator -1 and/or -1 denominator -1 must -1 be -1 out -1 of -1 range: -1 // -1 Calculate -1 how -1 far -1 to -1 shift -1 them -1 to -1 put -1 them -1 in -1 range. -1 ++++ -1 +++int -1 +++shift -1 +++= -1 +++Math.max(numerator.bitLength(), -1 ++++ -1 +++denominator.bitLength()) -1 +++- -1 +++Double.MAX_EXPONENT; -1 ++++ -1 +++result -1 +++= -1 +++numerator.shiftRight(shift).doubleValue() -1 +++/ -1 ++++ -1 +++denominator.shiftRight(shift).doubleValue(); -1 ++++ -1 +++} -1 return -1 result; -1 } -1 @@ -1 -730,8 -1 +736,14 -1 @@ -1 public -1 boolean -1 equals(final -1 Object -1 other) -1 { -1 @Override -1 public -1 float -1 floatValue() -1 { -1 float -1 result -1 = -1 numerator.floatValue() -1 / -1 denominator.floatValue(); -1 ++++ -1 +++if -1 +++(Double.isNaN(result)) -1 +++{ -1 // -1 Numerator -1 and/or -1 denominator -1 must -1 be -1 out -1 of -1 range: -1 // -1 Calculate -1 how -1 far -1 to -1 shift -1 them -1 to -1 put -1 them -1 in -1 range. -1 ++++ -1 +++int -1 +++shift -1 +++= -1 +++Math.max(numerator.bitLength(), -1 ++++ -1 +++denominator.bitLength()) -1 +++- -1 +++Float.MAX_EXPONENT; -1 ++++ -1 +++result -1 +++= -1 +++numerator.shiftRight(shift).floatValue() -1 +++/ -1 ++++ -1 +++denominator.shiftRight(shift).floatValue(); -1 ++++ -1 +++} -1 return -1 result; -1 } -1 -2
protected -1 RealPointValuePair -1 getSolution() -1 { -1 continue; -1 } -1 Integer -1 basicRow -1 = -1 getBasicRow(colIndex); -1 ++++ -1 +++if -1 +++(basicRow -1 +++!= -1 +++null -1 +++&& -1 +++basicRow -1 +++== -1 +++0) -1 +++{ -1 // -1 if -1 the -1 basic -1 row -1 is -1 found -1 to -1 be -1 the -1 objective -1 function -1 row -1 // -1 set -1 the -1 coefficient -1 to -1 0 -1 -> -1 this -1 case -1 handles -1 unconstrained -1 // -1 variables -1 that -1 are -1 still -1 part -1 of -1 the -1 objective -1 function -1 ---- -1 ---if -1 ---(basicRows.contains(basicRow)) -1 ---{ -1 ++++ -1 +++coefficients[i] -1 +++= -1 +++0; -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(basicRows.contains(basicRow)) -1 +++{ -1 // -1 if -1 multiple -1 variables -1 can -1 take -1 a -1 given -1 value -1 // -1 then -1 we -1 choose -1 the -1 first -1 and -1 set -1 the -1 rest -1 equal -1 to -1 0 -1 coefficients[i] -1 = -1 0 -1 - -1 (restrictToNonNegative -1 ? -1 0 -1 : -1 mostNegative); -1 -2
public -1 double -1 evaluate(final -1 double[] -1 values, -1 final -1 double[] -1 weights, -1 } -1 double -1 sumWts -1 = -1 0; -1 ---- -1 ---for -1 ---(int -1 ---i -1 ---= -1 ---0; -1 ---i -1 ---< -1 ---weights.length; -1 ---i++) -1 ---{ -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++begin; -1 +++i -1 +++< -1 +++begin -1 ++++ -1 +++length; -1 +++i++) -1 +++{ -1 sumWts -1 += -1 weights[i]; -1 } -1 -2
protected -1 double -1 acceptStep(final -1 AbstractStepInterpolator -1 interpolator, -1 double -1 previousT -1 = -1 interpolator.getGlobalPreviousTime(); -1 final -1 double -1 currentT -1 = -1 interpolator.getGlobalCurrentTime(); -1 ---- -1 ---resetOccurred -1 ---= -1 ---false; -1 // -1 initialize -1 the -1 events -1 states -1 if -1 needed -1 if -1 (! -1 statesInitialized) -1 { -1 @@ -1 -331,6 -1 +330,9 -1 @@ -1 public -1 int -1 compare(EventState -1 es0, -1 EventState -1 es1) -1 { -1 if -1 (isLastStep) -1 { -1 // -1 the -1 event -1 asked -1 to -1 stop -1 integration -1 System.arraycopy(eventY, -1 0, -1 y, -1 0, -1 y.length); -1 ++++ -1 +++for -1 +++(final -1 +++EventState -1 +++remaining -1 +++: -1 +++occuringEvents) -1 +++{ -1 ++++ -1 +++remaining.stepAccepted(eventT, -1 +++eventY); -1 ++++ -1 +++} -1 return -1 eventT; -1 } -1 @@ -1 -340,6 -1 +342,9 -1 @@ -1 public -1 int -1 compare(EventState -1 es0, -1 EventState -1 es1) -1 { -1 System.arraycopy(eventY, -1 0, -1 y, -1 0, -1 y.length); -1 computeDerivatives(eventT, -1 y, -1 yDot); -1 resetOccurred -1 = -1 true; -1 ++++ -1 +++for -1 +++(final -1 +++EventState -1 +++remaining -1 +++: -1 +++occuringEvents) -1 +++{ -1 ++++ -1 +++remaining.stepAccepted(eventT, -1 +++eventY); -1 ++++ -1 +++} -1 return -1 eventT; -1 } -1 -2
public -1 void -1 addValue(double -1 value) -1 { -1 secondMoment.increment(value); -1 // -1 If -1 mean, -1 variance -1 or -1 geomean -1 have -1 been -1 overridden, -1 // -1 need -1 to -1 increment -1 these -1 ---- -1 ---if -1 ---(!(meanImpl -1 ---instanceof -1 ---Mean)) -1 ---{ -1 ++++ -1 +++if -1 +++(meanImpl -1 +++!= -1 +++mean) -1 +++{ -1 meanImpl.increment(value); -1 } -1 ---- -1 ---if -1 ---(!(varianceImpl -1 ---instanceof -1 ---Variance)) -1 ---{ -1 ++++ -1 +++if -1 +++(varianceImpl -1 +++!= -1 +++variance) -1 +++{ -1 varianceImpl.increment(value); -1 } -1 ---- -1 ---if -1 ---(!(geoMeanImpl -1 ---instanceof -1 ---GeometricMean)) -1 ---{ -1 ++++ -1 +++if -1 +++(geoMeanImpl -1 +++!= -1 +++geoMean) -1 +++{ -1 geoMeanImpl.increment(value); -1 } -1 n++; -1 -2
/* -1 * -1 Licensed -1 to -1 the -1 Apache -1 Software -1 Foundation -1 (ASF) -1 under -1 one -1 or -1 more -1 * -1 contributor -1 license -1 agreements. -1 See -1 the -1 NOTICE -1 file -1 distributed -1 with -1 * -1 this -1 work -1 for -1 additional -1 information -1 regarding -1 copyright -1 ownership. -1 * -1 The -1 ASF -1 licenses -1 this -1 file -1 to -1 You -1 under -1 the -1 Apache -1 License, -1 Version -1 2.0 -1 * -1 (the -1 "License"); -1 you -1 may -1 not -1 use -1 this -1 file -1 except -1 in -1 compliance -1 with -1 * -1 the -1 License. -1 You -1 may -1 obtain -1 a -1 copy -1 of -1 the -1 License -1 at -1 * -1 * -1 http://www.apache.org/licenses/LICENSE-2.0 -1 * -1 * -1 Unless -1 required -1 by -1 applicable -1 law -1 or -1 agreed -1 to -1 in -1 writing, -1 software -1 * -1 distributed -1 under -1 the -1 License -1 is -1 distributed -1 on -1 an -1 "AS -1 IS" -1 BASIS, -1 * -1 WITHOUT -1 WARRANTIES -1 OR -1 CONDITIONS -1 OF -1 ANY -1 KIND, -1 either -1 express -1 or -1 implied. -1 * -1 See -1 the -1 License -1 for -1 the -1 specific -1 language -1 governing -1 permissions -1 and -1 * -1 limitations -1 under -1 the -1 License. -1 */ -1 package -1 org.apache.commons.math.complex; -1 import -1 java.io.Serializable; -1 import -1 java.util.ArrayList; -1 import -1 java.util.List; -1 import -1 org.apache.commons.math.FieldElement; -1 import -1 org.apache.commons.math.exception.NullArgumentException; -1 import -1 org.apache.commons.math.exception.NotPositiveException; -1 import -1 org.apache.commons.math.exception.util.LocalizedFormats; -1 import -1 org.apache.commons.math.util.MathUtils; -1 import -1 org.apache.commons.math.util.FastMath; -1 /** -1 * -1 Representation -1 of -1 a -1 Complex -1 number, -1 i.e. -1 a -1 number -1 which -1 has -1 both -1 a -1 * -1 real -1 and -1 imaginary -1 part. -1 * -1 <br/> -1 * -1 Implementations -1 of -1 arithmetic -1 operations -1 handle -1 {@code -1 NaN} -1 and -1 * -1 infinite -1 values -1 according -1 to -1 the -1 rules -1 for -1 {@link -1 java.lang.Double}, -1 i.e. -1 * -1 {@link -1 #equals} -1 is -1 an -1 equivalence -1 relation -1 for -1 all -1 instances -1 that -1 have -1 * -1 a -1 {@code -1 NaN} -1 in -1 either -1 real -1 or -1 imaginary -1 part, -1 e.g. -1 the -1 following -1 are -1 * -1 considered -1 equal: -1 * -1 <ul> -1 * -1 <li>{@code -1 1 -1 + -1 NaNi}</li> -1 * -1 <li>{@code -1 NaN -1 + -1 i}</li> -1 * -1 <li>{@code -1 NaN -1 + -1 NaNi}</li> -1 * -1 </ul> -1 * -1 Note -1 that -1 this -1 is -1 in -1 contradiction -1 with -1 the -1 IEEE-754 -1 standard -1 for -1 floating -1 * -1 point -1 numbers -1 (according -1 to -1 which -1 the -1 test -1 {@code -1 x -1 == -1 x} -1 must -1 fail -1 if -1 * -1 {@code -1 x} -1 is -1 {@code -1 NaN}). -1 The -1 method -1 * -1 {@link -1 MathUtils#equals(double,double,int) -1 equals -1 for -1 primitive -1 double} -1 in -1 * -1 {@link -1 MathUtils} -1 conforms -1 with -1 IEEE-754 -1 while -1 this -1 class -1 conforms -1 with -1 * -1 the -1 standard -1 behavior -1 for -1 Java -1 object -1 types. -1 * -1 <br/> -1 * -1 Implements -1 Serializable -1 since -1 2.0 -1 * -1 * -1 @version -1 $Id$ -1 */ -1 public -1 class -1 Complex -1 implements -1 FieldElement<Complex>, -1 Serializable -1 { -1 /** -1 The -1 square -1 root -1 of -1 -1. -1 A -1 number -1 representing -1 "0.0 -1 + -1 1.0i" -1 */ -1 public -1 static -1 final -1 Complex -1 I -1 = -1 new -1 Complex(0.0, -1 1.0); -1 // -1 CHECKSTYLE: -1 stop -1 ConstantName -1 /** -1 A -1 complex -1 number -1 representing -1 "NaN -1 + -1 NaNi" -1 */ -1 public -1 static -1 final -1 Complex -1 NaN -1 = -1 new -1 Complex(Double.NaN, -1 Double.NaN); -1 // -1 CHECKSTYLE: -1 resume -1 ConstantName -1 /** -1 A -1 complex -1 number -1 representing -1 "+INF -1 + -1 INFi" -1 */ -1 public -1 static -1 final -1 Complex -1 INF -1 = -1 new -1 Complex(Double.POSITIVE_INFINITY, -1 Double.POSITIVE_INFINITY); -1 /** -1 A -1 complex -1 number -1 representing -1 "1.0 -1 + -1 0.0i" -1 */ -1 public -1 static -1 final -1 Complex -1 ONE -1 = -1 new -1 Complex(1.0, -1 0.0); -1 /** -1 A -1 complex -1 number -1 representing -1 "0.0 -1 + -1 0.0i" -1 */ -1 public -1 static -1 final -1 Complex -1 ZERO -1 = -1 new -1 Complex(0.0, -1 0.0); -1 /** -1 Serializable -1 version -1 identifier -1 */ -1 private -1 static -1 final -1 long -1 serialVersionUID -1 = -1 -6195664516687396620L; -1 /** -1 The -1 imaginary -1 part. -1 */ -1 private -1 final -1 double -1 imaginary; -1 /** -1 The -1 real -1 part. -1 */ -1 private -1 final -1 double -1 real; -1 /** -1 Record -1 whether -1 this -1 complex -1 number -1 is -1 equal -1 to -1 NaN. -1 */ -1 private -1 final -1 transient -1 boolean -1 isNaN; -1 /** -1 Record -1 whether -1 this -1 complex -1 number -1 is -1 infinite. -1 */ -1 private -1 final -1 transient -1 boolean -1 isInfinite; -1 /** -1 Record -1 whether -1 this -1 complex -1 number -1 is -1 zero. -1 */ -1 ++++ -1 +++private -1 +++final -1 +++transient -1 +++boolean -1 +++isZero; -1 /** -1 * -1 Create -1 a -1 complex -1 number -1 given -1 only -1 the -1 real -1 part. -1 * -1 * -1 @param -1 real -1 Real -1 part. -1 */ -1 @@ -1 -98,17 -1 +99,18 -1 @@ -1 public -1 Complex(double -1 real) -1 { -1 public -1 Complex(double -1 real, -1 double -1 imaginary) -1 { -1 this.real -1 = -1 real; -1 this.imaginary -1 = -1 imaginary; -1 isNaN -1 = -1 Double.isNaN(real) -1 || -1 Double.isNaN(imaginary); -1 isInfinite -1 = -1 !isNaN -1 && -1 (Double.isInfinite(real) -1 || -1 Double.isInfinite(imaginary)); -1 ++++ -1 +++isZero -1 +++= -1 +++real -1 +++== -1 +++0 -1 +++&& -1 +++imaginary -1 +++== -1 +++0; -1 } -1 /** -1 * -1 Return -1 the -1 absolute -1 value -1 of -1 this -1 complex -1 number. -1 * -1 Returns -1 {@code -1 NaN} -1 if -1 either -1 real -1 or -1 imaginary -1 part -1 is -1 {@code -1 NaN} -1 * -1 and -1 {@code -1 Double.POSITIVE_INFINITY} -1 if -1 neither -1 part -1 is -1 {@code -1 NaN}, -1 * -1 but -1 at -1 least -1 one -1 part -1 is -1 infinite. -1 * -1 * -1 @return -1 the -1 absolute -1 value. -1 */ -1 @@ -1 -249,60 -1 +251,60 -1 @@ -1 public -1 Complex -1 conjugate() -1 { -1 public -1 Complex -1 divide(Complex -1 divisor) -1 throws -1 NullArgumentException -1 { -1 MathUtils.checkNotNull(divisor); -1 if -1 (isNaN -1 || -1 divisor.isNaN) -1 { -1 return -1 NaN; -1 } -1 ---- -1 ---if -1 ---(divisor.getReal() -1 ---== -1 ---0.0 -1 ---&& -1 ---divisor.getImaginary() -1 ---== -1 ---0.0) -1 ---{ -1 ---- -1 ---return -1 ---NaN; -1 ++++ -1 +++if -1 +++(divisor.isZero) -1 +++{ -1 ++++ -1 +++return -1 +++isZero -1 +++? -1 +++NaN -1 +++: -1 +++INF; -1 } -1 if -1 (divisor.isInfinite() -1 && -1 !isInfinite()) -1 { -1 return -1 ZERO; -1 } -1 final -1 double -1 c -1 = -1 divisor.getReal(); -1 final -1 double -1 d -1 = -1 divisor.getImaginary(); -1 if -1 (FastMath.abs(c) -1 < -1 FastMath.abs(d)) -1 { -1 double -1 q -1 = -1 c -1 / -1 d; -1 double -1 denominator -1 = -1 c -1 * -1 q -1 + -1 d; -1 return -1 createComplex((real -1 * -1 q -1 + -1 imaginary) -1 / -1 denominator, -1 (imaginary -1 * -1 q -1 - -1 real) -1 / -1 denominator); -1 } -1 else -1 { -1 double -1 q -1 = -1 d -1 / -1 c; -1 double -1 denominator -1 = -1 d -1 * -1 q -1 + -1 c; -1 return -1 createComplex((imaginary -1 * -1 q -1 + -1 real) -1 / -1 denominator, -1 (imaginary -1 - -1 real -1 * -1 q) -1 / -1 denominator); -1 } -1 } -1 /** -1 * -1 Returns -1 a -1 {@code -1 Complex} -1 whose -1 value -1 is -1 {@code -1 (this -1 / -1 divisor)}, -1 * -1 with -1 {@code -1 divisor} -1 interpreted -1 as -1 a -1 real -1 number. -1 * -1 * -1 @param -1 divisor -1 Value -1 by -1 which -1 this -1 {@code -1 Complex} -1 is -1 to -1 be -1 divided. -1 * -1 @return -1 {@code -1 this -1 / -1 divisor}. -1 * -1 @see -1 #divide(Complex) -1 */ -1 public -1 Complex -1 divide(double -1 divisor) -1 { -1 if -1 (isNaN -1 || -1 Double.isNaN(divisor)) -1 { -1 return -1 NaN; -1 } -1 if -1 (divisor -1 == -1 0d) -1 { -1 ---- -1 ---return -1 ---NaN; -1 ++++ -1 +++return -1 +++isZero -1 +++? -1 +++NaN -1 +++: -1 +++INF; -1 } -1 if -1 (Double.isInfinite(divisor)) -1 { -1 return -1 !isInfinite() -1 ? -1 ZERO -1 : -1 NaN; -1 } -1 return -1 createComplex(real -1 / -1 divisor, -1 imaginary -1 / -1 divisor); -1 } -1 /** -1 * -1 Test -1 for -1 the -1 equality -1 of -1 two -1 Complex -1 objects. -1 * -1 If -1 both -1 the -1 real -1 and -1 imaginary -1 parts -1 of -1 two -1 complex -1 numbers -1 * -1 are -1 exactly -1 the -1 same, -1 and -1 neither -1 is -1 {@code -1 Double.NaN}, -1 the -1 two -1 * -1 Complex -1 objects -1 are -1 considered -1 to -1 be -1 equal. -1 * -1 All -1 {@code -1 NaN} -1 values -1 are -1 considered -1 to -1 be -1 equal -1 - -1 i.e, -1 if -1 either -1 * -1 (or -1 both) -1 real -1 and -1 imaginary -1 parts -1 of -1 the -1 complex -1 number -1 are -1 equal -1 -2
protected -1 final -1 double -1 doSolve() -1 { -1 case -1 REGULA_FALSI: -1 // -1 Detect -1 early -1 that -1 algorithm -1 is -1 stuck, -1 instead -1 of -1 waiting -1 // -1 for -1 the -1 maximum -1 number -1 of -1 iterations -1 to -1 be -1 exceeded. -1 ++++ -1 +++if -1 +++(x -1 +++== -1 +++x1) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++ConvergenceException(); -1 ++++ -1 +++} -1 break; -1 default: -1 // -1 Should -1 never -1 happen. -1 -2
protected -1 final -1 double -1 doSolve() -1 { -1 break; -1 case -1 REGULA_FALSI: -1 // -1 Nothing. -1 ---- -1 ---if -1 ---(x -1 ---== -1 ---x1) -1 ---{ -1 ---- -1 ---x0 -1 ---= -1 ---0.5 -1 ---* -1 ---(x0 -1 ---+ -1 ---x1 -1 ---- -1 ---FastMath.max(rtol -1 ---* -1 ---FastMath.abs(x1), -1 ---atol)); -1 ---- -1 ---f0 -1 ---= -1 ---computeObjectiveValue(x0); -1 ---- -1 ---} -1 break; -1 default: -1 // -1 Should -1 never -1 happen. -1 -2
public -1 double -1 dotProduct(RealVector -1 v) -1 { -1 public -1 OpenMapRealVector -1 ebeDivide(RealVector -1 v) -1 { -1 checkVectorDimensions(v.getDimension()); -1 OpenMapRealVector -1 res -1 = -1 new -1 OpenMapRealVector(this); -1 ---- -1 ---Iterator -1 ---iter -1 ---= -1 ---res.entries.iterator(); -1 ++++ -1 +++Iterator -1 +++iter -1 +++= -1 +++entries.iterator(); -1 while -1 (iter.hasNext()) -1 { -1 iter.advance(); -1 res.setEntry(iter.key(), -1 iter.value() -1 / -1 v.getEntry(iter.key())); -1 @@ -1 -355,7 -1 +355,7 -1 @@ -1 public -1 OpenMapRealVector -1 ebeDivide(RealVector -1 v) -1 { -1 public -1 OpenMapRealVector -1 ebeDivide(double[] -1 v) -1 { -1 checkVectorDimensions(v.length); -1 OpenMapRealVector -1 res -1 = -1 new -1 OpenMapRealVector(this); -1 ---- -1 ---Iterator -1 ---iter -1 ---= -1 ---res.entries.iterator(); -1 ++++ -1 +++Iterator -1 +++iter -1 +++= -1 +++entries.iterator(); -1 while -1 (iter.hasNext()) -1 { -1 iter.advance(); -1 res.setEntry(iter.key(), -1 iter.value() -1 / -1 v[iter.key()]); -1 @@ -1 -367,7 -1 +367,7 -1 @@ -1 public -1 OpenMapRealVector -1 ebeDivide(double[] -1 v) -1 { -1 public -1 OpenMapRealVector -1 ebeMultiply(RealVector -1 v) -1 { -1 checkVectorDimensions(v.getDimension()); -1 OpenMapRealVector -1 res -1 = -1 new -1 OpenMapRealVector(this); -1 ---- -1 ---Iterator -1 ---iter -1 ---= -1 ---res.entries.iterator(); -1 ++++ -1 +++Iterator -1 +++iter -1 +++= -1 +++entries.iterator(); -1 while -1 (iter.hasNext()) -1 { -1 iter.advance(); -1 res.setEntry(iter.key(), -1 iter.value() -1 * -1 v.getEntry(iter.key())); -1 @@ -1 -380,7 -1 +380,7 -1 @@ -1 public -1 OpenMapRealVector -1 ebeMultiply(RealVector -1 v) -1 { -1 public -1 OpenMapRealVector -1 ebeMultiply(double[] -1 v) -1 { -1 checkVectorDimensions(v.length); -1 OpenMapRealVector -1 res -1 = -1 new -1 OpenMapRealVector(this); -1 ---- -1 ---Iterator -1 ---iter -1 ---= -1 ---res.entries.iterator(); -1 ++++ -1 +++Iterator -1 +++iter -1 +++= -1 +++entries.iterator(); -1 while -1 (iter.hasNext()) -1 { -1 iter.advance(); -1 res.setEntry(iter.key(), -1 iter.value() -1 * -1 v[iter.key()]); -1 -2
public -1 Complex -1 divide(Complex -1 divisor) -1 if -1 (divisor.isZero) -1 { -1 // -1 return -1 isZero -1 ? -1 NaN -1 : -1 INF; -1 // -1 See -1 MATH-657 -1 ---- -1 ---return -1 ---isZero -1 ---? -1 ---NaN -1 ---: -1 ---INF; -1 ++++ -1 +++return -1 +++NaN; -1 } -1 if -1 (divisor.isInfinite() -1 && -1 !isInfinite()) -1 { -1 @@ -1 -294,7 -1 +294,7 -1 @@ -1 public -1 Complex -1 divide(double -1 divisor) -1 { -1 } -1 if -1 (divisor -1 == -1 0d) -1 { -1 // -1 return -1 isZero -1 ? -1 NaN -1 : -1 INF; -1 // -1 See -1 MATH-657 -1 ---- -1 ---return -1 ---isZero -1 ---? -1 ---NaN -1 ---: -1 ---INF; -1 ++++ -1 +++return -1 +++NaN; -1 } -1 if -1 (Double.isInfinite(divisor)) -1 { -1 return -1 !isInfinite() -1 ? -1 ZERO -1 : -1 NaN; -1 -2
*/ -1 public -1 OpenMapRealMatrix(int -1 rowDimension, -1 int -1 columnDimension) -1 { -1 super(rowDimension, -1 columnDimension); -1 ++++ -1 +++long -1 +++lRow -1 +++= -1 +++(long) -1 +++rowDimension; -1 ++++ -1 +++long -1 +++lCol -1 +++= -1 +++(long) -1 +++columnDimension; -1 ++++ -1 +++if -1 +++(lRow -1 +++* -1 +++lCol -1 +++>= -1 +++(long) -1 +++Integer.MAX_VALUE) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++NumberIsTooLargeException(lRow -1 +++* -1 +++lCol, -1 +++Integer.MAX_VALUE, -1 +++false); -1 ++++ -1 +++} -1 this.rows -1 = -1 rowDimension; -1 this.columns -1 = -1 columnDimension; -1 this.entries -1 = -1 new -1 OpenIntToDoubleHashMap(0.0); -1 -2
protected -1 final -1 double -1 doSolve() -1 { -1 case -1 PEGASUS: -1 f0 -1 *= -1 f1 -1 / -1 (f1 -1 + -1 fx); -1 break; -1 ++++ -1 +++case -1 +++REGULA_FALSI: -1 ++++ -1 +++if -1 +++(x -1 +++== -1 +++x1) -1 +++{ -1 ++++ -1 +++final -1 +++double -1 +++delta -1 +++= -1 +++FastMath.max(rtol -1 +++* -1 +++FastMath.abs(x1), -1 ++++ -1 +++atol); -1 // -1 Update -1 formula -1 cannot -1 make -1 any -1 progress: -1 Update -1 the -1 // -1 search -1 interval. -1 ++++ -1 +++x0 -1 +++= -1 +++0.5 -1 +++* -1 +++(x0 -1 ++++ -1 +++x1 -1 +++- -1 +++delta); -1 ++++ -1 +++f0 -1 +++= -1 +++computeObjectiveValue(x0); -1 ++++ -1 +++} -1 ++++ -1 +++break; -1 default: -1 // -1 Should -1 never -1 happen. -1 ++++ -1 +++throw -1 +++new -1 +++MathInternalError(); -1 } -1 } -1 // -1 Update -1 from -1 [x0, -1 x1] -1 to -1 [x0, -1 x]. -1 -2
public -1 double -1 value(double -1 x, -1 double[] -1 p) -1 { -1 */ -1 public -1 double[] -1 fit() -1 { -1 final -1 double[] -1 guess -1 = -1 (new -1 ParameterGuesser(getObservations())).guess(); -1 ---- -1 ---return -1 ---fit(new -1 ---Gaussian.Parametric(), -1 ---guess); -1 ++++ -1 +++return -1 +++fit(guess); -1 } -1 /** -1 -2
public -1 static -1 long -1 max(final -1 long -1 a, -1 final -1 long -1 b) -1 { -1 * -1 @return -1 b -1 if -1 a -1 is -1 lesser -1 or -1 equal -1 to -1 b, -1 a -1 otherwise -1 */ -1 public -1 static -1 float -1 max(final -1 float -1 a, -1 final -1 float -1 b) -1 { -1 ---- -1 ---return -1 ---(a -1 ---<= -1 ---b) -1 ---? -1 ---b -1 ---: -1 ---(Float.isNaN(a -1 ---+ -1 ---b) -1 ---? -1 ---Float.NaN -1 ---: -1 ---b); -1 ++++ -1 +++return -1 +++(a -1 +++<= -1 +++b) -1 +++? -1 +++b -1 +++: -1 +++(Float.isNaN(a -1 ++++ -1 +++b) -1 +++? -1 +++Float.NaN -1 +++: -1 +++a); -1 } -1 /** -1 Compute -1 the -1 maximum -1 of -1 two -1 values -1 -2
public -1 KMeansPlusPlusClusterer(final -1 Random -1 random, -1 final -1 EmptyClusterStrategy -1 e -1 while -1 (resultSet.size() -1 < -1 k) -1 { -1 // -1 For -1 each -1 data -1 point -1 x, -1 compute -1 D(x), -1 the -1 distance -1 between -1 x -1 and -1 // -1 the -1 nearest -1 center -1 that -1 has -1 already -1 been -1 chosen. -1 ---- -1 ---int -1 ---sum -1 ---= -1 ---0; -1 ++++ -1 +++double -1 +++sum -1 +++= -1 +++0; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 pointSet.size(); -1 i++) -1 { -1 final -1 T -1 p -1 = -1 pointSet.get(i); -1 final -1 Cluster<T> -1 nearest -1 = -1 getNearestCluster(resultSet, -1 p); -1 -2
public -1 double -1 abs() -1 { -1 public -1 Complex -1 add(Complex -1 rhs) -1 throws -1 NullArgumentException -1 { -1 MathUtils.checkNotNull(rhs); -1 ++++ -1 +++if -1 +++(isNaN -1 +++|| -1 +++rhs.isNaN) -1 +++{ -1 ++++ -1 +++return -1 +++NaN; -1 ++++ -1 +++} -1 return -1 createComplex(real -1 + -1 rhs.getReal(), -1 imaginary -1 + -1 rhs.getImaginary()); -1 } -1 -2
import -1 java.io.Serializable; -1 import -1 org.apache.commons.math.MathException; -1 ----import -1 ---org.apache.commons.math.MathRuntimeException; -1 ++++import -1 +++org.apache.commons.math.exception.NotStrictlyPositiveException; -1 import -1 org.apache.commons.math.exception.util.LocalizedFormats; -1 import -1 org.apache.commons.math.special.Gamma; -1 import -1 org.apache.commons.math.util.MathUtils; -1 @@ -1 -91,7 -1 +91,7 -1 @@ -1 public -1 PoissonDistributionImpl(double -1 p) -1 { -1 */ -1 public -1 PoissonDistributionImpl(double -1 p, -1 double -1 epsilon, -1 int -1 maxIterations) -1 { -1 if -1 (p -1 <= -1 0) -1 { -1 ---- -1 ---throw -1 ---MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, -1 ---p); -1 ++++ -1 +++throw -1 +++new -1 +++NotStrictlyPositiveException(LocalizedFormats.MEAN, -1 +++p); -1 } -1 mean -1 = -1 p; -1 normal -1 = -1 new -1 NormalDistributionImpl(p, -1 FastMath.sqrt(p)); -1 -2
public -1 static -1 double -1 dotProduct(Vector3D -1 v1, -1 Vector3D -1 v2) -1 { -1 */ -1 public -1 static -1 Vector3D -1 crossProduct(final -1 Vector3D -1 v1, -1 final -1 Vector3D -1 v2) -1 { -1 ++++ -1 +++final -1 +++double -1 +++n1 -1 +++= -1 +++v1.getNormSq(); -1 ++++ -1 +++final -1 +++double -1 +++n2 -1 +++= -1 +++v2.getNormSq(); -1 ++++ -1 +++if -1 +++((n1 -1 +++* -1 +++n2) -1 +++< -1 +++MathUtils.SAFE_MIN) -1 +++{ -1 ++++ -1 +++return -1 +++ZERO; -1 ++++ -1 +++} -1 // -1 rescale -1 both -1 vectors -1 without -1 losing -1 precision, -1 // -1 to -1 ensure -1 their -1 norm -1 are -1 the -1 same -1 order -1 of -1 magnitude -1 ++++ -1 +++final -1 +++int -1 +++deltaExp -1 +++= -1 +++(FastMath.getExponent(n1) -1 +++- -1 +++FastMath.getExponent(n2)) -1 +++/ -1 +++4; -1 ++++ -1 +++final -1 +++double -1 +++x1 -1 +++= -1 +++FastMath.scalb(v1.x, -1 +++-deltaExp); -1 ++++ -1 +++final -1 +++double -1 +++y1 -1 +++= -1 +++FastMath.scalb(v1.y, -1 +++-deltaExp); -1 ++++ -1 +++final -1 +++double -1 +++z1 -1 +++= -1 +++FastMath.scalb(v1.z, -1 +++-deltaExp); -1 ++++ -1 +++final -1 +++double -1 +++x2 -1 +++= -1 +++FastMath.scalb(v2.x, -1 +++deltaExp); -1 ++++ -1 +++final -1 +++double -1 +++y2 -1 +++= -1 +++FastMath.scalb(v2.y, -1 +++deltaExp); -1 ++++ -1 +++final -1 +++double -1 +++z2 -1 +++= -1 +++FastMath.scalb(v2.z, -1 +++deltaExp); -1 // -1 we -1 reduce -1 cancellation -1 errors -1 by -1 preconditioning, -1 // -1 we -1 replace -1 v1 -1 by -1 v3 -1 = -1 v1 -1 - -1 rho -1 v2 -1 with -1 rho -1 chosen -1 in -1 order -1 to -1 compute -1 @@ -1 -467,10 -1 +479,15 -1 @@ -1 public -1 static -1 Vector3D -1 crossProduct(final -1 Vector3D -1 v1, -1 final -1 Vector3D -1 v2) -1 { -1 // -1 available -1 at -1 http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf -1 // -1 compute -1 rho -1 as -1 an -1 8 -1 bits -1 approximation -1 of -1 v1.v2 -1 / -1 v2.v2 -1 ++++ -1 +++final -1 +++double -1 +++ratio -1 +++= -1 +++(x1 -1 +++* -1 +++x2 -1 ++++ -1 +++y1 -1 +++* -1 +++y2 -1 ++++ -1 +++z1 -1 +++* -1 +++z2) -1 +++/ -1 +++FastMath.scalb(n2, -1 +++2 -1 +++* -1 +++deltaExp); -1 ++++ -1 +++final -1 +++double -1 +++rho -1 +++= -1 +++FastMath.rint(256 -1 +++* -1 +++ratio) -1 +++/ -1 +++256; -1 ++++ -1 +++final -1 +++double -1 +++x3 -1 +++= -1 +++x1 -1 +++- -1 +++rho -1 +++* -1 +++x2; -1 ++++ -1 +++final -1 +++double -1 +++y3 -1 +++= -1 +++y1 -1 +++- -1 +++rho -1 +++* -1 +++y2; -1 ++++ -1 +++final -1 +++double -1 +++z3 -1 +++= -1 +++z1 -1 +++- -1 +++rho -1 +++* -1 +++z2; -1 // -1 compute -1 cross -1 product -1 from -1 v3 -1 and -1 v2 -1 instead -1 of -1 v1 -1 and -1 v2 -1 ---- -1 ---return -1 ---new -1 ---Vector3D(v1.y -1 ---* -1 ---v2.z -1 ---- -1 ---v1.z -1 ---* -1 ---v2.y, -1 ---v1.z -1 ---* -1 ---v2.x -1 ---- -1 ---v1.x -1 ---* -1 ---v2.z, -1 ---v1.x -1 ---* -1 ---v2.y -1 ---- -1 ---v1.y -1 ---* -1 ---v2.x); -1 ++++ -1 +++return -1 +++new -1 +++Vector3D(y3 -1 +++* -1 +++z2 -1 +++- -1 +++z3 -1 +++* -1 +++y2, -1 +++z3 -1 +++* -1 +++x2 -1 +++- -1 +++x3 -1 +++* -1 +++z2, -1 +++x3 -1 +++* -1 +++y2 -1 +++- -1 +++y3 -1 +++* -1 +++x2); -1 } -1 -2
public -1 double -1 density(double -1 x) -1 { -1 */ -1 public -1 double -1 cumulativeProbability(double -1 x) -1 throws -1 MathException -1 { -1 final -1 double -1 dev -1 = -1 x -1 - -1 mean; -1 ---- -1 ---try -1 ---{ -1 ++++ -1 +++if -1 +++(FastMath.abs(dev) -1 +++> -1 +++40 -1 +++* -1 +++standardDeviation) -1 +++{ -1 ++++ -1 +++return -1 +++dev -1 +++< -1 +++0 -1 +++? -1 +++0.0d -1 +++: -1 +++1.0d; -1 ++++ -1 +++} -1 return -1 0.5 -1 * -1 (1.0 -1 + -1 Erf.erf((dev) -1 / -1 (standardDeviation -1 * -1 FastMath.sqrt(2.0)))); -1 ---- -1 ---} -1 ---catch -1 ---(MaxIterationsExceededException -1 ---ex) -1 ---{ -1 ---- -1 ---if -1 ---(x -1 ---< -1 ---(mean -1 ---- -1 ---20 -1 ---* -1 ---standardDeviation)) -1 ---{ -1 ---// -1 ---JDK -1 ---1.5 -1 ---blows -1 ---at -1 ---38 -1 ---- -1 ---return -1 ---0; -1 ---- -1 ---} -1 ---else -1 ---if -1 ---(x -1 ---> -1 ---(mean -1 ---+ -1 ---20 -1 ---* -1 ---standardDeviation)) -1 ---{ -1 ---- -1 ---return -1 ---1; -1 ---- -1 ---} -1 ---else -1 ---{ -1 ---- -1 ---throw -1 ---ex; -1 ---- -1 ---} -1 ---- -1 ---} -1 } -1 /** -1 -2
protected -1 Dfp(final -1 DfpField -1 field, -1 double -1 x) -1 { -1 // -1 Zero -1 or -1 sub-normal -1 if -1 (x -1 == -1 0) -1 { -1 // -1 make -1 sure -1 0 -1 has -1 the -1 right -1 sign -1 ++++ -1 +++if -1 +++((bits -1 +++& -1 +++0x8000000000000000L) -1 +++!= -1 +++0) -1 +++{ -1 ++++ -1 +++sign -1 +++= -1 +++-1; -1 ++++ -1 +++} -1 return; -1 } -1 @@ -1 -2316,7 -1 +2319,10 -1 @@ -1 public -1 double -1 toDouble() -1 { -1 Dfp -1 y -1 = -1 this; -1 boolean -1 negate -1 = -1 false; -1 ---- -1 ---if -1 ---(lessThan(getZero())) -1 ---{ -1 ++++ -1 +++int -1 +++cmp0 -1 +++= -1 +++compare(this, -1 +++getZero()); -1 ++++ -1 +++if -1 +++(cmp0 -1 +++== -1 +++0) -1 +++{ -1 ++++ -1 +++return -1 +++sign -1 +++< -1 +++0 -1 +++? -1 +++-0.0 -1 +++: -1 ++++0.0; -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(cmp0 -1 +++< -1 +++0) -1 +++{ -1 y -1 = -1 negate(); -1 negate -1 = -1 true; -1 } -1 -2
public -1 int -1 getDimension() -1 { -1 indices[i] -1 = -1 idx; -1 } -1 ---- -1 ---int -1 ---idx -1 ---= -1 ---1; -1 ---- -1 ---while -1 ---(count -1 ---< -1 ---index) -1 ---{ -1 ---- -1 ---count -1 ---+= -1 ---idx; -1 ---- -1 ---++idx; -1 ---- -1 ---} -1 ---- -1 -----idx; -1 ---- -1 ---indices[last] -1 ---= -1 ---idx; -1 ++++ -1 +++indices[last] -1 +++= -1 +++index -1 +++- -1 +++count; -1 return -1 indices; -1 } -1 -2
public -1 Rotation(Vector3D -1 u1, -1 Vector3D -1 u2, -1 Vector3D -1 v1, -1 Vector3D -1 v2) -1 { -1 Vector3D -1 k -1 = -1 v1Su1.crossProduct(v2Su2); -1 Vector3D -1 u3 -1 = -1 u1.crossProduct(u2); -1 double -1 c -1 = -1 k.dotProduct(u3); -1 ---- -1 ---if -1 ---(c -1 ---== -1 ---0) -1 ---{ -1 ++++ -1 +++final -1 +++double -1 +++inPlaneThreshold -1 +++= -1 +++0.001; -1 ++++ -1 +++if -1 +++(c -1 +++<= -1 +++inPlaneThreshold -1 +++* -1 +++k.getNorm() -1 +++* -1 +++u3.getNorm()) -1 +++{ -1 // -1 the -1 (q1, -1 q2, -1 q3) -1 vector -1 is -1 close -1 to -1 the -1 (u1, -1 u2) -1 plane -1 // -1 we -1 try -1 other -1 vectors -1 Vector3D -1 v3 -1 = -1 Vector3D.crossProduct(v1, -1 v2); -1 @@ -1 -350,13 -1 +351,13 -1 @@ -1 public -1 Rotation(Vector3D -1 u1, -1 Vector3D -1 u2, -1 Vector3D -1 v1, -1 Vector3D -1 v2) -1 { -1 Vector3D -1 u2Prime -1 = -1 u1.crossProduct(u3); -1 c -1 = -1 k.dotProduct(u2Prime); -1 ---- -1 ---if -1 ---(c -1 ---== -1 ---0) -1 ---{ -1 ++++ -1 +++if -1 +++(c -1 +++<= -1 +++inPlaneThreshold -1 +++* -1 +++k.getNorm() -1 +++* -1 +++u2Prime.getNorm()) -1 +++{ -1 // -1 the -1 (q1, -1 q2, -1 q3) -1 vector -1 is -1 also -1 close -1 to -1 the -1 (u1, -1 u3) -1 plane, -1 // -1 it -1 is -1 almost -1 aligned -1 with -1 u1: -1 we -1 try -1 (u2, -1 u3) -1 and -1 (v2, -1 v3) -1 k -1 = -1 v2Su2.crossProduct(v3Su3);; -1 c -1 = -1 k.dotProduct(u2.crossProduct(u3));; -1 ---- -1 ---if -1 ---(c -1 ---== -1 ---0) -1 ---{ -1 ++++ -1 +++if -1 +++(c -1 +++<= -1 +++0) -1 +++{ -1 // -1 the -1 (q1, -1 q2, -1 q3) -1 vector -1 is -1 aligned -1 with -1 everything -1 // -1 this -1 is -1 really -1 the -1 identity -1 rotation -1 q0 -1 = -1 1.0; -1 -2
public -1 static -1 double -1 cosh(double -1 x) -1 { -1 * -1 @return -1 {@code -1 true} -1 if -1 the -1 values -1 are -1 equal. -1 */ -1 public -1 static -1 boolean -1 equals(double -1 x, -1 double -1 y) -1 { -1 ---- -1 ---return -1 ---(Double.isNaN(x) -1 ---&& -1 ---Double.isNaN(y)) -1 ---|| -1 ---x -1 ---== -1 ---y; -1 ++++ -1 +++return -1 +++equals(x, -1 +++y, -1 +++1); -1 } -1 /** -1 -2
public -1 UnivariateRealPointValuePair -1 optimize(final -1 FUNC -1 f, -1 final -1 GoalType -1 goal, -1 final -1 double -1 min, -1 final -1 double -1 max) -1 throws -1 FunctionEvaluationException -1 { -1 ---- -1 ---return -1 ---optimize(f, -1 ---goal, -1 ---min, -1 ---max, -1 ---0); -1 ++++ -1 +++return -1 +++optimize(f, -1 +++goal, -1 +++min, -1 +++max, -1 +++min -1 ++++ -1 +++0.5 -1 +++* -1 +++(max -1 +++- -1 +++min)); -1 } -1 /** -1 {@inheritDoc} -1 */ -1 @@ -1 -157,9 -1 +157,8 -1 @@ -1 public -1 UnivariateRealPointValuePair -1 optimize(final -1 FUNC -1 f, -1 final -1 GoalType -1 goal, -1 // -1 Multi-start -1 loop. -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 starts; -1 ++i) -1 { -1 try -1 { -1 ---- -1 ---final -1 ---double -1 ---bound1 -1 ---= -1 ---(i -1 ---== -1 ---0) -1 ---? -1 ---min -1 ---: -1 ---min -1 ---+ -1 ---generator.nextDouble() -1 ---* -1 ---(max -1 ---- -1 ---min); -1 ---- -1 ---final -1 ---double -1 ---bound2 -1 ---= -1 ---(i -1 ---== -1 ---0) -1 ---? -1 ---max -1 ---: -1 ---min -1 ---+ -1 ---generator.nextDouble() -1 ---* -1 ---(max -1 ---- -1 ---min); -1 ---- -1 ---optima[i] -1 ---= -1 ---optimizer.optimize(f, -1 ---goal, -1 ---FastMath.min(bound1, -1 ---bound2), -1 ---FastMath.max(bound1, -1 ---bound2)); -1 ++++ -1 +++final -1 +++double -1 +++s -1 +++= -1 +++(i -1 +++== -1 +++0) -1 +++? -1 +++startValue -1 +++: -1 +++min -1 ++++ -1 +++generator.nextDouble() -1 +++* -1 +++(max -1 +++- -1 +++min); -1 ++++ -1 +++optima[i] -1 +++= -1 +++optimizer.optimize(f, -1 +++goal, -1 +++min, -1 +++max, -1 +++s); -1 } -1 catch -1 (FunctionEvaluationException -1 fee) -1 { -1 optima[i] -1 = -1 null; -1 } -1 catch -1 (ConvergenceException -1 ce) -1 { -1 -2
* -1 Construct -1 a -1 solver. -1 */ -1 public -1 BrentOptimizer() -1 { -1 ---- -1 ---setMaxEvaluations(Integer.MAX_VALUE); -1 ++++ -1 +++setMaxEvaluations(1000); -1 setMaximalIterationCount(100); -1 ---- -1 ---setAbsoluteAccuracy(1E-10); -1 ---- -1 ---setRelativeAccuracy(1.0e-14); -1 ++++ -1 +++setAbsoluteAccuracy(1e-11); -1 ++++ -1 +++setRelativeAccuracy(1e-9); -1 } -1 /** -1 @@ -1 -54,17 -1 +54,10 -1 @@ -1 public -1 BrentOptimizer() -1 { -1 */ -1 protected -1 double -1 doOptimize() -1 throws -1 MaxIterationsExceededException, -1 FunctionEvaluationException -1 { -1 ---- -1 ---throw -1 ---new -1 ---UnsupportedOperationException(); -1 ---- -1 ---} -1 ---- -1 ---public -1 ---double -1 ---optimize(final -1 ---UnivariateRealFunction -1 ---f, -1 ---final -1 ---GoalType -1 ---goalType, -1 ---final -1 ---double -1 ---min, -1 ---final -1 ---double -1 ---max, -1 ---final -1 ---double -1 ---startValue) -1 ---throws -1 ---MaxIterationsExceededException, -1 ---FunctionEvaluationException -1 ---{ -1 ---- -1 ---clearResult(); -1 return -1 localMin(getGoalType() -1 == -1 GoalType.MINIMIZE, -1 ---- -1 ---f, -1 ---goalType, -1 ---min, -1 ---startValue, -1 ---max, -1 ++++ -1 +++getMin(), -1 +++getStartValue(), -1 +++getMax(), -1 getRelativeAccuracy(), -1 getAbsoluteAccuracy()); -1 } -1 ---- -1 ---public -1 ---double -1 ---optimize(final -1 ---UnivariateRealFunction -1 ---f, -1 ---final -1 ---GoalType -1 ---goalType, -1 ---final -1 ---double -1 ---min, -1 ---final -1 ---double -1 ---max) -1 ---throws -1 ---MaxIterationsExceededException, -1 ---FunctionEvaluationException -1 ---{ -1 ---- -1 ---return -1 ---optimize(f, -1 ---goalType, -1 ---min, -1 ---max, -1 ---min -1 ---+ -1 ---GOLDEN_SECTION -1 ---* -1 ---(max -1 ---- -1 ---min)); -1 ---- -1 ---} -1 /** -1 * -1 Find -1 the -1 minimum -1 of -1 the -1 function -1 within -1 the -1 interval -1 {@code -1 (lo, -1 hi)}. -1 @@ -1 -91,8 -1 +84,6 -1 @@ -1 public -1 double -1 optimize(final -1 UnivariateRealFunction -1 f, -1 final -1 GoalType -1 goalType, -1 * -1 the -1 function. -1 */ -1 private -1 double -1 localMin(boolean -1 isMinim, -1 ---- -1 ---UnivariateRealFunction -1 ---f, -1 ---- -1 ---GoalType -1 ---goalType, -1 double -1 lo, -1 double -1 mid, -1 double -1 hi, -1 double -1 eps, -1 double -1 t) -1 throws -1 MaxIterationsExceededException, -1 FunctionEvaluationException -1 { -1 @@ -1 -116,15 -1 +107,14 -1 @@ -1 private -1 double -1 localMin(boolean -1 isMinim, -1 double -1 w -1 = -1 x; -1 double -1 d -1 = -1 0; -1 double -1 e -1 = -1 0; -1 ---- -1 ---double -1 ---fx -1 ---= -1 ---computeObjectiveValue(f, -1 ---x); -1 ---- -1 ---if -1 ---(goalType -1 ---== -1 ---GoalType.MAXIMIZE) -1 ---{ -1 ++++ -1 +++double -1 +++fx -1 +++= -1 +++computeObjectiveValue(x); -1 ++++ -1 +++if -1 +++(!isMinim) -1 +++{ -1 fx -1 = -1 -fx; -1 } -1 double -1 fv -1 = -1 fx; -1 double -1 fw -1 = -1 fx; -1 ---- -1 ---int -1 ---count -1 ---= -1 ---0; -1 ---- -1 ---while -1 ---(count -1 ---< -1 ---maximalIterationCount) -1 ---{ -1 ++++ -1 +++while -1 +++(true) -1 +++{ -1 double -1 m -1 = -1 0.5 -1 * -1 (a -1 + -1 b); -1 final -1 double -1 tol1 -1 = -1 eps -1 * -1 Math.abs(x) -1 + -1 t; -1 final -1 double -1 tol2 -1 = -1 2 -1 * -1 tol1; -1 @@ -1 -197,8 -1 +187,8 -1 @@ -1 private -1 double -1 localMin(boolean -1 isMinim, -1 u -1 = -1 x -1 + -1 d; -1 } -1 ---- -1 ---double -1 ---fu -1 ---= -1 ---computeObjectiveValue(f, -1 ---u); -1 ---- -1 ---if -1 ---(goalType -1 ---== -1 ---GoalType.MAXIMIZE) -1 ---{ -1 ++++ -1 +++double -1 +++fu -1 +++= -1 +++computeObjectiveValue(u); -1 ++++ -1 +++if -1 +++(!isMinim) -1 +++{ -1 fu -1 = -1 -fu; -1 } -1 @@ -1 -235,11 -1 +225,10 -1 @@ -1 private -1 double -1 localMin(boolean -1 isMinim, -1 } -1 } -1 } -1 else -1 { -1 // -1 termination -1 ---- -1 ---setResult(x, -1 ---(goalType -1 ---== -1 ---GoalType.MAXIMIZE) -1 ---? -1 ----fx -1 ---: -1 ---fx, -1 ---count); -1 ++++ -1 +++setFunctionValue(isMinim -1 +++? -1 +++fx -1 +++: -1 +++-fx); -1 return -1 x; -1 } -1 ---- -1 ---++count; -1 ++++ -1 +++incrementIterationsCounter(); -1 } -1 ---- -1 ---throw -1 ---new -1 ---MaxIterationsExceededException(maximalIterationCount); -1 } -1 } -1 -2
protected -1 void -1 updateResidualsAndCost() -1 public -1 double -1 getRMS() -1 { -1 ---- -1 ---double -1 ---criterion -1 ---= -1 ---0; -1 ---- -1 ---for -1 ---(int -1 ---i -1 ---= -1 ---0; -1 ---i -1 ---< -1 ---rows; -1 ---++i) -1 ---{ -1 ---- -1 ---final -1 ---double -1 ---residual -1 ---= -1 ---residuals[i]; -1 ---- -1 ---criterion -1 ---+= -1 ---residual -1 ---* -1 ---residual -1 ---* -1 ---residualsWeights[i]; -1 ---- -1 ---} -1 ---- -1 ---return -1 ---Math.sqrt(criterion -1 ---/ -1 ---rows); -1 ++++ -1 +++return -1 +++Math.sqrt(getChiSquare() -1 +++/ -1 +++rows); -1 } -1 /** -1 * -1 Get -1 a -1 Chi-Square-like -1 value -1 assuming -1 the -1 N -1 residuals -1 follow -1 N -1 * -1 distinct -1 normal -1 distributions -1 centered -1 on -1 0 -1 and -1 whose -1 variances -1 are -1 * -1 the -1 reciprocal -1 of -1 the -1 weights. -1 * -1 @return -1 chi-square -1 value -1 */ -1 public -1 double -1 getChiSquare() -1 { -1 double -1 chiSquare -1 = -1 0; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 rows; -1 ++i) -1 { -1 final -1 double -1 residual -1 = -1 residuals[i]; -1 ---- -1 ---chiSquare -1 ---+= -1 ---residual -1 ---* -1 ---residual -1 ---/ -1 ---residualsWeights[i]; -1 ++++ -1 +++chiSquare -1 ++++= -1 +++residual -1 +++* -1 +++residual -1 +++* -1 +++residualsWeights[i]; -1 } -1 return -1 chiSquare; -1 } -1 /** -1 * -1 Get -1 the -1 covariance -1 matrix -1 of -1 optimized -1 parameters. -1 * -1 @return -1 covariance -1 matrix -1 * -1 @exception -1 FunctionEvaluationException -1 if -1 the -1 function -1 jacobian -1 cannot -1 * -1 be -1 evaluated -1 * -1 @exception -1 OptimizationException -1 if -1 the -1 covariance -1 matrix -1 -2
protected -1 VectorialPointValuePair -1 doOptimize() -1 double[] -1 diag -1 = -1 new -1 double[cols]; -1 double[] -1 oldX -1 = -1 new -1 double[cols]; -1 double[] -1 oldRes -1 = -1 new -1 double[rows]; -1 ++++ -1 +++double[] -1 +++oldObj -1 +++= -1 +++new -1 +++double[rows]; -1 ++++ -1 +++double[] -1 +++qtf -1 +++= -1 +++new -1 +++double[rows]; -1 double[] -1 work1 -1 = -1 new -1 double[cols]; -1 double[] -1 work2 -1 = -1 new -1 double[cols]; -1 double[] -1 work3 -1 = -1 new -1 double[cols]; -1 @@ -1 -267,6 -1 +269,9 -1 @@ -1 protected -1 VectorialPointValuePair -1 doOptimize() -1 boolean -1 firstIteration -1 = -1 true; -1 VectorialPointValuePair -1 current -1 = -1 new -1 VectorialPointValuePair(point, -1 objective); -1 while -1 (true) -1 { -1 ++++ -1 +++for -1 +++(int -1 +++i=0;i<rows;i++) -1 +++{ -1 ++++ -1 +++qtf[i]=residuals[i]; -1 ++++ -1 +++} -1 incrementIterationsCounter(); -1 // -1 compute -1 the -1 Q.R. -1 decomposition -1 of -1 the -1 jacobian -1 matrix -1 @@ -1 -275,7 -1 +280,7 -1 @@ -1 protected -1 VectorialPointValuePair -1 doOptimize() -1 qrDecomposition(); -1 // -1 compute -1 Qt.res -1 ---- -1 ---qTy(residuals); -1 ++++ -1 +++qTy(qtf); -1 // -1 now -1 we -1 don't -1 need -1 Q -1 anymore, -1 // -1 so -1 let -1 jacobian -1 contain -1 the -1 R -1 matrix -1 with -1 its -1 diagonal -1 elements -1 for -1 (int -1 k -1 = -1 0; -1 k -1 < -1 solvedCols; -1 ++k) -1 { -1 @@ -1 -313,7 -1 +318,7 -1 @@ -1 protected -1 VectorialPointValuePair -1 doOptimize() -1 if -1 (s -1 != -1 0) -1 { -1 double -1 sum -1 = -1 0; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 <= -1 j; -1 ++i) -1 { -1 ---- -1 ---sum -1 ---+= -1 ---jacobian[i][pj] -1 ---* -1 ---residuals[i]; -1 ++++ -1 +++sum -1 ++++= -1 +++jacobian[i][pj] -1 +++* -1 +++qtf[i]; -1 } -1 maxCosine -1 = -1 Math.max(maxCosine, -1 Math.abs(sum) -1 / -1 (s -1 * -1 cost)); -1 } -1 @@ -1 -321,6 -1 +326,8 -1 @@ -1 protected -1 VectorialPointValuePair -1 doOptimize() -1 } -1 if -1 (maxCosine -1 <= -1 orthoTolerance) -1 { -1 // -1 convergence -1 has -1 been -1 reached -1 ++++ -1 +++updateResidualsAndCost(); -1 ++++ -1 +++current -1 +++= -1 +++new -1 +++VectorialPointValuePair(point, -1 +++objective); -1 return -1 current; -1 } -1 @@ -1 -341,9 -1 +348,12 -1 @@ -1 protected -1 VectorialPointValuePair -1 doOptimize() -1 double[] -1 tmpVec -1 = -1 residuals; -1 residuals -1 = -1 oldRes; -1 oldRes -1 = -1 tmpVec; -1 ++++ -1 +++tmpVec -1 +++= -1 +++objective; -1 ++++ -1 +++objective -1 +++= -1 +++oldObj; -1 ++++ -1 +++oldObj -1 +++= -1 +++tmpVec; -1 // -1 determine -1 the -1 Levenberg-Marquardt -1 parameter -1 ---- -1 ---determineLMParameter(oldRes, -1 ---delta, -1 ---diag, -1 ---work1, -1 ---work2, -1 ---work3); -1 ++++ -1 +++determineLMParameter(qtf, -1 +++delta, -1 +++diag, -1 +++work1, -1 +++work2, -1 +++work3); -1 // -1 compute -1 the -1 new -1 point -1 and -1 the -1 norm -1 of -1 the -1 evolution -1 direction -1 double -1 lmNorm -1 = -1 0; -1 @@ -1 -362,7 -1 +372,6 -1 @@ -1 protected -1 VectorialPointValuePair -1 doOptimize() -1 // -1 evaluate -1 the -1 function -1 at -1 x -1 + -1 p -1 and -1 calculate -1 its -1 norm -1 updateResidualsAndCost(); -1 ---- -1 ---current -1 ---= -1 ---new -1 ---VectorialPointValuePair(point, -1 ---objective); -1 // -1 compute -1 the -1 scaled -1 actual -1 reduction -1 double -1 actRed -1 = -1 -1.0; -1 @@ -1 -418,9 -1 +427,15 -1 @@ -1 protected -1 VectorialPointValuePair -1 doOptimize() -1 xNorm -1 += -1 xK -1 * -1 xK; -1 } -1 xNorm -1 = -1 Math.sqrt(xNorm); -1 ++++ -1 +++current -1 +++= -1 +++new -1 +++VectorialPointValuePair(point, -1 +++objective); -1 // -1 tests -1 for -1 convergence. -1 ++++ -1 +++if -1 +++(checker -1 +++!= -1 +++null) -1 +++{ -1 // -1 we -1 use -1 the -1 vectorial -1 convergence -1 checker -1 ++++ -1 +++if -1 +++(checker.converged(getIterations(), -1 +++previous, -1 +++current)) -1 +++{ -1 ++++ -1 +++return -1 +++current; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 } -1 else -1 { -1 // -1 failed -1 iteration, -1 reset -1 the -1 previous -1 values -1 cost -1 = -1 previousCost; -1 @@ -1 -431,6 -1 +446,9 -1 @@ -1 protected -1 VectorialPointValuePair -1 doOptimize() -1 tmpVec -1 = -1 residuals; -1 residuals -1 = -1 oldRes; -1 oldRes -1 = -1 tmpVec; -1 ++++ -1 +++tmpVec -1 +++= -1 +++objective; -1 ++++ -1 +++objective -1 +++= -1 +++oldObj; -1 ++++ -1 +++oldObj -1 +++= -1 +++tmpVec; -1 } -1 if -1 (checker==null) -1 { -1 if -1 (((Math.abs(actRed) -1 <= -1 costRelativeTolerance) -1 && -1 @@ -1 -439,10 -1 +457,6 -1 @@ -1 protected -1 VectorialPointValuePair -1 doOptimize() -1 (delta -1 <= -1 parRelativeTolerance -1 * -1 xNorm)) -1 { -1 return -1 current; -1 } -1 ---- -1 ---} -1 ---else -1 ---{ -1 ---- -1 ---if -1 ---(checker.converged(getIterations(), -1 ---previous, -1 ---current)) -1 ---{ -1 ---- -1 ---return -1 ---current; -1 ---- -1 ---} -1 } -1 // -1 tests -1 for -1 termination -1 and -1 stringent -1 tolerances -1 // -1 (2.2204e-16 -1 is -1 the -1 machine -1 epsilon -1 for -1 IEEE754) -1 -2
public -1 double -1 solve(double -1 min, -1 double -1 max) -1 /** -1 {@inheritDoc} -1 */ -1 public -1 double -1 solve(final -1 UnivariateRealFunction -1 f, -1 double -1 min, -1 double -1 max, -1 double -1 initial) -1 throws -1 MaxIterationsExceededException, -1 FunctionEvaluationException -1 { -1 ---- -1 ---return -1 ---solve(min, -1 ---max); -1 ++++ -1 +++return -1 +++solve(f, -1 +++min, -1 +++max); -1 } -1 /** -1 {@inheritDoc} -1 */ -1 -2
public -1 LevenbergMarquardtOptimizer() -1 { -1 setMaxIterations(1000); -1 // -1 default -1 values -1 for -1 the -1 tuning -1 parameters -1 ++++ -1 +++setConvergenceChecker(null); -1 setInitialStepBoundFactor(100.0); -1 setCostRelativeTolerance(1.0e-10); -1 setParRelativeTolerance(1.0e-10); -1 @@ -1 -244,11 -1 +245,13 -1 @@ -1 protected -1 VectorialPointValuePair -1 doOptimize() -1 // -1 outer -1 loop -1 lmPar -1 = -1 0; -1 boolean -1 firstIteration -1 = -1 true; -1 ++++ -1 +++VectorialPointValuePair -1 +++current -1 +++= -1 +++new -1 +++VectorialPointValuePair(point, -1 +++objective); -1 while -1 (true) -1 { -1 incrementIterationsCounter(); -1 // -1 compute -1 the -1 Q.R. -1 decomposition -1 of -1 the -1 jacobian -1 matrix -1 ++++ -1 +++VectorialPointValuePair -1 +++previous -1 +++= -1 +++current; -1 updateJacobian(); -1 qrDecomposition(); -1 @@ -1 -300,7 -1 +303,7 -1 @@ -1 protected -1 VectorialPointValuePair -1 doOptimize() -1 } -1 if -1 (maxCosine -1 <= -1 orthoTolerance) -1 { -1 // -1 convergence -1 has -1 been -1 reached -1 ---- -1 ---return -1 ---new -1 ---VectorialPointValuePair(point, -1 ---objective); -1 ++++ -1 +++return -1 +++current; -1 } -1 // -1 rescale -1 if -1 necessary -1 @@ -1 -342,6 -1 +345,7 -1 @@ -1 protected -1 VectorialPointValuePair -1 doOptimize() -1 // -1 evaluate -1 the -1 function -1 at -1 x -1 + -1 p -1 and -1 calculate -1 its -1 norm -1 updateResidualsAndCost(); -1 ++++ -1 +++current -1 +++= -1 +++new -1 +++VectorialPointValuePair(point, -1 +++objective); -1 // -1 compute -1 the -1 scaled -1 actual -1 reduction -1 double -1 actRed -1 = -1 -1.0; -1 @@ -1 -410,14 -1 +414,20 -1 @@ -1 protected -1 VectorialPointValuePair -1 doOptimize() -1 } -1 // -1 tests -1 for -1 convergence. -1 ++++ -1 +++if -1 +++(checker -1 +++!= -1 +++null) -1 +++{ -1 // -1 we -1 use -1 the -1 vectorial -1 convergence -1 checker -1 ++++ -1 +++if -1 +++(checker.converged(getIterations(), -1 +++previous, -1 +++current)) -1 +++{ -1 ++++ -1 +++return -1 +++current; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 +++else -1 +++{ -1 // -1 we -1 use -1 the -1 Levenberg-Marquardt -1 specific -1 convergence -1 parameters -1 if -1 (((Math.abs(actRed) -1 <= -1 costRelativeTolerance) -1 && -1 (preRed -1 <= -1 costRelativeTolerance) -1 && -1 (ratio -1 <= -1 2.0)) -1 || -1 (delta -1 <= -1 parRelativeTolerance -1 * -1 xNorm)) -1 { -1 ---- -1 ---return -1 ---new -1 ---VectorialPointValuePair(point, -1 ---objective); -1 ++++ -1 +++return -1 +++current; -1 } -1 ++++ -1 +++} -1 // -1 tests -1 for -1 termination -1 and -1 stringent -1 tolerances -1 // -1 (2.2204e-16 -1 is -1 the -1 machine -1 epsilon -1 for -1 IEEE754) -1 -2
public -1 RealMatrix -1 getCorrelationPValues() -1 throws -1 MathException -1 { -1 } -1 else -1 { -1 double -1 r -1 = -1 correlationMatrix.getEntry(i, -1 j); -1 double -1 t -1 = -1 Math.abs(r -1 * -1 Math.sqrt((nObs -1 - -1 2)/(1 -1 - -1 r -1 * -1 r))); -1 ---- -1 ---out[i][j] -1 ---= -1 ---2 -1 ---* -1 ---(1 -1 ---- -1 ---tDistribution.cumulativeProbability(t)); -1 ++++ -1 +++out[i][j] -1 +++= -1 +++2 -1 +++* -1 +++tDistribution.cumulativeProbability(-t); -1 } -1 } -1 } -1 -2
public -1 double -1 integrate(final -1 FirstOrderDifferentialEquations -1 equations, -1 // -1 it -1 is -1 so -1 small -1 (much -1 probably -1 exactly -1 0 -1 due -1 to -1 limited -1 accuracy) -1 // -1 that -1 the -1 code -1 above -1 would -1 fail -1 handling -1 it. -1 // -1 So -1 we -1 set -1 up -1 an -1 artificial -1 0 -1 size -1 step -1 by -1 copying -1 states -1 ++++ -1 +++interpolator.storeTime(stepStart); -1 ++++ -1 +++System.arraycopy(y, -1 +++0, -1 +++yTmp, -1 +++0, -1 +++y0.length); -1 ++++ -1 +++hNew -1 +++= -1 +++0; -1 ++++ -1 +++stepSize -1 +++= -1 +++0; -1 loop -1 = -1 false; -1 } -1 else -1 { -1 // -1 reject -1 the -1 step -1 to -1 match -1 exactly -1 the -1 next -1 switch -1 time -1 ------ -1 ---a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java -1 ++++++ -1 +++b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java -1 @@ -1 -177,6 -1 +177,9 -1 @@ -1 public -1 double -1 integrate(final -1 FirstOrderDifferentialEquations -1 equations, -1 // -1 it -1 is -1 so -1 small -1 (much -1 probably -1 exactly -1 0 -1 due -1 to -1 limited -1 accuracy) -1 // -1 that -1 the -1 code -1 above -1 would -1 fail -1 handling -1 it. -1 // -1 So -1 we -1 set -1 up -1 an -1 artificial -1 0 -1 size -1 step -1 by -1 copying -1 states -1 ++++ -1 +++interpolator.storeTime(stepStart); -1 ++++ -1 +++System.arraycopy(y, -1 +++0, -1 +++yTmp, -1 +++0, -1 +++y0.length); -1 ++++ -1 +++stepSize -1 +++= -1 +++0; -1 loop -1 = -1 false; -1 } -1 else -1 { -1 // -1 reject -1 the -1 step -1 to -1 match -1 exactly -1 the -1 next -1 switch -1 time -1 -2
public -1 double -1 solve(final -1 UnivariateRealFunction -1 f, -1 // -1 return -1 the -1 first -1 endpoint -1 if -1 it -1 is -1 good -1 enough -1 double -1 yMin -1 = -1 f.value(min); -1 if -1 (Math.abs(yMin) -1 <= -1 functionValueAccuracy) -1 { -1 ---- -1 ---setResult(yMin, -1 ---0); -1 ++++ -1 +++setResult(min, -1 +++0); -1 return -1 result; -1 } -1 @@ -1 -124,7 -1 +124,7 -1 @@ -1 public -1 double -1 solve(final -1 UnivariateRealFunction -1 f, -1 // -1 return -1 the -1 second -1 endpoint -1 if -1 it -1 is -1 good -1 enough -1 double -1 yMax -1 = -1 f.value(max); -1 if -1 (Math.abs(yMax) -1 <= -1 functionValueAccuracy) -1 { -1 ---- -1 ---setResult(yMax, -1 ---0); -1 ++++ -1 +++setResult(max, -1 +++0); -1 return -1 result; -1 } -1 -2
public -1 MultiStartUnivariateRealOptimizer(final -1 UnivariateRealOptimizer -1 optimizer -1 /** -1 {@inheritDoc} -1 */ -1 public -1 double -1 getFunctionValue() -1 { -1 ---- -1 ---return -1 ---optimizer.getFunctionValue(); -1 ++++ -1 +++return -1 +++optimaValues[0]; -1 } -1 /** -1 {@inheritDoc} -1 */ -1 public -1 double -1 getResult() -1 { -1 ---- -1 ---return -1 ---optimizer.getResult(); -1 ++++ -1 +++return -1 +++optima[0]; -1 } -1 /** -1 {@inheritDoc} -1 */ -1 -2
public -1 double -1 solve(final -1 UnivariateRealFunction -1 f, -1 return -1 solve(f, -1 initial, -1 yInitial, -1 max, -1 yMax, -1 initial, -1 yInitial); -1 } -1 ++++ -1 +++if -1 +++(yMin -1 +++* -1 +++yMax -1 +++> -1 +++0) -1 +++{ -1 ++++ -1 +++throw -1 +++MathRuntimeException.createIllegalArgumentException( -1 ++++ -1 +++NON_BRACKETING_MESSAGE, -1 +++min, -1 +++max, -1 +++yMin, -1 +++yMax); -1 ++++ -1 +++} -1 // -1 full -1 Brent -1 algorithm -1 starting -1 with -1 provided -1 initial -1 guess -1 return -1 solve(f, -1 min, -1 yMin, -1 max, -1 yMax, -1 initial, -1 yInitial); -1 -2
public -1 double -1 integrate(final -1 FirstOrderDifferentialEquations -1 equations, -1 } -1 if -1 (firstTime) -1 { -1 ---- -1 ---final -1 ---double[] -1 ---scale; -1 ++++ -1 +++final -1 +++double[] -1 +++scale -1 +++= -1 +++new -1 +++double[y0.length]; -1 if -1 (vecAbsoluteTolerance -1 == -1 null) -1 { -1 ---- -1 ---scale -1 ---= -1 ---new -1 ---double[y0.length]; -1 ---- -1 ---java.util.Arrays.fill(scale, -1 ---scalAbsoluteTolerance); -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++scale.length; -1 +++++i) -1 +++{ -1 ++++ -1 +++scale[i] -1 +++= -1 +++scalAbsoluteTolerance -1 ++++ -1 +++scalRelativeTolerance -1 +++* -1 +++Math.abs(y[i]); -1 ++++ -1 +++} -1 } -1 else -1 { -1 ---- -1 ---scale -1 ---= -1 ---vecAbsoluteTolerance; -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++scale.length; -1 +++++i) -1 +++{ -1 ++++ -1 +++scale[i] -1 +++= -1 +++vecAbsoluteTolerance[i] -1 ++++ -1 +++vecRelativeTolerance[i] -1 +++* -1 +++Math.abs(y[i]); -1 ++++ -1 +++} -1 } -1 hNew -1 = -1 initializeStep(equations, -1 forward, -1 getOrder(), -1 scale, -1 stepStart, -1 y, -1 yDotK[0], -1 yTmp, -1 yDotK[1]); -1 -2
public -1 long -1 getCount(char -1 v) -1 { -1 */ -1 @Deprecated -1 public -1 double -1 getPct(Object -1 v) -1 { -1 ---- -1 ---return -1 ---getCumPct((Comparable<?>) -1 ---v); -1 ++++ -1 +++return -1 +++getPct((Comparable<?>) -1 +++v); -1 } -1 /** -1 -2
public -1 double -1 getL1Norm() -1 { -1 public -1 double -1 getLInfNorm() -1 { -1 double -1 max -1 = -1 0; -1 for -1 (double -1 a -1 : -1 data) -1 { -1 ---- -1 ---max -1 ---+= -1 ---Math.max(max, -1 ---Math.abs(a)); -1 ++++ -1 +++max -1 +++= -1 +++Math.max(max, -1 +++Math.abs(a)); -1 } -1 return -1 max; -1 } -1 ------ -1 ---a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java -1 ++++++ -1 +++b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java -1 @@ -1 -495,15 -1 +495,6 -1 @@ -1 public -1 double -1 getL1Distance(double[] -1 v) -1 throws -1 IllegalArgumentException -1 { -1 return -1 max; -1 } -1 ---- -1 ---public -1 ---double -1 ---getLInfNorm() -1 ---{ -1 ---- -1 ---double -1 ---max -1 ---= -1 ---0; -1 ---- -1 ---Iterator -1 ---iter -1 ---= -1 ---entries.iterator(); -1 ---- -1 ---while -1 ---(iter.hasNext()) -1 ---{ -1 ---- -1 ---iter.advance(); -1 ---- -1 ---max -1 ---+= -1 ---iter.value(); -1 ---- -1 ---} -1 ---- -1 ---return -1 ---max; -1 ---- -1 ---} -1 /** -1 * -1 Optimized -1 method -1 to -1 compute -1 LInfDistance. -1 * -1 @param -1 v -1 The -1 vector -1 to -1 compute -1 from -1 -2
private -1 Integer -1 getPivotRow(final -1 int -1 col, -1 final -1 SimplexTableau -1 tableau) -1 { -1 for -1 (int -1 i -1 = -1 tableau.getNumObjectiveFunctions(); -1 i -1 < -1 tableau.getHeight(); -1 i++) -1 { -1 final -1 double -1 rhs -1 = -1 tableau.getEntry(i, -1 tableau.getWidth() -1 - -1 1); -1 final -1 double -1 entry -1 = -1 tableau.getEntry(i, -1 col); -1 ---- -1 ---if -1 ---(MathUtils.compareTo(entry, -1 ---0, -1 ---epsilon) -1 --->= -1 ---0) -1 ---{ -1 ++++ -1 +++if -1 +++(MathUtils.compareTo(entry, -1 +++0, -1 +++epsilon) -1 +++> -1 +++0) -1 +++{ -1 final -1 double -1 ratio -1 = -1 rhs -1 / -1 entry; -1 if -1 (ratio -1 < -1 minRatio) -1 { -1 minRatio -1 = -1 ratio; -1 -2
public -1 RealMatrix -1 getU() -1 if -1 (m -1 >= -1 n) -1 { -1 // -1 the -1 tridiagonal -1 matrix -1 is -1 Bt.B, -1 where -1 B -1 is -1 upper -1 bidiagonal -1 final -1 RealMatrix -1 e -1 = -1 ---- -1 ---eigenDecomposition.getV().getSubMatrix(0, -1 ---p -1 ---- -1 ---1, -1 ---0, -1 ---p -1 ---- -1 ---1); -1 ++++ -1 +++eigenDecomposition.getV().getSubMatrix(0, -1 +++n -1 +++- -1 +++1, -1 +++0, -1 +++p -1 +++- -1 +++1); -1 final -1 double[][] -1 eData -1 = -1 e.getData(); -1 final -1 double[][] -1 wData -1 = -1 new -1 double[m][p]; -1 double[] -1 ei1 -1 = -1 eData[0]; -1 ---- -1 ---for -1 ---(int -1 ---i -1 ---= -1 ---0; -1 ---i -1 ---< -1 ---p -1 ---- -1 ---1; -1 ---++i) -1 ---{ -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++p; -1 +++++i) -1 +++{ -1 // -1 compute -1 W -1 = -1 B.E.S^(-1) -1 where -1 E -1 is -1 the -1 eigenvectors -1 matrix -1 final -1 double -1 mi -1 = -1 mainBidiagonal[i]; -1 final -1 double[] -1 ei0 -1 = -1 ei1; -1 final -1 double[] -1 wi -1 = -1 wData[i]; -1 ++++ -1 +++if -1 +++(i -1 +++< -1 +++n -1 +++- -1 +++1) -1 +++{ -1 ei1 -1 = -1 eData[i -1 + -1 1]; -1 final -1 double -1 si -1 = -1 secondaryBidiagonal[i]; -1 for -1 (int -1 j -1 = -1 0; -1 j -1 < -1 p; -1 ++j) -1 { -1 wi[j] -1 = -1 (mi -1 * -1 ei0[j] -1 + -1 si -1 * -1 ei1[j]) -1 / -1 singularValues[j]; -1 } -1 ---- -1 ---} -1 ++++ -1 +++} -1 +++else -1 +++{ -1 for -1 (int -1 j -1 = -1 0; -1 j -1 < -1 p; -1 ++j) -1 { -1 ---- -1 ---wData[p -1 ---- -1 ---1][j] -1 ---= -1 ---ei1[j] -1 ---* -1 ---mainBidiagonal[p -1 ---- -1 ---1] -1 ---/ -1 ---singularValues[j]; -1 ++++ -1 +++wi[j] -1 +++= -1 +++mi -1 +++* -1 +++ei0[j] -1 +++/ -1 +++singularValues[j]; -1 } -1 ++++ -1 +++} -1 ++++ -1 +++} -1 for -1 (int -1 i -1 = -1 p; -1 i -1 < -1 m; -1 ++i) -1 { -1 wData[i] -1 = -1 new -1 double[p]; -1 @@ -1 -245,23 -1 +248,26 -1 @@ -1 public -1 RealMatrix -1 getV() -1 // -1 the -1 tridiagonal -1 matrix -1 is -1 B.Bt, -1 where -1 B -1 is -1 lower -1 bidiagonal -1 // -1 compute -1 W -1 = -1 Bt.E.S^(-1) -1 where -1 E -1 is -1 the -1 eigenvectors -1 matrix -1 final -1 RealMatrix -1 e -1 = -1 ---- -1 ---eigenDecomposition.getV().getSubMatrix(0, -1 ---p -1 ---- -1 ---1, -1 ---0, -1 ---p -1 ---- -1 ---1); -1 ++++ -1 +++eigenDecomposition.getV().getSubMatrix(0, -1 +++m -1 +++- -1 +++1, -1 +++0, -1 +++p -1 +++- -1 +++1); -1 final -1 double[][] -1 eData -1 = -1 e.getData(); -1 final -1 double[][] -1 wData -1 = -1 new -1 double[n][p]; -1 double[] -1 ei1 -1 = -1 eData[0]; -1 ---- -1 ---for -1 ---(int -1 ---i -1 ---= -1 ---0; -1 ---i -1 ---< -1 ---p -1 ---- -1 ---1; -1 ---++i) -1 ---{ -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++p; -1 +++++i) -1 +++{ -1 final -1 double -1 mi -1 = -1 mainBidiagonal[i]; -1 final -1 double[] -1 ei0 -1 = -1 ei1; -1 final -1 double[] -1 wi -1 = -1 wData[i]; -1 ++++ -1 +++if -1 +++(i -1 +++< -1 +++m -1 +++- -1 +++1) -1 +++{ -1 ei1 -1 = -1 eData[i -1 + -1 1]; -1 final -1 double -1 si -1 = -1 secondaryBidiagonal[i]; -1 for -1 (int -1 j -1 = -1 0; -1 j -1 < -1 p; -1 ++j) -1 { -1 wi[j] -1 = -1 (mi -1 * -1 ei0[j] -1 + -1 si -1 * -1 ei1[j]) -1 / -1 singularValues[j]; -1 } -1 ---- -1 ---} -1 ++++ -1 +++} -1 +++else -1 +++{ -1 for -1 (int -1 j -1 = -1 0; -1 j -1 < -1 p; -1 ++j) -1 { -1 ---- -1 ---wData[p -1 ---- -1 ---1][j] -1 ---= -1 ---ei1[j] -1 ---* -1 ---mainBidiagonal[p -1 ---- -1 ---1] -1 ---/ -1 ---singularValues[j]; -1 ++++ -1 +++wi[j] -1 +++= -1 +++mi -1 +++* -1 +++ei0[j] -1 +++/ -1 +++singularValues[j]; -1 } -1 ++++ -1 +++} -1 ++++ -1 +++} -1 for -1 (int -1 i -1 = -1 p; -1 i -1 < -1 n; -1 ++i) -1 { -1 wData[i] -1 = -1 new -1 double[p]; -1 } -1 -2
public -1 MultiDirectional(final -1 double -1 khi, -1 final -1 double -1 gamma) -1 { -1 protected -1 void -1 iterateSimplex(final -1 Comparator<RealPointValuePair> -1 comparator) -1 throws -1 FunctionEvaluationException, -1 OptimizationException, -1 IllegalArgumentException -1 { -1 ++++ -1 +++final -1 +++RealConvergenceChecker -1 +++checker -1 +++= -1 +++getConvergenceChecker(); -1 while -1 (true) -1 { -1 incrementIterationsCounter(); -1 @@ -1 -89,8 -1 +90,16 -1 @@ -1 protected -1 void -1 iterateSimplex(final -1 Comparator<RealPointValuePair> -1 comparator) -1 final -1 RealPointValuePair -1 contracted -1 = -1 evaluateNewSimplex(original, -1 gamma, -1 comparator); -1 if -1 (comparator.compare(contracted, -1 best) -1 < -1 0) -1 { -1 // -1 accept -1 the -1 contracted -1 simplex -1 ++++ -1 +++return; -1 ++++ -1 +++} -1 // -1 check -1 convergence -1 ++++ -1 +++final -1 +++int -1 +++iter -1 +++= -1 +++getIterations(); -1 ++++ -1 +++boolean -1 +++converged -1 +++= -1 +++true; -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++simplex.length; -1 +++++i) -1 +++{ -1 ++++ -1 +++converged -1 +++&= -1 +++checker.converged(iter, -1 +++original[i], -1 +++simplex[i]); -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(converged) -1 +++{ -1 return; -1 } -1 -2
private -1 void -1 computeGershgorinCircles() -1 { -1 lowerSpectra -1 = -1 Math.min(lowerSpectra, -1 lower); -1 final -1 double -1 upper -1 = -1 dCurrent -1 + -1 eCurrent; -1 work[upperStart -1 + -1 m -1 - -1 1] -1 = -1 upper; -1 ++++ -1 +++upperSpectra -1 +++= -1 +++Math.max(upperSpectra, -1 +++upper); -1 minPivot -1 = -1 MathUtils.SAFE_MIN -1 * -1 Math.max(1.0, -1 eMax -1 * -1 eMax); -1 } -1 @@ -1 -902,8 -1 +903,8 -1 @@ -1 private -1 void -1 processGeneralBlock(final -1 int -1 n) -1 diagMax -1 = -1 work[4 -1 * -1 i0]; -1 offDiagMin -1 = -1 work[4 -1 * -1 i0 -1 + -1 2]; -1 double -1 previousEMin -1 = -1 work[4 -1 * -1 i0 -1 + -1 3]; -1 ---- -1 ---for -1 ---(int -1 ---i -1 ---= -1 ---4 -1 ---* -1 ---i0; -1 ---i -1 ---< -1 ---4 -1 ---* -1 ---n0 -1 ---- -1 ---11; -1 ---i -1 ---+= -1 ---4) -1 ---{ -1 ---- -1 ---if -1 ---((work[i -1 ---+ -1 ---3] -1 ---<= -1 ---TOLERANCE_2 -1 ---* -1 ---work[i]) -1 ---&& -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++4 -1 +++* -1 +++i0; -1 +++i -1 +++< -1 +++4 -1 +++* -1 +++n0 -1 +++- -1 +++16; -1 +++i -1 ++++= -1 +++4) -1 +++{ -1 ++++ -1 +++if -1 +++((work[i -1 ++++ -1 +++3] -1 +++<= -1 +++TOLERANCE_2 -1 +++* -1 +++work[i]) -1 +++|| -1 (work[i -1 + -1 2] -1 <= -1 TOLERANCE_2 -1 * -1 sigma)) -1 { -1 // -1 insert -1 a -1 split -1 work[i -1 + -1 2] -1 = -1 -sigma; -1 @@ -1 -1540,7 -1 +1541,7 -1 @@ -1 private -1 void -1 computeShiftIncrement(final -1 int -1 start, -1 final -1 int -1 end, -1 final -1 int -1 def -1 double -1 a2 -1 = -1 (work[np -1 - -1 8] -1 / -1 b2) -1 * -1 (1 -1 + -1 work[np -1 - -1 4] -1 / -1 b1); -1 // -1 approximate -1 contribution -1 to -1 norm -1 squared -1 from -1 i -1 < -1 nn-2. -1 ---- -1 ---if -1 ---(end -1 ---- -1 ---start -1 ---> -1 ---2) -1 ---{ -1 ++++ -1 +++if -1 +++(end -1 +++- -1 +++start -1 +++> -1 +++3) -1 +++{ -1 b2 -1 = -1 work[nn -1 - -1 13] -1 / -1 work[nn -1 - -1 15]; -1 a2 -1 = -1 a2 -1 + -1 b2; -1 for -1 (int -1 i4 -1 = -1 nn -1 - -1 17; -1 i4 -1 >= -1 4 -1 * -1 start -1 + -1 2 -1 + -1 pingPong; -1 i4 -1 -= -1 4) -1 { -1 -2
private -1 int -1 goodStep(final -1 int -1 start, -1 final -1 int -1 end) -1 { -1 private -1 boolean -1 flipIfWarranted(final -1 int -1 n, -1 final -1 int -1 step) -1 { -1 if -1 (1.5 -1 * -1 work[pingPong] -1 < -1 work[4 -1 * -1 (n -1 - -1 1) -1 + -1 pingPong]) -1 { -1 // -1 flip -1 array -1 ---- -1 ---int -1 ---j -1 ---= -1 ---4 -1 ---* -1 ---n -1 ---- -1 ---1; -1 ++++ -1 +++int -1 +++j -1 +++= -1 +++4 -1 +++* -1 +++(n -1 +++- -1 +++1); -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 j; -1 i -1 += -1 4) -1 { -1 for -1 (int -1 k -1 = -1 0; -1 k -1 < -1 4; -1 k -1 += -1 step) -1 { -1 final -1 double -1 tmp -1 = -1 work[i -1 + -1 k]; -1 -2
public -1 boolean -1 evaluateStep(final -1 StepInterpolator -1 interpolator) -1 if -1 (g0Positive -1 ^ -1 (gb -1 >= -1 0)) -1 { -1 // -1 there -1 is -1 a -1 sign -1 change: -1 an -1 event -1 is -1 expected -1 during -1 this -1 step -1 ++++ -1 +++if -1 +++(ga -1 +++* -1 +++gb -1 +++> -1 +++0) -1 +++{ -1 // -1 this -1 is -1 a -1 corner -1 case: -1 // -1 - -1 there -1 was -1 an -1 event -1 near -1 ta, -1 // -1 - -1 there -1 is -1 another -1 event -1 between -1 ta -1 and -1 tb -1 @@ -1 -195,7 -1 +196,17 -1 @@ -1 public -1 boolean -1 evaluateStep(final -1 StepInterpolator -1 interpolator) -1 // -1 this -1 implies -1 that -1 the -1 real -1 sign -1 of -1 ga -1 is -1 the -1 same -1 as -1 gb, -1 so -1 we -1 need -1 to -1 slightly -1 // -1 shift -1 ta -1 to -1 make -1 sure -1 ga -1 and -1 gb -1 get -1 opposite -1 signs -1 and -1 the -1 solver -1 won't -1 complain -1 // -1 about -1 bracketing -1 ++++ -1 +++final -1 +++double -1 +++epsilon -1 +++= -1 +++(forward -1 +++? -1 +++0.25 -1 +++: -1 +++-0.25) -1 +++* -1 +++convergence; -1 ++++ -1 +++for -1 +++(int -1 +++k -1 +++= -1 +++0; -1 +++(k -1 +++< -1 +++4) -1 +++&& -1 +++(ga -1 +++* -1 +++gb -1 +++> -1 +++0); -1 +++++k) -1 +++{ -1 ++++ -1 +++ta -1 ++++= -1 +++epsilon; -1 ++++ -1 +++interpolator.setInterpolatedTime(ta); -1 ++++ -1 +++ga -1 +++= -1 +++handler.g(ta, -1 +++interpolator.getInterpolatedState()); -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(ga -1 +++* -1 +++gb -1 +++> -1 +++0) -1 +++{ -1 // -1 this -1 should -1 never -1 happen -1 ++++ -1 +++throw -1 +++MathRuntimeException.createInternalError(null); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 // -1 variation -1 direction, -1 with -1 respect -1 to -1 the -1 integration -1 direction -1 increasing -1 = -1 gb -1 >= -1 ga; -1 -2
private -1 Integer -1 getBasicRowForSolution(final -1 int -1 col) -1 { -1 */ -1 private -1 Integer -1 getBasicRow(final -1 int -1 col, -1 boolean -1 ignoreObjectiveRows) -1 { -1 Integer -1 row -1 = -1 null; -1 ---- -1 ---int -1 ---start -1 ---= -1 ---getNumObjectiveFunctions(); -1 ++++ -1 +++int -1 +++start -1 +++= -1 +++ignoreObjectiveRows -1 +++? -1 +++getNumObjectiveFunctions() -1 +++: -1 +++0; -1 for -1 (int -1 i -1 = -1 start; -1 i -1 < -1 getHeight(); -1 i++) -1 { -1 if -1 (MathUtils.equals(getEntry(i, -1 col), -1 1.0, -1 epsilon) -1 && -1 (row -1 == -1 null)) -1 { -1 row -1 = -1 i; -1 @@ -1 -338,11 -1 +338,11 -1 @@ -1 private -1 void -1 copyArray(final -1 double[] -1 src, -1 final -1 double[] -1 dest, -1 */ -1 protected -1 RealPointValuePair -1 getSolution() -1 { -1 double[] -1 coefficients -1 = -1 new -1 double[getOriginalNumDecisionVariables()]; -1 ---- -1 ---Integer -1 ---negativeVarBasicRow -1 ---= -1 ---getBasicRow(getNegativeDecisionVariableOffset()); -1 ++++ -1 +++Integer -1 +++negativeVarBasicRow -1 +++= -1 +++getBasicRowForSolution(getNegativeDecisionVariableOffset()); -1 double -1 mostNegative -1 = -1 negativeVarBasicRow -1 == -1 null -1 ? -1 0 -1 : -1 getEntry(negativeVarBasicRow, -1 getRhsOffset()); -1 Set<Integer> -1 basicRows -1 = -1 new -1 HashSet<Integer>(); -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 coefficients.length; -1 i++) -1 { -1 ---- -1 ---Integer -1 ---basicRow -1 ---= -1 ---getBasicRow(getNumObjectiveFunctions() -1 ---+ -1 ---i); -1 ++++ -1 +++Integer -1 +++basicRow -1 +++= -1 +++getBasicRowForSolution(getNumObjectiveFunctions() -1 ++++ -1 +++i); -1 if -1 (basicRows.contains(basicRow)) -1 { -1 // -1 if -1 multiple -1 variables -1 can -1 take -1 a -1 given -1 value -1 // -1 then -1 we -1 choose -1 the -1 first -1 and -1 set -1 the -1 rest -1 equal -1 to -1 0 -1 -2
public -1 static -1 double -1 distance(double[] -1 p1, -1 double[] -1 p2) -1 { -1 * -1 @return -1 the -1 L<sub>2</sub> -1 distance -1 between -1 the -1 two -1 points -1 */ -1 public -1 static -1 double -1 distance(int[] -1 p1, -1 int[] -1 p2) -1 { -1 ---- -1 ---int -1 ---sum -1 ---= -1 ---0; -1 ++++ -1 +++double -1 +++sum -1 +++= -1 +++0; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 p1.length; -1 i++) -1 { -1 ---- -1 ---final -1 ---int -1 ---dp -1 ---= -1 ---p1[i] -1 ---- -1 ---p2[i]; -1 ++++ -1 +++final -1 +++double -1 +++dp -1 +++= -1 +++p1[i] -1 +++- -1 +++p2[i]; -1 sum -1 += -1 dp -1 * -1 dp; -1 } -1 return -1 Math.sqrt(sum); -1 -2
public -1 static -1 double -1 solve(UnivariateRealFunction -1 f, -1 double -1 x0, -1 double -1 x1, -1 } -1 while -1 ((fa -1 * -1 fb -1 > -1 0.0) -1 && -1 (numIterations -1 < -1 maximumIterations) -1 && -1 ((a -1 > -1 lowerBound) -1 || -1 (b -1 < -1 upperBound))); -1 ---- -1 ---if -1 ---(fa -1 ---* -1 ---fb -1 --->= -1 ---0.0 -1 ---) -1 ---{ -1 ++++ -1 +++if -1 +++(fa -1 +++* -1 +++fb -1 +++> -1 +++0.0 -1 +++) -1 +++{ -1 throw -1 new -1 ConvergenceException( -1 "number -1 of -1 iterations={0}, -1 maximum -1 iterations={1}, -1 " -1 + -1 "initial={2}, -1 lower -1 bound={3}, -1 upper -1 bound={4}, -1 final -1 a -1 value={5}, -1 " -1 + -1 -2
public -1 String -1 toString() -1 { -1 */ -1 @Deprecated -1 public -1 void -1 addValue(Object -1 v) -1 { -1 ++++ -1 +++if -1 +++(v -1 +++instanceof -1 +++Comparable<?>){ -1 addValue((Comparable<?>) -1 v); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Object -1 +++must -1 +++implement -1 +++Comparable"); -1 ++++ -1 +++} -1 } -1 /** -1 -2
protected -1 static -1 double -1 getInvertedCoeffiecientSum(final -1 RealVector -1 coefficients -1 private -1 Integer -1 getBasicRow(final -1 int -1 col) -1 { -1 Integer -1 row -1 = -1 null; -1 for -1 (int -1 i -1 = -1 getNumObjectiveFunctions(); -1 i -1 < -1 getHeight(); -1 i++) -1 { -1 ---- -1 ---if -1 ---(!MathUtils.equals(getEntry(i, -1 ---col), -1 ---0.0, -1 ---epsilon)) -1 ---{ -1 ---- -1 ---if -1 ---(row -1 ---== -1 ---null) -1 ---{ -1 ++++ -1 +++if -1 +++(MathUtils.equals(getEntry(i, -1 +++col), -1 +++1.0, -1 +++epsilon) -1 +++&& -1 +++(row -1 +++== -1 +++null)) -1 +++{ -1 row -1 = -1 i; -1 ---- -1 ---} -1 ---else -1 ---{ -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(!MathUtils.equals(getEntry(i, -1 +++col), -1 +++0.0, -1 +++epsilon)) -1 +++{ -1 return -1 null; -1 ---- -1 ---} -1 } -1 } -1 return -1 row; -1 -2
public -1 CholeskyDecompositionImpl(final -1 RealMatrix -1 matrix, -1 final -1 double[] -1 lI -1 = -1 lTData[i]; -1 ---- -1 ---if -1 ---(lTData[i][i] -1 ---< -1 ---absolutePositivityThreshold) -1 ---{ -1 ---- -1 ---throw -1 ---new -1 ---NotPositiveDefiniteMatrixException(); -1 ---- -1 ---} -1 // -1 check -1 off-diagonal -1 elements -1 (and -1 reset -1 them -1 to -1 0) -1 for -1 (int -1 j -1 = -1 i -1 + -1 1; -1 j -1 < -1 order; -1 ++j) -1 { -1 final -1 double[] -1 lJ -1 = -1 lTData[j]; -1 @@ -1 -134,6 -1 +131,9 -1 @@ -1 public -1 CholeskyDecompositionImpl(final -1 RealMatrix -1 matrix, -1 final -1 double[] -1 ltI -1 = -1 lTData[i]; -1 // -1 check -1 diagonal -1 element -1 ++++ -1 +++if -1 +++(ltI[i] -1 +++< -1 +++absolutePositivityThreshold) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++NotPositiveDefiniteMatrixException(); -1 ++++ -1 +++} -1 ltI[i] -1 = -1 Math.sqrt(ltI[i]); -1 final -1 double -1 inverse -1 = -1 1.0 -1 / -1 ltI[i]; -1 -2
protected -1 RealPointValuePair -1 getSolution() -1 { -1 Integer -1 basicRow -1 = -1 getBasicRow(getNumObjectiveFunctions() -1 + -1 getOriginalNumDecisionVariables()); -1 double -1 mostNegative -1 = -1 basicRow -1 == -1 null -1 ? -1 0 -1 : -1 getEntry(basicRow, -1 getRhsOffset()); -1 ++++ -1 +++Set<Integer> -1 +++basicRows -1 +++= -1 +++new -1 +++HashSet<Integer>(); -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 coefficients.length; -1 i++) -1 { -1 basicRow -1 = -1 getBasicRow(getNumObjectiveFunctions() -1 + -1 i); -1 ++++ -1 +++if -1 +++(basicRows.contains(basicRow)) -1 +++{ -1 // -1 if -1 multiple -1 variables -1 can -1 take -1 a -1 given -1 value -1 // -1 then -1 we -1 choose -1 the -1 first -1 and -1 set -1 the -1 rest -1 equal -1 to -1 0 -1 ++++ -1 +++coefficients[i] -1 +++= -1 +++0; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++basicRows.add(basicRow); -1 coefficients[i] -1 = -1 (basicRow -1 == -1 null -1 ? -1 0 -1 : -1 getEntry(basicRow, -1 getRhsOffset())) -1 - -1 (restrictToNonNegative -1 ? -1 0 -1 : -1 mostNegative); -1 ---- -1 ---if -1 ---(basicRow -1 ---!= -1 ---null) -1 ---{ -1 ---- -1 ---for -1 ---(int -1 ---j -1 ---= -1 ---getNumObjectiveFunctions(); -1 ---j -1 ---< -1 ---getNumObjectiveFunctions() -1 ---+ -1 ---i; -1 ---j++) -1 ---{ -1 ---- -1 ---if -1 ---(tableau.getEntry(basicRow, -1 ---j) -1 ---== -1 ---1) -1 ---{ -1 ---- -1 ---coefficients[i] -1 ---= -1 ---0; -1 ---- -1 ---} -1 ---- -1 ---} -1 } -1 } -1 return -1 new -1 RealPointValuePair(coefficients, -1 f.getValue(coefficients)); -1 -2
public -1 Fraction -1 abs() -1 { -1 * -1 than -1 <tt>object</tt>, -1 0 -1 if -1 they -1 are -1 equal. -1 */ -1 public -1 int -1 compareTo(Fraction -1 object) -1 { -1 ---- -1 ---double -1 ---nOd -1 ---= -1 ---doubleValue(); -1 ---- -1 ---double -1 ---dOn -1 ---= -1 ---object.doubleValue(); -1 ++++ -1 +++long -1 +++nOd -1 +++= -1 +++((long) -1 +++numerator) -1 +++* -1 +++object.denominator; -1 ++++ -1 +++long -1 +++dOn -1 +++= -1 +++((long) -1 +++denominator) -1 +++* -1 +++object.numerator; -1 return -1 (nOd -1 < -1 dOn) -1 ? -1 -1 -1 : -1 ((nOd -1 > -1 dOn) -1 ? -1 +1 -1 : -1 0); -1 } -1 -2
public -1 static -1 boolean -1 equals(double[] -1 x, -1 double[] -1 y) -1 { -1 * -1 @throws -1 IllegalArgumentException -1 if -1 n -1 < -1 0 -1 */ -1 public -1 static -1 long -1 factorial(final -1 int -1 n) -1 { -1 ---- -1 ---long -1 ---result -1 ---= -1 ---Math.round(factorialDouble(n)); -1 ---- -1 ---if -1 ---(result -1 ---== -1 ---Long.MAX_VALUE) -1 ---{ -1 ++++ -1 +++if -1 +++(n -1 +++< -1 +++0) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("must -1 +++have -1 +++n -1 +++>= -1 +++0 -1 +++for -1 +++n!"); -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(n -1 +++> -1 +++20) -1 +++{ -1 throw -1 new -1 ArithmeticException( -1 "factorial -1 value -1 is -1 too -1 large -1 to -1 fit -1 in -1 a -1 long"); -1 } -1 @@ -1 -374,6 -1 +376,9 -1 @@ -1 public -1 static -1 double -1 factorialDouble(final -1 int -1 n) -1 { -1 if -1 (n -1 < -1 0) -1 { -1 throw -1 new -1 IllegalArgumentException("must -1 have -1 n -1 >= -1 0 -1 for -1 n!"); -1 } -1 ++++ -1 +++if -1 +++(n -1 +++< -1 +++21) -1 +++{ -1 ++++ -1 +++return -1 +++factorial(n); -1 ++++ -1 +++} -1 return -1 Math.floor(Math.exp(factorialLog(n)) -1 + -1 0.5); -1 } -1 @@ -1 -394,6 -1 +399,9 -1 @@ -1 public -1 static -1 double -1 factorialLog(final -1 int -1 n) -1 { -1 if -1 (n -1 < -1 0) -1 { -1 throw -1 new -1 IllegalArgumentException("must -1 have -1 n -1 > -1 0 -1 for -1 n!"); -1 } -1 ++++ -1 +++if -1 +++(n -1 +++< -1 +++21) -1 +++{ -1 ++++ -1 +++return -1 +++Math.log(factorial(n)); -1 ++++ -1 +++} -1 double -1 logSum -1 = -1 0; -1 for -1 (int -1 i -1 = -1 2; -1 i -1 <= -1 n; -1 i++) -1 { -1 logSum -1 += -1 Math.log((double)i); -1 -2
protected -1 double -1 getDomainUpperBound(double -1 p) -1 { -1 * -1 @return -1 initial -1 domain -1 value -1 */ -1 protected -1 double -1 getInitialDomain(double -1 p) -1 { -1 ---- -1 ---double -1 ---ret; -1 ++++ -1 +++double -1 +++ret -1 +++= -1 +++1.0; -1 double -1 d -1 = -1 getDenominatorDegreesOfFreedom(); -1 ++++ -1 +++if -1 +++(d -1 +++> -1 +++2.0) -1 +++{ -1 // -1 use -1 mean -1 ret -1 = -1 d -1 / -1 (d -1 - -1 2.0); -1 ++++ -1 +++} -1 return -1 ret; -1 } -1 -2
public -1 static -1 double -1 factorialLog(final -1 int -1 n) -1 { -1 * -1 @since -1 1.1 -1 */ -1 public -1 static -1 int -1 gcd(int -1 u, -1 int -1 v) -1 { -1 ---- -1 ---if -1 ---(u -1 ---* -1 ---v -1 ---== -1 ---0) -1 ---{ -1 ++++ -1 +++if -1 +++((u -1 +++== -1 +++0) -1 +++|| -1 +++(v -1 +++== -1 +++0)) -1 +++{ -1 return -1 (Math.abs(u) -1 + -1 Math.abs(v)); -1 } -1 // -1 keep -1 u -1 and -1 v -1 negative, -1 as -1 negative -1 integers -1 range -1 down -1 to -1 -2
public -1 String -1 toString() -1 { -1 */ -1 @Deprecated -1 public -1 void -1 addValue(Object -1 v) -1 { -1 ++++ -1 +++addValue((Comparable<?>) -1 +++v); -1 ++++ -1 +++} -1 /** -1 * -1 Adds -1 1 -1 to -1 the -1 frequency -1 count -1 for -1 v. -1 @@ -1 -118,6 -1 +120,7 -1 @@ -1 public -1 void -1 addValue(Object -1 v) -1 { -1 * -1 @param -1 v -1 the -1 value -1 to -1 add. -1 * -1 @throws -1 IllegalArgumentException -1 if -1 <code>v</code> -1 is -1 not -1 comparable -1 with -1 previous -1 entries -1 */ -1 ++++ -1 +++public -1 +++void -1 +++addValue(Comparable<?>v){ -1 Object -1 obj -1 = -1 v; -1 if -1 (v -1 instanceof -1 Integer) -1 { -1 obj -1 = -1 Long.valueOf(((Integer) -1 v).longValue()); -1 -2
public -1 boolean -1 equals(Object -1 other) -1 { -1 if -1 (rhs.isNaN()) -1 { -1 ret -1 = -1 this.isNaN(); -1 } -1 else -1 { -1 ---- -1 ---ret -1 ---= -1 ---(Double.doubleToRawLongBits(real) -1 ---== -1 ---Double.doubleToRawLongBits(rhs.getReal())) -1 ---&& -1 ---(Double.doubleToRawLongBits(imaginary) -1 ---== -1 ---Double.doubleToRawLongBits(rhs.getImaginary())); -1 ++++ -1 +++ret -1 +++= -1 +++(real -1 +++== -1 +++rhs.real) -1 +++&& -1 +++(imaginary -1 +++== -1 +++rhs.imaginary); -1 } -1 } -1 catch -1 (ClassCastException -1 ex) -1 { -1 // -1 ignore -1 exception -1 -2
public -1 static -1 long -1 binomialCoefficient(final -1 int -1 n, -1 final -1 int -1 k) -1 { -1 if -1 ((k -1 == -1 1) -1 || -1 (k -1 == -1 n -1 - -1 1)) -1 { -1 return -1 n; -1 } -1 ---- -1 ---long -1 ---result -1 ---= -1 ---Math.round(binomialCoefficientDouble(n, -1 ---k)); -1 ---- -1 ---if -1 ---(result -1 ---== -1 ---Long.MAX_VALUE) -1 ---{ -1 ---- -1 ---throw -1 ---new -1 ---ArithmeticException( -1 ---- -1 ---"result -1 ---too -1 ---large -1 ---to -1 ---represent -1 ---in -1 ---a -1 ---long -1 ---integer"); -1 ---- -1 ---} -1 // -1 Use -1 symmetry -1 for -1 large -1 k -1 ++++ -1 +++if -1 +++(k -1 +++> -1 +++n -1 +++/ -1 +++2) -1 ++++ -1 +++return -1 +++binomialCoefficient(n, -1 +++n -1 +++- -1 +++k); -1 // -1 We -1 use -1 the -1 formula -1 // -1 (n -1 choose -1 k) -1 = -1 n! -1 / -1 (n-k)! -1 / -1 k! -1 // -1 (n -1 choose -1 k) -1 == -1 ((n-k+1)*...*n) -1 / -1 (1*...*k) -1 // -1 which -1 could -1 be -1 written -1 // -1 (n -1 choose -1 k) -1 == -1 (n-1 -1 choose -1 k-1) -1 * -1 n -1 / -1 k -1 ++++ -1 +++long -1 +++result -1 +++= -1 +++1; -1 ++++ -1 +++if -1 +++(n -1 +++<= -1 +++61) -1 +++{ -1 // -1 For -1 n -1 <= -1 61, -1 the -1 naive -1 implementation -1 cannot -1 overflow. -1 ++++ -1 +++for -1 +++(int -1 +++j -1 +++= -1 +++1, -1 +++i -1 +++= -1 +++n -1 +++- -1 +++k -1 ++++ -1 +++1; -1 +++j -1 +++<= -1 +++k; -1 +++i++, -1 +++j++) -1 +++{ -1 ++++ -1 +++result -1 +++= -1 +++result -1 +++* -1 +++i -1 +++/ -1 +++j; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(n -1 +++<= -1 +++66) -1 +++{ -1 // -1 For -1 n -1 > -1 61 -1 but -1 n -1 <= -1 66, -1 the -1 result -1 cannot -1 overflow, -1 // -1 but -1 we -1 must -1 take -1 care -1 not -1 to -1 overflow -1 intermediate -1 values. -1 ++++ -1 +++for -1 +++(int -1 +++j -1 +++= -1 +++1, -1 +++i -1 +++= -1 +++n -1 +++- -1 +++k -1 ++++ -1 +++1; -1 +++j -1 +++<= -1 +++k; -1 +++i++, -1 +++j++) -1 +++{ -1 // -1 We -1 know -1 that -1 (result -1 * -1 i) -1 is -1 divisible -1 by -1 j, -1 // -1 but -1 (result -1 * -1 i) -1 may -1 overflow, -1 so -1 we -1 split -1 j: -1 // -1 Filter -1 out -1 the -1 gcd, -1 d, -1 so -1 j/d -1 and -1 i/d -1 are -1 integer. -1 // -1 result -1 is -1 divisible -1 by -1 (j/d) -1 because -1 (j/d) -1 // -1 is -1 relative -1 prime -1 to -1 (i/d) -1 and -1 is -1 a -1 divisor -1 of -1 // -1 result -1 * -1 (i/d). -1 ++++ -1 +++long -1 +++d -1 +++= -1 +++gcd(i, -1 +++j); -1 ++++ -1 +++result -1 +++= -1 +++(result -1 +++/ -1 +++(j -1 +++/ -1 +++d)) -1 +++* -1 +++(i -1 +++/ -1 +++d); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 +++else -1 +++{ -1 // -1 For -1 n -1 > -1 66, -1 a -1 result -1 overflow -1 might -1 occur, -1 so -1 we -1 check -1 // -1 the -1 multiplication, -1 taking -1 care -1 to -1 not -1 overflow -1 // -1 unnecessary. -1 ++++ -1 +++for -1 +++(int -1 +++j -1 +++= -1 +++1, -1 +++i -1 +++= -1 +++n -1 +++- -1 +++k -1 ++++ -1 +++1; -1 +++j -1 +++<= -1 +++k; -1 +++i++, -1 +++j++) -1 +++{ -1 ++++ -1 +++long -1 +++d -1 +++= -1 +++gcd(i, -1 +++j); -1 ++++ -1 +++result -1 +++= -1 +++mulAndCheck((result -1 +++/ -1 +++(j -1 +++/ -1 +++d)), -1 +++(i -1 +++/ -1 +++d)); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 return -1 result; -1 } -1 @@ -1 -231,9 -1 +244,33 -1 @@ -1 public -1 static -1 long -1 binomialCoefficient(final -1 int -1 n, -1 final -1 int -1 k) -1 { -1 * -1 @throws -1 IllegalArgumentException -1 if -1 preconditions -1 are -1 not -1 met. -1 */ -1 public -1 static -1 double -1 binomialCoefficientDouble(final -1 int -1 n, -1 final -1 int -1 k) -1 { -1 ++++ -1 +++if -1 +++(n -1 +++< -1 +++k) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException( -1 ++++ -1 +++"must -1 +++have -1 +++n -1 +++>= -1 +++k -1 +++for -1 +++binomial -1 +++coefficient -1 +++(n,k)"); -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(n -1 +++< -1 +++0) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException( -1 ++++ -1 +++"must -1 +++have -1 +++n -1 +++>= -1 +++0 -1 +++for -1 +++binomial -1 +++coefficient -1 +++(n,k)"); -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++((n -1 +++== -1 +++k) -1 +++|| -1 +++(k -1 +++== -1 +++0)) -1 +++{ -1 ++++ -1 +++return -1 +++1d; -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++((k -1 +++== -1 +++1) -1 +++|| -1 +++(k -1 +++== -1 +++n -1 +++- -1 +++1)) -1 +++{ -1 ++++ -1 +++return -1 +++n; -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(k -1 +++> -1 +++n/2) -1 +++{ -1 ++++ -1 +++return -1 +++binomialCoefficientDouble(n, -1 +++n -1 +++- -1 +++k); -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(n -1 +++< -1 +++67) -1 +++{ -1 ++++ -1 +++return -1 +++binomialCoefficient(n,k); -1 ++++ -1 +++} -1 ++++ -1 +++double -1 +++result -1 +++= -1 +++1d; -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++1; -1 +++i -1 +++<= -1 +++k; -1 +++i++) -1 +++{ -1 ++++ -1 +++result -1 +++*= -1 +++(double)(n -1 +++- -1 +++k -1 ++++ -1 +++i) -1 +++/ -1 +++(double)i; -1 ++++ -1 +++} -1 ---- -1 ---return -1 ---Math.floor(Math.exp(binomialCoefficientLog(n, -1 ---k)) -1 ---+ -1 ---0.5); -1 ++++ -1 +++return -1 +++Math.floor(result -1 ++++ -1 +++0.5); -1 } -1 /** -1 @@ -1 -274,11 -1 +311,17 -1 @@ -1 public -1 static -1 double -1 binomialCoefficientLog(final -1 int -1 n, -1 final -1 int -1 k) -1 { -1 * -1 For -1 values -1 small -1 enough -1 to -1 do -1 exact -1 integer -1 computation, -1 * -1 return -1 the -1 log -1 of -1 the -1 exact -1 value -1 */ -1 ++++ -1 +++if -1 +++(n -1 +++< -1 +++67) -1 +++{ -1 ++++ -1 +++return -1 +++Math.log(binomialCoefficient(n,k)); -1 ++++ -1 +++} -1 /* -1 * -1 Return -1 the -1 log -1 of -1 binomialCoefficientDouble -1 for -1 values -1 that -1 will -1 not -1 * -1 overflow -1 binomialCoefficientDouble -1 */ -1 ++++ -1 +++if -1 +++(n -1 +++< -1 +++1030) -1 +++{ -1 ++++ -1 +++return -1 +++Math.log(binomialCoefficientDouble(n, -1 +++k)); -1 ++++ -1 +++} -1 /* -1 * -1 Sum -1 logs -1 for -1 values -1 that -1 could -1 overflow -1 -2
public -1 BigDecimal -1 getTrace() -1 throws -1 IllegalArgumentException -1 { -1 } -1 final -1 int -1 nRows -1 = -1 this.getRowDimension(); -1 final -1 int -1 nCols -1 = -1 this.getColumnDimension(); -1 ---- -1 ---final -1 ---BigDecimal[] -1 ---out -1 ---= -1 ---new -1 ---BigDecimal[v.length]; -1 ++++ -1 +++final -1 +++BigDecimal[] -1 +++out -1 +++= -1 +++new -1 +++BigDecimal[nRows]; -1 for -1 (int -1 row -1 = -1 0; -1 row -1 < -1 nRows; -1 row++) -1 { -1 BigDecimal -1 sum -1 = -1 ZERO; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 nCols; -1 i++) -1 { -1 ------ -1 ---a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java -1 ++++++ -1 +++b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java -1 @@ -1 -776,7 -1 +776,7 -1 @@ -1 public -1 double -1 getTrace() -1 throws -1 IllegalArgumentException -1 { -1 if -1 (v.length -1 != -1 nCols) -1 { -1 throw -1 new -1 IllegalArgumentException("vector -1 has -1 wrong -1 length"); -1 } -1 ---- -1 ---final -1 ---double[] -1 ---out -1 ---= -1 ---new -1 ---double[v.length]; -1 ++++ -1 +++final -1 +++double[] -1 +++out -1 +++= -1 +++new -1 +++double[nRows]; -1 for -1 (int -1 row -1 = -1 0; -1 row -1 < -1 nRows; -1 row++) -1 { -1 final -1 double[] -1 dataRow -1 = -1 data[row]; -1 double -1 sum -1 = -1 0; -1 -2
public -1 Complex -1 parse(String -1 source, -1 ParsePosition -1 pos) -1 { -1 int -1 n -1 = -1 getImaginaryCharacter().length(); -1 startIndex -1 = -1 pos.getIndex(); -1 int -1 endIndex -1 = -1 startIndex -1 + -1 n; -1 ---- -1 ---if -1 ---( -1 ++++ -1 +++if -1 +++((startIndex -1 +++>= -1 +++source.length()) -1 +++|| -1 ++++ -1 +++(endIndex -1 +++> -1 +++source.length()) -1 +++|| -1 source.substring(startIndex, -1 endIndex).compareTo( -1 getImaginaryCharacter()) -1 != -1 0) -1 { -1 // -1 set -1 index -1 back -1 to -1 initial, -1 error -1 index -1 should -1 be -1 the -1 start -1 index -1 -2
public -1 double -1 getSlope() -1 { -1 * -1 @return -1 sum -1 of -1 squared -1 errors -1 associated -1 with -1 the -1 regression -1 model -1 */ -1 public -1 double -1 getSumSquaredErrors() -1 { -1 ---- -1 ---return -1 ---sumYY -1 ---- -1 ---sumXY -1 ---* -1 ---sumXY -1 ---/ -1 ---sumXX; -1 ++++ -1 +++return -1 +++Math.max(0d, -1 +++sumYY -1 +++- -1 +++sumXY -1 +++* -1 +++sumXY -1 +++/ -1 +++sumXX); -1 } -1 /** -1 -2
private -1 static -1 final -1 long -1 serialVersionUID -1 = -1 -6587513359895466954L; -1 /** -1 Maximum -1 allowed -1 numerical -1 error. -1 */ -1 ---- -1 ---private -1 ---static -1 ---final -1 ---double -1 ---DEFAULT_EPSILON -1 ---= -1 ---10e-9; -1 ++++ -1 +++private -1 +++static -1 +++final -1 +++double -1 +++DEFAULT_EPSILON -1 +++= -1 +++10e-15; -1 /** -1 Lanczos -1 coefficients -1 */ -1 private -1 static -1 double[] -1 lanczos -1 = -1 -2
public -1 double -1 solve(double -1 min, -1 double -1 max) -1 throws -1 MaxIterationsExceededExceptio -1 // -1 Verify -1 bracketing -1 double -1 sign -1 = -1 yMin -1 * -1 yMax; -1 ---- -1 ---if -1 ---(sign -1 --->= -1 ---0) -1 ---{ -1 ++++ -1 +++if -1 +++(sign -1 +++> -1 +++0) -1 +++{ -1 // -1 check -1 if -1 either -1 value -1 is -1 close -1 to -1 a -1 zero -1 ++++ -1 +++if -1 +++(Math.abs(yMin) -1 +++<= -1 +++functionValueAccuracy) -1 +++{ -1 ++++ -1 +++setResult(min, -1 +++0); -1 ++++ -1 +++ret -1 +++= -1 +++min; -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(Math.abs(yMax) -1 +++<= -1 +++functionValueAccuracy) -1 +++{ -1 ++++ -1 +++setResult(max, -1 +++0); -1 ++++ -1 +++ret -1 +++= -1 +++max; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 // -1 neither -1 value -1 is -1 close -1 to -1 zero -1 and -1 min -1 and -1 max -1 do -1 not -1 bracket -1 root. -1 throw -1 new -1 IllegalArgumentException -1 ("Function -1 values -1 at -1 endpoints -1 do -1 not -1 have -1 different -1 signs." -1 + -1 " -1 Endpoints: -1 [" -1 + -1 min -1 + -1 "," -1 + -1 max -1 + -1 "]" -1 + -1 " -1 Values: -1 [" -1 + -1 yMin -1 + -1 "," -1 + -1 yMax -1 + -1 "]"); -1 ---- -1 ---} -1 ---else -1 ---{ -1 ++++ -1 +++} -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(sign -1 +++< -1 +++0){ -1 // -1 solve -1 using -1 only -1 the -1 first -1 endpoint -1 as -1 initial -1 guess -1 ret -1 = -1 solve(min, -1 yMin, -1 max, -1 yMax, -1 min, -1 yMin); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 // -1 either -1 min -1 or -1 max -1 is -1 a -1 root -1 ++++ -1 +++if -1 +++(yMin -1 +++== -1 +++0.0) -1 +++{ -1 ++++ -1 +++ret -1 +++= -1 +++min; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++ret -1 +++= -1 +++max; -1 ++++ -1 +++} -1 } -1 return -1 ret; -1 -2
public -1 double -1 getChiSquare(EstimationProblem -1 problem) -1 { -1 // -1 compute -1 transpose(J).J, -1 avoiding -1 building -1 big -1 intermediate -1 matrices -1 final -1 int -1 rows -1 = -1 problem.getMeasurements().length; -1 ---- -1 ---final -1 ---int -1 ---cols -1 ---= -1 ---problem.getAllParameters().length; -1 ++++ -1 +++final -1 +++int -1 +++cols -1 +++= -1 +++problem.getUnboundParameters().length; -1 final -1 int -1 max -1 = -1 cols -1 * -1 rows; -1 double[][] -1 jTj -1 = -1 new -1 double[cols][cols]; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 cols; -1 ++i) -1 { -1 @@ -1 -199,12 -1 +199,12 -1 @@ -1 public -1 double -1 getChiSquare(EstimationProblem -1 problem) -1 { -1 public -1 double[] -1 guessParametersErrors(EstimationProblem -1 problem) -1 throws -1 EstimationException -1 { -1 int -1 m -1 = -1 problem.getMeasurements().length; -1 ---- -1 ---int -1 ---p -1 ---= -1 ---problem.getAllParameters().length; -1 ++++ -1 +++int -1 +++p -1 +++= -1 +++problem.getUnboundParameters().length; -1 if -1 (m -1 <= -1 p) -1 { -1 throw -1 new -1 EstimationException("no -1 degrees -1 of -1 freedom -1 ({0} -1 measurements, -1 {1} -1 parameters)", -1 new -1 Object[] -1 { -1 new -1 Integer(m), -1 new -1 Integer(p)}); -1 } -1 ---- -1 ---double[] -1 ---errors -1 ---= -1 ---new -1 ---double[problem.getAllParameters().length]; -1 ++++ -1 +++double[] -1 +++errors -1 +++= -1 +++new -1 +++double[problem.getUnboundParameters().length]; -1 final -1 double -1 c -1 = -1 Math.sqrt(getChiSquare(problem) -1 / -1 (m -1 - -1 p)); -1 double[][] -1 covar -1 = -1 getCovariances(problem); -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 errors.length; -1 ++i) -1 { -1 -2
public -1 void -1 setStandardDeviation(double -1 sd) -1 { -1 * -1 convergence -1 exception -1 is -1 caught -1 and -1 0 -1 or -1 1 -1 is -1 returned. -1 */ -1 public -1 double -1 cumulativeProbability(double -1 x) -1 throws -1 MathException -1 { -1 ++++ -1 +++try -1 +++{ -1 return -1 0.5 -1 * -1 (1.0 -1 + -1 Erf.erf((x -1 - -1 mean) -1 / -1 (standardDeviation -1 * -1 Math.sqrt(2.0)))); -1 ++++ -1 +++} -1 +++catch -1 +++(MaxIterationsExceededException -1 +++ex) -1 +++{ -1 ++++ -1 +++if -1 +++(x -1 +++< -1 +++(mean -1 +++- -1 +++20 -1 +++* -1 +++standardDeviation)) -1 +++{ -1 +++// -1 +++JDK -1 +++1.5 -1 +++blows -1 +++at -1 +++38 -1 ++++ -1 +++return -1 +++0.0d; -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(x -1 +++> -1 +++(mean -1 ++++ -1 +++20 -1 +++* -1 +++standardDeviation)) -1 +++{ -1 ++++ -1 +++return -1 +++1.0d; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++throw -1 +++ex; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 } -1 /** -1 -2
public -1 double -1 chiSquare(double[] -1 expected, -1 long[] -1 observed) -1 throw -1 new -1 IllegalArgumentException( -1 "observed -1 counts -1 must -1 be -1 non-negative -1 and -1 expected -1 counts -1 must -1 be -1 postive"); -1 } -1 ++++ -1 +++double -1 +++sumExpected -1 +++= -1 +++0d; -1 ++++ -1 +++double -1 +++sumObserved -1 +++= -1 +++0d; -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++observed.length; -1 +++i++) -1 +++{ -1 ++++ -1 +++sumExpected -1 ++++= -1 +++expected[i]; -1 ++++ -1 +++sumObserved -1 ++++= -1 +++observed[i]; -1 ++++ -1 +++} -1 ++++ -1 +++double -1 +++ratio -1 +++= -1 +++1.0d; -1 ++++ -1 +++boolean -1 +++rescale -1 +++= -1 +++false; -1 ++++ -1 +++if -1 +++(Math.abs(sumExpected -1 +++- -1 +++sumObserved) -1 +++> -1 +++10E-6) -1 +++{ -1 ++++ -1 +++ratio -1 +++= -1 +++sumObserved -1 +++/ -1 +++sumExpected; -1 ++++ -1 +++rescale -1 +++= -1 +++true; -1 ++++ -1 +++} -1 double -1 sumSq -1 = -1 0.0d; -1 double -1 dev -1 = -1 0.0d; -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 observed.length; -1 i++) -1 { -1 ++++ -1 +++if -1 +++(rescale) -1 +++{ -1 ++++ -1 +++dev -1 +++= -1 +++((double) -1 +++observed[i] -1 +++- -1 +++ratio -1 +++* -1 +++expected[i]); -1 ++++ -1 +++sumSq -1 ++++= -1 +++dev -1 +++* -1 +++dev -1 +++/ -1 +++(ratio -1 +++* -1 +++expected[i]); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 dev -1 = -1 ((double) -1 observed[i] -1 - -1 expected[i]); -1 sumSq -1 += -1 dev -1 * -1 dev -1 / -1 expected[i]; -1 ++++ -1 +++} -1 } -1 return -1 sumSq; -1 } -1 -2
public -1 static -1 int -1 gcd(final -1 int -1 p, -1 final -1 int -1 q) -1 { -1 int -1 u -1 = -1 p; -1 int -1 v -1 = -1 q; -1 if -1 ((u -1 == -1 0) -1 || -1 (v -1 == -1 0)) -1 { -1 ++++ -1 +++if -1 +++((u -1 +++== -1 +++Integer.MIN_VALUE) -1 +++|| -1 +++(v -1 +++== -1 +++Integer.MIN_VALUE)) -1 +++{ -1 ++++ -1 +++throw -1 +++MathRuntimeException.createArithmeticException( -1 ++++ -1 +++"overflow: -1 +++gcd({0}, -1 +++{1}) -1 +++is -1 +++2^31", -1 ++++ -1 +++new -1 +++Object[] -1 +++{ -1 +++p, -1 +++q -1 +++}); -1 ++++ -1 +++} -1 return -1 (Math.abs(u) -1 + -1 Math.abs(v)); -1 } -1 // -1 keep -1 u -1 and -1 v -1 negative, -1 as -1 negative -1 integers -1 range -1 down -1 to -1 @@ -1 -711,6 -1 +716,9 -1 @@ -1 public -1 static -1 int -1 lcm(int -1 a, -1 int -1 b) -1 { -1 return -1 0; -1 } -1 int -1 lcm -1 = -1 Math.abs(mulAndCheck(a -1 / -1 gcd(a, -1 b), -1 b)); -1 ++++ -1 +++if -1 +++(lcm -1 +++== -1 +++Integer.MIN_VALUE){ -1 ++++ -1 +++throw -1 +++new -1 +++ArithmeticException("overflow: -1 +++lcm -1 +++is -1 +++2^31"); -1 ++++ -1 +++} -1 return -1 lcm; -1 } -1 -2
public -1 Fraction -1 parse(String -1 source, -1 ParsePosition -1 pos) -1 { -1 return -1 null; -1 } -1 ++++ -1 +++if -1 +++(num.intValue() -1 +++< -1 +++0) -1 +++{ -1 // -1 minus -1 signs -1 should -1 be -1 leading, -1 invalid -1 expression -1 ++++ -1 +++pos.setIndex(initialIndex); -1 ++++ -1 +++return -1 +++null; -1 ++++ -1 +++} -1 // -1 parse -1 '/' -1 int -1 startIndex -1 = -1 pos.getIndex(); -1 @@ -1 -197,7 -1 +201,11 -1 @@ -1 public -1 Fraction -1 parse(String -1 source, -1 ParsePosition -1 pos) -1 { -1 return -1 null; -1 } -1 ++++ -1 +++if -1 +++(den.intValue() -1 +++< -1 +++0) -1 +++{ -1 // -1 minus -1 signs -1 must -1 be -1 leading, -1 invalid -1 ++++ -1 +++pos.setIndex(initialIndex); -1 ++++ -1 +++return -1 +++null; -1 ++++ -1 +++} -1 int -1 w -1 = -1 whole.intValue(); -1 int -1 n -1 = -1 num.intValue(); -1 -2
public -1 void -1 captureArgumentsFrom(Invocation -1 invocation) -1 { -1 ((CapturesArguments) -1 m).captureFrom(invocation.getArgumentAt(position, -1 Object.class)); -1 } -1 } -1 ---- -1 ---for -1 ---(int -1 ---position -1 ---= -1 ---indexOfVararg; -1 ---position -1 ---< -1 ---matchers.size(); -1 ---position++) -1 ---{ -1 ---- -1 ---Matcher -1 ---m -1 ---= -1 ---matchers.get(position); -1 ++++ -1 +++for -1 +++(Matcher -1 +++m -1 +++: -1 +++uniqueMatcherSet(indexOfVararg)) -1 +++{ -1 if -1 (m -1 instanceof -1 CapturesArguments) -1 { -1 ---- -1 ---((CapturesArguments) -1 ---m).captureFrom(invocation.getRawArguments()[position -1 ---- -1 ---indexOfVararg]); -1 ++++ -1 +++Object -1 +++rawArgument -1 +++= -1 +++invocation.getRawArguments()[indexOfVararg]; -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++Array.getLength(rawArgument); -1 +++i++) -1 +++{ -1 ++++ -1 +++((CapturesArguments) -1 +++m).captureFrom(Array.get(rawArgument, -1 +++i)); -1 ++++ -1 +++} -1 } -1 } -1 } -1 else -1 { -1 @@ -1 -140,6 -1 +142,18 -1 @@ -1 public -1 void -1 captureArgumentsFrom(Invocation -1 invocation) -1 { -1 } -1 } -1 ++++ -1 +++private -1 +++Set<Matcher> -1 +++uniqueMatcherSet(int -1 +++indexOfVararg) -1 +++{ -1 ++++ -1 +++HashSet<Matcher> -1 +++set -1 +++= -1 +++new -1 +++HashSet<Matcher>(); -1 ++++ -1 +++for -1 +++(int -1 +++position -1 +++= -1 +++indexOfVararg; -1 +++position -1 +++< -1 +++matchers.size(); -1 +++position++) -1 +++{ -1 ++++ -1 +++Matcher -1 +++matcher -1 +++= -1 +++matchers.get(position); -1 ++++ -1 +++if(matcher -1 +++instanceof -1 +++MatcherDecorator) -1 +++{ -1 ++++ -1 +++set.add(((MatcherDecorator) -1 +++matcher).getActualMatcher()); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++set.add(matcher); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++set; -1 ++++ -1 +++} -1 public -1 static -1 List<InvocationMatcher> -1 createFrom(List<Invocation> -1 invocations) -1 { -1 LinkedList<InvocationMatcher> -1 out -1 = -1 new -1 LinkedList<InvocationMatcher>(); -1 -2
package -1 org.mockito.internal.util; -1 ++++import -1 +++org.mockito.exceptions.Reporter; -1 public -1 class -1 Timer -1 { -1 @@ -1 -7,6 -1 +8,7 -1 @@ -1 private -1 long -1 startTime -1 = -1 -1; -1 public -1 Timer(long -1 durationMillis) -1 { -1 ++++ -1 +++validateInput(durationMillis); -1 this.durationMillis -1 = -1 durationMillis; -1 } -1 @@ -1 -25,4 -1 +27,9 -1 @@ -1 public -1 void -1 start() -1 { -1 startTime -1 = -1 System.currentTimeMillis(); -1 } -1 ++++ -1 +++private -1 +++void -1 +++validateInput(long -1 +++durationMillis) -1 +++{ -1 ++++ -1 +++if -1 +++(durationMillis -1 +++< -1 +++0) -1 +++{ -1 ++++ -1 +++new -1 +++Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 } -1 -2
public -1 Location -1 getLocation() -1 { -1 public -1 void -1 captureArgumentsFrom(Invocation -1 invocation) -1 { -1 if -1 (invocation.getMethod().isVarArgs()) -1 { -1 int -1 indexOfVararg -1 = -1 invocation.getRawArguments().length -1 - -1 1; -1 ---- -1 ---throw -1 ---new -1 ---UnsupportedOperationException(); -1 ++++ -1 +++for -1 +++(int -1 +++position -1 +++= -1 +++0; -1 +++position -1 +++< -1 +++indexOfVararg; -1 +++position++) -1 +++{ -1 ++++ -1 +++Matcher -1 +++m -1 +++= -1 +++matchers.get(position); -1 ++++ -1 +++if -1 +++(m -1 +++instanceof -1 +++CapturesArguments) -1 +++{ -1 ++++ -1 +++((CapturesArguments) -1 +++m).captureFrom(invocation.getArgumentAt(position, -1 +++Object.class)); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++for -1 +++(int -1 +++position -1 +++= -1 +++indexOfVararg; -1 +++position -1 +++< -1 +++matchers.size(); -1 +++position++) -1 +++{ -1 ++++ -1 +++Matcher -1 +++m -1 +++= -1 +++matchers.get(position); -1 ++++ -1 +++if -1 +++(m -1 +++instanceof -1 +++CapturesArguments) -1 +++{ -1 ++++ -1 +++((CapturesArguments) -1 +++m).captureFrom(invocation.getRawArguments()[position -1 +++- -1 +++indexOfVararg]); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 } -1 else -1 { -1 for -1 (int -1 position -1 = -1 0; -1 position -1 < -1 matchers.size(); -1 position++) -1 { -1 -2
private -1 void -1 readTypeVariables() -1 { -1 for -1 (Type -1 type -1 : -1 typeVariable.getBounds()) -1 { -1 registerTypeVariablesOn(type); -1 } -1 ++++ -1 +++registerTypeParametersOn(new -1 +++TypeVariable[] -1 +++{ -1 +++typeVariable -1 +++}); -1 registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); -1 } -1 -2
public -1 void -1 noMoreInteractionsWanted(Invocation -1 undesired, -1 List<VerificationAwar -1 throw -1 new -1 NoInteractionsWanted(join( -1 "No -1 interactions -1 wanted -1 here:", -1 new -1 LocationImpl(), -1 ---- -1 ---"But -1 ---found -1 ---this -1 ---interaction -1 ---on -1 ---mock -1 ---'" -1 ---+ -1 ---undesired.getMock() -1 ---+ -1 ---"':", -1 ++++ -1 +++"But -1 +++found -1 +++this -1 +++interaction -1 +++on -1 +++mock -1 +++'" -1 ++++ -1 +++safelyGetMockName(undesired.getMock()) -1 ++++ -1 +++"':", -1 undesired.getLocation(), -1 scenario -1 )); -1 @@ -1 -431,7 -1 +431,7 -1 @@ -1 public -1 void -1 noMoreInteractionsWantedInOrder(Invocation -1 undesired) -1 { -1 throw -1 new -1 VerificationInOrderFailure(join( -1 "No -1 interactions -1 wanted -1 here:", -1 new -1 LocationImpl(), -1 ---- -1 ---"But -1 ---found -1 ---this -1 ---interaction -1 ---on -1 ---mock -1 ---'" -1 ---+ -1 ---undesired.getMock() -1 ---+ -1 ---"':", -1 ++++ -1 +++"But -1 +++found -1 +++this -1 +++interaction -1 +++on -1 +++mock -1 +++'" -1 ++++ -1 +++safelyGetMockName(undesired.getMock()) -1 ++++ -1 +++"':", -1 undesired.getLocation() -1 )); -1 } -1 @@ -1 -674,6 -1 +674,9 -1 @@ -1 public -1 void -1 cannotInjectDependency(Field -1 field, -1 Object -1 matchingMock, -1 Exception -1 d -1 } -1 private -1 String -1 exceptionCauseMessageIfAvailable(Exception -1 details) -1 { -1 ++++ -1 +++if -1 +++(details.getCause() -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++return -1 +++details.getMessage(); -1 ++++ -1 +++} -1 return -1 details.getCause().getMessage(); -1 } -1 -2
public -1 boolean -1 isAbstract() -1 { -1 */ -1 @Override -1 public -1 boolean -1 equals(Object -1 o) -1 { -1 ++++ -1 +++if -1 +++(this -1 +++== -1 +++o) -1 +++{ -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(o -1 +++instanceof -1 +++DelegatingMethod) -1 +++{ -1 ++++ -1 +++DelegatingMethod -1 +++that -1 +++= -1 +++(DelegatingMethod) -1 +++o; -1 ++++ -1 +++return -1 +++method.equals(that.method); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 return -1 method.equals(o); -1 ++++ -1 +++} -1 } -1 @Override -1 public -1 int -1 hashCode() -1 { -1 ---- -1 ---return -1 ---1; -1 ++++ -1 +++return -1 +++method.hashCode(); -1 } -1 } -1 \ -1 No -1 newline -1 at -1 end -1 of -1 file -1 -2
import -1 org.mockito.internal.util.MockUtil; -1 import -1 org.mockito.internal.util.reflection.GenericMetadataSupport; -1 import -1 org.mockito.invocation.InvocationOnMock; -1 ++++import -1 +++org.mockito.mock.MockCreationSettings; -1 import -1 org.mockito.stubbing.Answer; -1 import -1 java.io.IOException; -1 @@ -1 -68,7 -1 +69,7 -1 @@ -1 private -1 Object -1 deepStub(InvocationOnMock -1 invocation, -1 GenericMetadataSupport -1 retu -1 // -1 record -1 deep -1 stub -1 answer -1 return -1 recordDeepStubAnswer( -1 ---- -1 ---newDeepStubMock(returnTypeGenericMetadata), -1 ++++ -1 +++newDeepStubMock(returnTypeGenericMetadata, -1 +++invocation.getMock()), -1 container -1 ); -1 } -1 @@ -1 -84,22 -1 +85,26 -1 @@ -1 private -1 Object -1 deepStub(InvocationOnMock -1 invocation, -1 GenericMetadataSupport -1 retu -1 * -1 @param -1 parentMock -1 The -1 parent -1 of -1 the -1 current -1 deep -1 stub -1 mock. -1 * -1 @return -1 The -1 mock -1 */ -1 ---- -1 ---private -1 ---Object -1 ---newDeepStubMock(GenericMetadataSupport -1 ---returnTypeGenericMetadata) -1 ---{ -1 ++++ -1 +++private -1 +++Object -1 +++newDeepStubMock(GenericMetadataSupport -1 +++returnTypeGenericMetadata, -1 +++Object -1 +++parentMock) -1 +++{ -1 ++++ -1 +++MockCreationSettings -1 +++parentMockSettings -1 +++= -1 +++new -1 +++MockUtil().getMockSettings(parentMock); -1 return -1 mockitoCore().mock( -1 returnTypeGenericMetadata.rawType(), -1 ---- -1 ---withSettingsUsing(returnTypeGenericMetadata) -1 ++++ -1 +++withSettingsUsing(returnTypeGenericMetadata, -1 +++parentMockSettings) -1 ); -1 } -1 ---- -1 ---private -1 ---MockSettings -1 ---withSettingsUsing(GenericMetadataSupport -1 ---returnTypeGenericMetadata) -1 ---{ -1 ++++ -1 +++private -1 +++MockSettings -1 +++withSettingsUsing(GenericMetadataSupport -1 +++returnTypeGenericMetadata, -1 +++MockCreationSettings -1 +++parentMockSettings) -1 +++{ -1 MockSettings -1 mockSettings -1 = -1 returnTypeGenericMetadata.hasRawExtraInterfaces() -1 ? -1 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces()) -1 : -1 withSettings(); -1 ---- -1 ---return -1 ---mockSettings.serializable() -1 ++++ -1 +++return -1 +++propagateSerializationSettings(mockSettings, -1 +++parentMockSettings) -1 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata)); -1 } -1 ++++ -1 +++private -1 +++MockSettings -1 +++propagateSerializationSettings(MockSettings -1 +++mockSettings, -1 +++MockCreationSettings -1 +++parentMockSettings) -1 +++{ -1 ++++ -1 +++return -1 +++mockSettings.serializable(parentMockSettings.getSerializableMode()); -1 ++++ -1 +++} -1 private -1 ReturnsDeepStubs -1 returnsDeepStubsAnswerUsing(final -1 GenericMetadataSupport -1 returnTypeGenericMetadata) -1 { -1 return -1 new -1 ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata); -1 -2
public -1 void -1 verify(VerificationData -1 data) -1 { -1 } -1 catch -1 (MockitoAssertionError -1 e) -1 { -1 error -1 = -1 handleVerifyException(e); -1 } -1 ---- -1 ---catch -1 ---(org.mockito.exceptions.verification.junit.ArgumentsAreDifferent -1 ---e) -1 ---{ -1 ++++ -1 +++catch -1 +++(AssertionError -1 +++e) -1 +++{ -1 error -1 = -1 handleVerifyException(e); -1 } -1 } -1 -2
* -1 @return -1 <code>false</code>. -1 */ -1 public -1 static -1 boolean -1 anyBoolean() -1 { -1 ---- -1 ---return -1 ---reportMatcher(Any.ANY).returnFalse(); -1 ++++ -1 +++return -1 +++reportMatcher(new -1 +++InstanceOf(Boolean.class)).returnFalse(); -1 } -1 /** -1 @@ -1 -134,7 -1 +134,7 -1 @@ -1 public -1 static -1 boolean -1 anyBoolean() -1 { -1 * -1 @return -1 <code>0</code>. -1 */ -1 public -1 static -1 byte -1 anyByte() -1 { -1 ---- -1 ---return -1 ---reportMatcher(Any.ANY).returnZero(); -1 ++++ -1 +++return -1 +++reportMatcher(new -1 +++InstanceOf(Byte.class)).returnZero(); -1 } -1 /** -1 @@ -1 -149,7 -1 +149,7 -1 @@ -1 public -1 static -1 byte -1 anyByte() -1 { -1 * -1 @return -1 <code>0</code>. -1 */ -1 public -1 static -1 char -1 anyChar() -1 { -1 ---- -1 ---return -1 ---reportMatcher(Any.ANY).returnChar(); -1 ++++ -1 +++return -1 +++reportMatcher(new -1 +++InstanceOf(Character.class)).returnChar(); -1 } -1 /** -1 @@ -1 -164,7 -1 +164,7 -1 @@ -1 public -1 static -1 char -1 anyChar() -1 { -1 * -1 @return -1 <code>0</code>. -1 */ -1 public -1 static -1 int -1 anyInt() -1 { -1 ---- -1 ---return -1 ---reportMatcher(Any.ANY).returnZero(); -1 ++++ -1 +++return -1 +++reportMatcher(new -1 +++InstanceOf(Integer.class)).returnZero(); -1 } -1 /** -1 @@ -1 -179,7 -1 +179,7 -1 @@ -1 public -1 static -1 int -1 anyInt() -1 { -1 * -1 @return -1 <code>0</code>. -1 */ -1 public -1 static -1 long -1 anyLong() -1 { -1 ---- -1 ---return -1 ---reportMatcher(Any.ANY).returnZero(); -1 ++++ -1 +++return -1 +++reportMatcher(new -1 +++InstanceOf(Long.class)).returnZero(); -1 } -1 /** -1 @@ -1 -194,7 -1 +194,7 -1 @@ -1 public -1 static -1 long -1 anyLong() -1 { -1 * -1 @return -1 <code>0</code>. -1 */ -1 public -1 static -1 float -1 anyFloat() -1 { -1 ---- -1 ---return -1 ---reportMatcher(Any.ANY).returnZero(); -1 ++++ -1 +++return -1 +++reportMatcher(new -1 +++InstanceOf(Float.class)).returnZero(); -1 } -1 /** -1 @@ -1 -209,7 -1 +209,7 -1 @@ -1 public -1 static -1 float -1 anyFloat() -1 { -1 * -1 @return -1 <code>0</code>. -1 */ -1 public -1 static -1 double -1 anyDouble() -1 { -1 ---- -1 ---return -1 ---reportMatcher(Any.ANY).returnZero(); -1 ++++ -1 +++return -1 +++reportMatcher(new -1 +++InstanceOf(Double.class)).returnZero(); -1 } -1 /** -1 @@ -1 -224,7 -1 +224,7 -1 @@ -1 public -1 static -1 double -1 anyDouble() -1 { -1 * -1 @return -1 <code>0</code>. -1 */ -1 public -1 static -1 short -1 anyShort() -1 { -1 ---- -1 ---return -1 ---reportMatcher(Any.ANY).returnZero(); -1 ++++ -1 +++return -1 +++reportMatcher(new -1 +++InstanceOf(Short.class)).returnZero(); -1 } -1 /** -1 @@ -1 -241,7 -1 +241,7 -1 @@ -1 public -1 static -1 short -1 anyShort() -1 { -1 * -1 @return -1 <code>null</code>. -1 */ -1 public -1 static -1 <T> -1 T -1 anyObject() -1 { -1 ---- -1 ---return -1 ---(T) -1 ---reportMatcher(Any.ANY).returnNull(); -1 ++++ -1 +++return -1 +++(T) -1 +++reportMatcher(new -1 +++InstanceOf(Object.class)).returnNull(); -1 } -1 /** -1 @@ -1 -289,7 -1 +289,7 -1 @@ -1 public -1 static -1 short -1 anyShort() -1 { -1 * -1 @return -1 <code>null</code>. -1 */ -1 public -1 static -1 <T> -1 T -1 any(Class<T> -1 clazz) -1 { -1 ---- -1 ---return -1 ---(T) -1 ---reportMatcher(Any.ANY).returnFor(clazz); -1 ++++ -1 +++return -1 +++(T) -1 +++reportMatcher(new -1 +++InstanceOf(clazz)).returnFor(clazz); -1 } -1 /** -1 @@ -1 -306,7 -1 +306,7 -1 @@ -1 public -1 static -1 short -1 anyShort() -1 { -1 * -1 @return -1 <code>null</code>. -1 */ -1 public -1 static -1 <T> -1 T -1 any() -1 { -1 ---- -1 ---return -1 ---(T) -1 ---anyObject(); -1 ++++ -1 +++return -1 +++(T) -1 +++reportMatcher(Any.ANY).returnNull(); -1 } -1 /** -1 @@ -1 -321,7 -1 +321,7 -1 @@ -1 public -1 static -1 short -1 anyShort() -1 { -1 * -1 @return -1 empty -1 String -1 ("") -1 */ -1 public -1 static -1 String -1 anyString() -1 { -1 ---- -1 ---return -1 ---reportMatcher(Any.ANY).returnString(); -1 ++++ -1 +++return -1 +++reportMatcher(new -1 +++InstanceOf(String.class)).returnString(); -1 } -1 /** -1 @@ -1 -336,7 -1 +336,7 -1 @@ -1 public -1 static -1 String -1 anyString() -1 { -1 * -1 @return -1 empty -1 List. -1 */ -1 public -1 static -1 List -1 anyList() -1 { -1 ---- -1 ---return -1 ---reportMatcher(Any.ANY).returnList(); -1 ++++ -1 +++return -1 +++reportMatcher(new -1 +++InstanceOf(List.class)).returnList(); -1 } -1 /** -1 @@ -1 -355,7 -1 +355,7 -1 @@ -1 public -1 static -1 List -1 anyList() -1 { -1 * -1 @return -1 empty -1 List. -1 */ -1 public -1 static -1 <T> -1 List<T> -1 anyListOf(Class<T> -1 clazz) -1 { -1 ---- -1 ---return -1 ---(List) -1 ---reportMatcher(Any.ANY).returnList(); -1 ++++ -1 +++return -1 +++anyList(); -1 } -1 /** -1 @@ -1 -370,7 -1 +370,7 -1 @@ -1 public -1 static -1 List -1 anyList() -1 { -1 * -1 @return -1 empty -1 Set -1 */ -1 public -1 static -1 Set -1 anySet() -1 { -1 ---- -1 ---return -1 ---reportMatcher(Any.ANY).returnSet(); -1 ++++ -1 +++return -1 +++reportMatcher(new -1 +++InstanceOf(Set.class)).returnSet(); -1 } -1 /** -1 @@ -1 -389,7 -1 +389,7 -1 @@ -1 public -1 static -1 Set -1 anySet() -1 { -1 * -1 @return -1 empty -1 Set -1 */ -1 public -1 static -1 <T> -1 Set<T> -1 anySetOf(Class<T> -1 clazz) -1 { -1 ---- -1 ---return -1 ---(Set) -1 ---reportMatcher(Any.ANY).returnSet(); -1 ++++ -1 +++return -1 +++anySet(); -1 } -1 /** -1 @@ -1 -404,7 -1 +404,7 -1 @@ -1 public -1 static -1 Set -1 anySet() -1 { -1 * -1 @return -1 empty -1 Map. -1 */ -1 public -1 static -1 Map -1 anyMap() -1 { -1 ---- -1 ---return -1 ---reportMatcher(Any.ANY).returnMap(); -1 ++++ -1 +++return -1 +++reportMatcher(new -1 +++InstanceOf(Map.class)).returnMap(); -1 } -1 /** -1 @@ -1 -424,7 -1 +424,7 -1 @@ -1 public -1 static -1 Map -1 anyMap() -1 { -1 * -1 @return -1 empty -1 Map. -1 */ -1 public -1 static -1 <K, -1 V> -1 Map<K, -1 V> -1 anyMapOf(Class<K> -1 keyClazz, -1 Class<V> -1 valueClazz) -1 { -1 ---- -1 ---return -1 ---reportMatcher(Any.ANY).returnMap(); -1 ++++ -1 +++return -1 +++anyMap(); -1 } -1 /** -1 @@ -1 -439,7 -1 +439,7 -1 @@ -1 public -1 static -1 Map -1 anyMap() -1 { -1 * -1 @return -1 empty -1 Collection. -1 */ -1 public -1 static -1 Collection -1 anyCollection() -1 { -1 ---- -1 ---return -1 ---reportMatcher(Any.ANY).returnList(); -1 ++++ -1 +++return -1 +++reportMatcher(new -1 +++InstanceOf(Collection.class)).returnList(); -1 } -1 /** -1 @@ -1 -458,7 -1 +458,7 -1 @@ -1 public -1 static -1 Collection -1 anyCollection() -1 { -1 * -1 @return -1 empty -1 Collection. -1 */ -1 public -1 static -1 <T> -1 Collection<T> -1 anyCollectionOf(Class<T> -1 clazz) -1 { -1 ---- -1 ---return -1 ---(Collection) -1 ---reportMatcher(Any.ANY).returnList(); -1 ++++ -1 +++return -1 +++anyCollection(); -1 } -1 /** -1 -2
package -1 org.mockito.internal.stubbing.answers; -1 import -1 java.io.Serializable; -1 ++++import -1 +++java.lang.reflect.Modifier; -1 ++++import -1 +++org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer; -1 import -1 org.mockito.invocation.InvocationOnMock; -1 import -1 org.mockito.stubbing.Answer; -1 @@ -1 -33,6 -1 +35,9 -1 @@ -1 private -1 static -1 final -1 long -1 serialVersionUID -1 = -1 9057165148930624087L; -1 public -1 Object -1 answer(InvocationOnMock -1 invocation) -1 throws -1 Throwable -1 { -1 ++++ -1 +++if -1 +++(Modifier.isAbstract(invocation.getMethod().getModifiers())) -1 +++{ -1 ++++ -1 +++return -1 +++new -1 +++GloballyConfiguredAnswer().answer(invocation); -1 ++++ -1 +++} -1 return -1 invocation.callRealMethod(); -1 } -1 } -1 \ -1 No -1 newline -1 at -1 end -1 of -1 file -1 -2
protected -1 void -1 registerTypeVariablesOn(Type -1 classType) -1 { -1 if -1 (actualTypeArgument -1 instanceof -1 WildcardType) -1 { -1 contextualActualTypeParameters.put(typeParameter, -1 boundsOf((WildcardType) -1 actualTypeArgument)); -1 ---- -1 ---} -1 ---else -1 ---{ -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(typeParameter -1 +++!= -1 +++actualTypeArgument) -1 +++{ -1 contextualActualTypeParameters.put(typeParameter, -1 actualTypeArgument); -1 } -1 // -1 logger.log("For -1 '" -1 + -1 parameterizedType -1 + -1 "' -1 found -1 type -1 variable -1 : -1 { -1 '" -1 + -1 typeParameter -1 + -1 "(" -1 + -1 System.identityHashCode(typeParameter) -1 + -1 ")" -1 + -1 "' -1 : -1 '" -1 + -1 actualTypeArgument -1 + -1 "(" -1 + -1 System.identityHashCode(typeParameter) -1 + -1 ")" -1 + -1 "' -1 }"); -1 -2
/* -1 * -1 Copyright -1 (c) -1 2007 -1 Mockito -1 contributors -1 * -1 This -1 program -1 is -1 made -1 available -1 under -1 the -1 terms -1 of -1 the -1 MIT -1 License. -1 */ -1 package -1 org.mockito; -1 import -1 org.mockito.internal.MockitoCore; -1 import -1 org.mockito.internal.creation.MockSettingsImpl; -1 import -1 org.mockito.internal.debugging.MockitoDebuggerImpl; -1 import -1 org.mockito.internal.stubbing.answers.*; -1 import -1 org.mockito.internal.stubbing.defaultanswers.*; -1 import -1 org.mockito.internal.verification.VerificationModeFactory; -1 import -1 org.mockito.internal.verification.api.VerificationMode; -1 import -1 org.mockito.runners.MockitoJUnitRunner; -1 import -1 org.mockito.stubbing.*; -1 /** -1 * -1 <p -1 align="left"><img -1 src="logo.jpg"/></p> -1 * -1 Mockito -1 library -1 enables -1 mocks -1 creation, -1 verification -1 and -1 stubbing. -1 * -1 <p> -1 * -1 This -1 javadoc -1 content -1 is -1 also -1 available -1 on -1 the -1 <a -1 href="http://mockito.org">http://mockito.org</a> -1 web -1 page. -1 * -1 All -1 documentation -1 is -1 kept -1 in -1 javadocs -1 because -1 it -1 guarantees -1 consistency -1 between -1 what's -1 on -1 the -1 web -1 and -1 what's -1 in -1 the -1 source -1 code. -1 * -1 Also, -1 it -1 makes -1 possible -1 to -1 access -1 documentation -1 straight -1 from -1 the -1 IDE -1 even -1 if -1 you -1 work -1 offline. -1 * -1 * -1 <h1>Contents</h1> -1 * -1 * -1 <b> -1 * -1 <a -1 href="#1">1. -1 Let's -1 verify -1 some -1 behaviour! -1 </a><br/> -1 * -1 <a -1 href="#2">2. -1 How -1 about -1 some -1 stubbing? -1 </a><br/> -1 * -1 <a -1 href="#3">3. -1 Argument -1 matchers -1 </a><br/> -1 * -1 <a -1 href="#4">4. -1 Verifying -1 exact -1 number -1 of -1 invocations -1 / -1 at -1 least -1 once -1 / -1 never -1 </a><br/> -1 * -1 <a -1 href="#5">5. -1 Stubbing -1 void -1 methods -1 with -1 exceptions -1 </a><br/> -1 * -1 <a -1 href="#6">6. -1 Verification -1 in -1 order -1 </a><br/> -1 * -1 <a -1 href="#7">7. -1 Making -1 sure -1 interaction(s) -1 never -1 happened -1 on -1 mock -1 </a><br/> -1 * -1 <a -1 href="#8">8. -1 Finding -1 redundant -1 invocations -1 </a><br/> -1 * -1 <a -1 href="#9">9. -1 Shorthand -1 for -1 mocks -1 creation -1 - -1 &#064;Mock -1 annotation -1 </a><br/> -1 * -1 <a -1 href="#10">10. -1 Stubbing -1 consecutive -1 calls -1 (iterator-style -1 stubbing) -1 </a><br/> -1 * -1 <a -1 href="#11">11. -1 Stubbing -1 with -1 callbacks -1 </a><br/> -1 * -1 <a -1 href="#12">12. -1 doThrow()|doAnswer()|doNothing()|doReturn() -1 family -1 of -1 methods -1 mostly -1 for -1 stubbing -1 voids -1 </a><br/> -1 * -1 <a -1 href="#13">13. -1 Spying -1 on -1 real -1 objects -1 </a><br/> -1 * -1 <a -1 href="#14">14. -1 Changing -1 default -1 return -1 values -1 of -1 unstubbed -1 invocations -1 (Since -1 1.7) -1 </a><br/> -1 * -1 <a -1 href="#15">15. -1 Capturing -1 arguments -1 for -1 further -1 assertions -1 (Since -1 1.8.0) -1 </a><br/> -1 * -1 <a -1 href="#16">16. -1 Real -1 partial -1 mocks -1 (Since -1 1.8.0) -1 </a><br/> -1 * -1 <a -1 href="#17">17. -1 Resetting -1 mocks -1 (Since -1 1.8.0) -1 </a><br/> -1 * -1 <a -1 href="#18">18. -1 Troubleshooting -1 & -1 validating -1 framework -1 usage -1 (Since -1 1.8.0) -1 </a><br/> -1 * -1 <a -1 href="#19">19. -1 Aliases -1 for -1 behavior -1 driven -1 development -1 (Since -1 1.8.0) -1 </a><br/> -1 * -1 <a -1 href="#20">20. -1 (**New**) -1 Serializable -1 mocks -1 (Since -1 1.8.1) -1 </a><br/> -1 * -1 </b> -1 * -1 * -1 <p> -1 * -1 Following -1 examples -1 mock -1 a -1 List, -1 because -1 everyone -1 knows -1 its -1 interface -1 (methods -1 * -1 like -1 add(), -1 get(), -1 clear() -1 will -1 be -1 used). -1 <br> -1 * -1 You -1 probably -1 wouldn't -1 mock -1 List -1 class -1 'in -1 real'. -1 * -1 * -1 <h3 -1 id="1">1. -1 Let's -1 verify -1 some -1 behaviour!</h3> -1 * -1 * -1 <pre> -1 * -1 //Let's -1 import -1 Mockito -1 statically -1 so -1 that -1 the -1 code -1 looks -1 clearer -1 * -1 import -1 static -1 org.mockito.Mockito.*; -1 * -1 * -1 //mock -1 creation -1 * -1 List -1 mockedList -1 = -1 mock(List.class); -1 * -1 * -1 //using -1 mock -1 object -1 * -1 mockedList.add("one"); -1 * -1 mockedList.clear(); -1 * -1 * -1 //verification -1 * -1 verify(mockedList).add("one"); -1 * -1 verify(mockedList).clear(); -1 * -1 </pre> -1 * -1 * -1 <p> -1 * -1 Once -1 created, -1 mock -1 will -1 remember -1 all -1 interactions. -1 Then -1 you -1 can -1 selectively -1 * -1 verify -1 whatever -1 interaction -1 you -1 are -1 interested -1 in. -1 * -1 * -1 <h3 -1 id="2">2. -1 How -1 about -1 some -1 stubbing?</h3> -1 * -1 * -1 <pre> -1 * -1 //You -1 can -1 mock -1 concrete -1 classes, -1 not -1 only -1 interfaces -1 * -1 LinkedList -1 mockedList -1 = -1 mock(LinkedList.class); -1 * -1 * -1 //stubbing -1 * -1 when(mockedList.get(0)).thenReturn("first"); -1 * -1 when(mockedList.get(1)).thenThrow(new -1 RuntimeException()); -1 * -1 * -1 //following -1 prints -1 "first" -1 * -1 System.out.println(mockedList.get(0)); -1 * -1 * -1 //following -1 throws -1 runtime -1 exception -1 * -1 System.out.println(mockedList.get(1)); -1 * -1 * -1 //following -1 prints -1 "null" -1 because -1 get(999) -1 was -1 not -1 stubbed -1 * -1 System.out.println(mockedList.get(999)); -1 * -1 * -1 //Although -1 it -1 is -1 possible -1 to -1 verify -1 a -1 stubbed -1 invocation, -1 usually -1 <b>it's -1 just -1 redundant</b> -1 * -1 //If -1 your -1 code -1 cares -1 what -1 get(0) -1 returns -1 then -1 something -1 else -1 breaks -1 (often -1 before -1 even -1 verify() -1 gets -1 executed). -1 * -1 //If -1 your -1 code -1 doesn't -1 care -1 what -1 get(0) -1 returns -1 then -1 it -1 should -1 not -1 be -1 stubbed. -1 Not -1 convinced? -1 See -1 <a -1 href="http://monkeyisland.pl/2008/04/26/asking-and-telling">here</a>. -1 * -1 verify(mockedList).get(0); -1 * -1 </pre> -1 * -1 * -1 <ul> -1 * -1 <li> -1 By -1 default, -1 for -1 all -1 methods -1 that -1 return -1 value, -1 mock -1 returns -1 null, -1 an -1 * -1 empty -1 collection -1 or -1 appropriate -1 primitive/primitive -1 wrapper -1 value -1 (e.g: -1 0, -1 * -1 false, -1 ... -1 for -1 int/Integer, -1 boolean/Boolean, -1 ...). -1 </li> -1 * -1 * -1 <li> -1 Stubbing -1 can -1 be -1 overridden: -1 for -1 example -1 common -1 stubbing -1 can -1 go -1 to -1 * -1 fixture -1 setup -1 but -1 the -1 test -1 methods -1 can -1 override -1 it. -1 * -1 Please -1 note -1 that -1 overridding -1 stubbing -1 is -1 a -1 potential -1 code -1 smell -1 that -1 points -1 out -1 too -1 much -1 stubbing</li> -1 * -1 * -1 <li> -1 Once -1 stubbed, -1 the -1 method -1 will -1 always -1 return -1 stubbed -1 value -1 regardless -1 * -1 of -1 how -1 many -1 times -1 it -1 is -1 called. -1 </li> -1 * -1 * -1 <li> -1 Last -1 stubbing -1 is -1 more -1 important -1 - -1 when -1 you -1 stubbed -1 the -1 same -1 method -1 with -1 * -1 the -1 same -1 arguments -1 many -1 times. -1 </li> -1 * -1 * -1 </ul> -1 * -1 * -1 <h3 -1 id="3">3. -1 Argument -1 matchers</h3> -1 * -1 * -1 Mockito -1 verifies -1 argument -1 values -1 in -1 natural -1 java -1 style: -1 by -1 using -1 an -1 equals() -1 method. -1 * -1 Sometimes, -1 when -1 extra -1 flexibility -1 is -1 required -1 then -1 you -1 might -1 use -1 argument -1 matchers: -1 * -1 * -1 <pre> -1 * -1 //stubbing -1 using -1 built-in -1 anyInt() -1 argument -1 matcher -1 * -1 when(mockedList.get(anyInt())).thenReturn("element"); -1 * -1 * -1 //stubbing -1 using -1 hamcrest -1 (let's -1 say -1 isValid() -1 returns -1 your -1 own -1 hamcrest -1 matcher): -1 * -1 when(mockedList.contains(argThat(isValid()))).thenReturn("element"); -1 * -1 * -1 //following -1 prints -1 "element" -1 * -1 System.out.println(mockedList.get(999)); -1 * -1 * -1 //<b>you -1 can -1 also -1 verify -1 using -1 an -1 argument -1 matcher</b> -1 * -1 verify(mockedList).get(anyInt()); -1 * -1 </pre> -1 * -1 * -1 <p> -1 * -1 Argument -1 matchers -1 allow -1 flexible -1 verification -1 or -1 stubbing. -1 * -1 {@link -1 Matchers -1 Click -1 here -1 to -1 see} -1 more -1 built-in -1 matchers -1 * -1 and -1 examples -1 of -1 <b>custom -1 argument -1 matchers -1 / -1 hamcrest -1 matchers</b>. -1 * -1 <p> -1 * -1 For -1 information -1 solely -1 on -1 <b>custom -1 argument -1 matchers</b> -1 check -1 out -1 javadoc -1 for -1 {@link -1 ArgumentMatcher} -1 class. -1 * -1 <p> -1 * -1 Be -1 reasonable -1 with -1 using -1 complicated -1 argument -1 matching. -1 * -1 The -1 natural -1 matching -1 style -1 using -1 equals() -1 with -1 occasional -1 anyX() -1 matchers -1 tend -1 to -1 give -1 clean -1 & -1 simple -1 tests. -1 * -1 Sometimes -1 it's -1 just -1 better -1 to -1 refactor -1 the -1 code -1 to -1 allow -1 equals() -1 matching -1 or -1 even -1 implement -1 equals() -1 method -1 to -1 help -1 out -1 with -1 testing. -1 * -1 <p> -1 * -1 Also, -1 read -1 <a -1 href="#15">section -1 15</a> -1 or -1 javadoc -1 for -1 {@link -1 ArgumentCaptor} -1 class. -1 * -1 {@link -1 ArgumentCaptor} -1 is -1 a -1 special -1 implementation -1 of -1 an -1 argument -1 matcher -1 that -1 captures -1 argument -1 values -1 for -1 further -1 assertions. -1 * -1 <p> -1 * -1 <b>Warning -1 on -1 argument -1 matchers:</b> -1 * -1 <p> -1 * -1 If -1 you -1 are -1 using -1 argument -1 matchers, -1 <b>all -1 arguments</b> -1 have -1 to -1 be -1 provided -1 * -1 by -1 matchers. -1 * -1 <p> -1 * -1 E.g: -1 (example -1 shows -1 verification -1 but -1 the -1 same -1 applies -1 to -1 stubbing): -1 * -1 * -1 <pre> -1 * -1 verify(mock).someMethod(anyInt(), -1 anyString(), -1 <b>eq("third -1 argument")</b>); -1 * -1 //above -1 is -1 correct -1 - -1 eq() -1 is -1 also -1 an -1 argument -1 matcher -1 * -1 * -1 verify(mock).someMethod(anyInt(), -1 anyString(), -1 <b>"third -1 argument"</b>); -1 * -1 //above -1 is -1 incorrect -1 - -1 exception -1 will -1 be -1 thrown -1 because -1 third -1 argument -1 is -1 given -1 without -1 an -1 argument -1 matcher. -1 * -1 </pre> -1 * -1 * -1 <h3 -1 id="4">4. -1 Verifying -1 exact -1 number -1 of -1 invocations -1 / -1 at -1 least -1 x -1 / -1 never</h3> -1 * -1 * -1 <pre> -1 * -1 //using -1 mock -1 * -1 mockedList.add("once"); -1 * -1 * -1 mockedList.add("twice"); -1 * -1 mockedList.add("twice"); -1 * -1 * -1 mockedList.add("three -1 times"); -1 * -1 mockedList.add("three -1 times"); -1 * -1 mockedList.add("three -1 times"); -1 * -1 * -1 //following -1 two -1 verifications -1 work -1 exactly -1 the -1 same -1 - -1 times(1) -1 is -1 used -1 by -1 default -1 * -1 verify(mockedList).add("once"); -1 * -1 verify(mockedList, -1 times(1)).add("once"); -1 * -1 * -1 //exact -1 number -1 of -1 invocations -1 verification -1 * -1 verify(mockedList, -1 times(2)).add("twice"); -1 * -1 verify(mockedList, -1 times(3)).add("three -1 times"); -1 * -1 * -1 //verification -1 using -1 never(). -1 never() -1 is -1 an -1 alias -1 to -1 times(0) -1 * -1 verify(mockedList, -1 never()).add("never -1 happened"); -1 * -1 * -1 //verification -1 using -1 atLeast()/atMost() -1 * -1 verify(mockedList, -1 atLeastOnce()).add("three -1 times"); -1 * -1 verify(mockedList, -1 atLeast(2)).add("five -1 times"); -1 * -1 verify(mockedList, -1 atMost(5)).add("three -1 times"); -1 * -1 * -1 </pre> -1 * -1 * -1 <p> -1 * -1 <b>times(1) -1 is -1 the -1 default.</b> -1 Therefore -1 using -1 times(1) -1 explicitly -1 can -1 be -1 * -1 omitted. -1 * -1 * -1 <h3 -1 id="5">5. -1 Stubbing -1 void -1 methods -1 with -1 exceptions</h3> -1 * -1 * -1 <pre> -1 * -1 doThrow(new -1 RuntimeException()).when(mockedList).clear(); -1 * -1 * -1 //following -1 throws -1 RuntimeException: -1 * -1 mockedList.clear(); -1 * -1 </pre> -1 * -1 * -1 Read -1 more -1 about -1 doThrow|doAnswer -1 family -1 of -1 methods -1 in -1 paragraph -1 12. -1 * -1 <p> -1 * -1 Initially, -1 {@link -1 Mockito#stubVoid(Object)} -1 was -1 used -1 for -1 stubbing -1 voids. -1 * -1 Currently -1 stubVoid() -1 is -1 deprecated -1 in -1 favor -1 of -1 {@link -1 Mockito#doThrow(Throwable)}. -1 * -1 This -1 is -1 because -1 of -1 improved -1 readability -1 and -1 consistency -1 with -1 the -1 family -1 of -1 {@link -1 Mockito#doAnswer(Answer)} -1 methods. -1 * -1 * -1 <h3 -1 id="6">6. -1 Verification -1 in -1 order</h3> -1 * -1 * -1 <pre> -1 * -1 List -1 firstMock -1 = -1 mock(List.class); -1 * -1 List -1 secondMock -1 = -1 mock(List.class); -1 * -1 * -1 //using -1 mocks -1 * -1 firstMock.add("was -1 called -1 first"); -1 * -1 secondMock.add("was -1 called -1 second"); -1 * -1 * -1 //create -1 inOrder -1 object -1 passing -1 any -1 mocks -1 that -1 need -1 to -1 be -1 verified -1 in -1 order -1 * -1 InOrder -1 inOrder -1 = -1 inOrder(firstMock, -1 secondMock); -1 * -1 * -1 //following -1 will -1 make -1 sure -1 that -1 firstMock -1 was -1 called -1 before -1 secondMock -1 * -1 inOrder.verify(firstMock).add("was -1 called -1 first"); -1 * -1 inOrder.verify(secondMock).add("was -1 called -1 second"); -1 * -1 </pre> -1 * -1 * -1 Verification -1 in -1 order -1 is -1 flexible -1 - -1 <b>you -1 don't -1 have -1 to -1 verify -1 all -1 * -1 interactions</b> -1 one-by-one -1 but -1 only -1 those -1 that -1 you -1 are -1 interested -1 in -1 * -1 testing -1 in -1 order. -1 * -1 <p> -1 * -1 Also, -1 you -1 can -1 create -1 InOrder -1 object -1 passing -1 only -1 mocks -1 that -1 are -1 relevant -1 for -1 * -1 in-order -1 verification. -1 * -1 * -1 <h3 -1 id="7">7. -1 Making -1 sure -1 interaction(s) -1 never -1 happened -1 on -1 mock</h3> -1 * -1 * -1 <pre> -1 * -1 //using -1 mocks -1 - -1 only -1 mockOne -1 is -1 interacted -1 * -1 mockOne.add("one"); -1 * -1 * -1 //ordinary -1 verification -1 * -1 verify(mockOne).add("one"); -1 * -1 * -1 //verify -1 that -1 method -1 was -1 never -1 called -1 on -1 a -1 mock -1 * -1 verify(mockOne, -1 never()).add("two"); -1 * -1 * -1 //verify -1 that -1 other -1 mocks -1 were -1 not -1 interacted -1 * -1 verifyZeroInteractions(mockTwo, -1 mockThree); -1 * -1 * -1 </pre> -1 * -1 * -1 <h3 -1 id="8">8. -1 Finding -1 redundant -1 invocations</h3> -1 * -1 * -1 <pre> -1 * -1 //using -1 mocks -1 * -1 mockedList.add("one"); -1 * -1 mockedList.add("two"); -1 * -1 * -1 verify(mockedList).add("one"); -1 * -1 * -1 //following -1 verification -1 will -1 fail -1 * -1 verifyNoMoreInteractions(mockedList); -1 * -1 </pre> -1 * -1 * -1 A -1 word -1 of -1 <b>warning</b>: -1 * -1 Some -1 users -1 who -1 did -1 a -1 lot -1 of -1 classic, -1 expect-run-verify -1 mocking -1 tend -1 to -1 use -1 verifyNoMoreInteractions() -1 very -1 often, -1 even -1 in -1 every -1 test -1 method. -1 * -1 verifyNoMoreInteractions() -1 is -1 not -1 recommended -1 to -1 use -1 in -1 every -1 test -1 method. -1 * -1 verifyNoMoreInteractions() -1 is -1 a -1 handy -1 assertion -1 from -1 the -1 interaction -1 testing -1 toolkit. -1 Use -1 it -1 only -1 when -1 it's -1 relevant. -1 * -1 Abusing -1 it -1 leads -1 to -1 overspecified, -1 less -1 maintainable -1 tests. -1 You -1 can -1 find -1 further -1 reading -1 * -1 <a -1 href="http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/">here</a>. -1 * -1 * -1 <p> -1 * -1 See -1 also -1 {@link -1 Mockito#never()} -1 - -1 it -1 is -1 more -1 explicit -1 and -1 * -1 communicates -1 the -1 intent -1 well. -1 * -1 <p> -1 * -1 * -1 <h3 -1 id="9">9. -1 Shorthand -1 for -1 mocks -1 creation -1 - -1 &#064;Mock -1 annotation</h3> -1 * -1 * -1 <ul> -1 * -1 <li>Minimizes -1 repetitive -1 mock -1 creation -1 code.</li> -1 * -1 <li>Makes -1 the -1 test -1 class -1 more -1 readable.</li> -1 * -1 <li>Makes -1 the -1 verification -1 error -1 easier -1 to -1 read -1 because -1 the -1 <b>field -1 name</b> -1 * -1 is -1 used -1 to -1 identify -1 the -1 mock.</li> -1 * -1 </ul> -1 * -1 * -1 <pre> -1 * -1 public -1 class -1 ArticleManagerTest -1 { -1 * -1 * -1 &#064;Mock -1 private -1 ArticleCalculator -1 calculator; -1 * -1 &#064;Mock -1 private -1 ArticleDatabase -1 database; -1 * -1 &#064;Mock -1 private -1 UserProvider -1 userProvider; -1 * -1 * -1 private -1 ArticleManager -1 manager; -1 * -1 </pre> -1 * -1 * -1 <b>Important!</b> -1 This -1 needs -1 to -1 be -1 somewhere -1 in -1 the -1 base -1 class -1 or -1 a -1 test -1 * -1 runner: -1 * -1 * -1 <pre> -1 * -1 MockitoAnnotations.initMocks(testClass); -1 * -1 </pre> -1 * -1 * -1 You -1 can -1 use -1 built-in -1 runner: -1 {@link -1 MockitoJUnitRunner}. -1 * -1 <p> -1 * -1 Read -1 more -1 here: -1 {@link -1 MockitoAnnotations} -1 * -1 * -1 <h3 -1 id="10"> -1 10. -1 Stubbing -1 consecutive -1 calls -1 (iterator-style -1 stubbing)</h3> -1 * -1 * -1 Sometimes -1 we -1 need -1 to -1 stub -1 with -1 different -1 return -1 value/exception -1 for -1 the -1 same -1 * -1 method -1 call. -1 Typical -1 use -1 case -1 could -1 be -1 mocking -1 iterators. -1 * -1 Original -1 version -1 of -1 Mockito -1 did -1 not -1 have -1 this -1 feature -1 to -1 promote -1 simple -1 mocking. -1 * -1 For -1 example, -1 instead -1 of -1 iterators -1 one -1 could -1 use -1 {@link -1 Iterable} -1 or -1 simply -1 * -1 collections. -1 Those -1 offer -1 natural -1 ways -1 of -1 stubbing -1 (e.g. -1 using -1 real -1 * -1 collections). -1 In -1 rare -1 scenarios -1 stubbing -1 consecutive -1 calls -1 could -1 be -1 useful, -1 * -1 though: -1 * -1 <p> -1 * -1 * -1 <pre> -1 * -1 when(mock.someMethod("some -1 arg")) -1 * -1 .thenThrow(new -1 RuntimeException()) -1 * -1 .thenReturn("foo"); -1 * -1 * -1 //First -1 call: -1 throws -1 runtime -1 exception: -1 * -1 mock.someMethod("some -1 arg"); -1 * -1 * -1 //Second -1 call: -1 prints -1 "foo" -1 * -1 System.out.println(mock.someMethod("some -1 arg")); -1 * -1 * -1 //Any -1 consecutive -1 call: -1 prints -1 "foo" -1 as -1 well -1 (last -1 stubbing -1 wins). -1 * -1 System.out.println(mock.someMethod("some -1 arg")); -1 * -1 </pre> -1 * -1 * -1 Alternative, -1 shorter -1 version -1 of -1 consecutive -1 stubbing: -1 * -1 * -1 <pre> -1 * -1 when(mock.someMethod("some -1 arg")) -1 * -1 .thenReturn("one", -1 "two", -1 "three"); -1 * -1 </pre> -1 * -1 * -1 <h3 -1 id="11"> -1 11. -1 Stubbing -1 with -1 callbacks</h3> -1 * -1 * -1 Allows -1 stubbing -1 with -1 generic -1 {@link -1 Answer} -1 interface. -1 * -1 <p> -1 * -1 Yet -1 another -1 controversial -1 feature -1 which -1 was -1 not -1 included -1 in -1 Mockito -1 * -1 originally. -1 We -1 recommend -1 using -1 simple -1 stubbing -1 with -1 thenReturn() -1 or -1 * -1 thenThrow() -1 only. -1 Those -1 two -1 should -1 be -1 <b>just -1 enough</b> -1 to -1 test/test-drive -1 * -1 any -1 clean -1 & -1 simple -1 code. -1 * -1 * -1 <pre> -1 * -1 when(mock.someMethod(anyString())).thenAnswer(new -1 Answer() -1 { -1 * -1 Object -1 answer(InvocationOnMock -1 invocation) -1 { -1 * -1 Object[] -1 args -1 = -1 invocation.getArguments(); -1 * -1 Object -1 mock -1 = -1 invocation.getMock(); -1 * -1 return -1 "called -1 with -1 arguments: -1 " -1 + -1 args; -1 * -1 } -1 * -1 }); -1 * -1 * -1 //Following -1 prints -1 "called -1 with -1 arguments: -1 foo" -1 * -1 System.out.println(mock.someMethod("foo")); -1 * -1 </pre> -1 * -1 * -1 <h3 -1 id="12"> -1 12. -1 doThrow()|doAnswer()|doNothing()|doReturn() -1 family -1 of -1 methods -1 for -1 stubbing -1 voids -1 (mostly)</h3> -1 * -1 * -1 Stubbing -1 voids -1 requires -1 different -1 approach -1 from -1 {@link -1 Mockito#when(Object)} -1 because -1 the -1 compiler -1 does -1 not -1 like -1 void -1 methods -1 inside -1 brackets... -1 * -1 <p> -1 * -1 {@link -1 Mockito#doThrow(Throwable)} -1 replaces -1 the -1 {@link -1 Mockito#stubVoid(Object)} -1 method -1 for -1 stubbing -1 voids. -1 * -1 The -1 main -1 reason -1 is -1 improved -1 readability -1 and -1 consistency -1 with -1 the -1 family -1 of -1 doAnswer() -1 methods. -1 * -1 <p> -1 * -1 Use -1 doThrow() -1 when -1 you -1 want -1 to -1 stub -1 a -1 void -1 method -1 with -1 an -1 exception: -1 * -1 <pre> -1 * -1 doThrow(new -1 RuntimeException()).when(mockedList).clear(); -1 * -1 * -1 //following -1 throws -1 RuntimeException: -1 * -1 mockedList.clear(); -1 * -1 </pre> -1 * -1 * -1 Read -1 more -1 about -1 other -1 methods: -1 * -1 <p> -1 * -1 {@link -1 Mockito#doThrow(Throwable)} -1 * -1 <p> -1 * -1 {@link -1 Mockito#doAnswer(Answer)} -1 * -1 <p> -1 * -1 {@link -1 Mockito#doNothing()} -1 * -1 <p> -1 * -1 {@link -1 Mockito#doReturn(Object)} -1 * -1 * -1 <h3 -1 id="13"> -1 13. -1 Spying -1 on -1 real -1 objects</h3> -1 * -1 * -1 You -1 can -1 create -1 spies -1 of -1 real -1 objects. -1 When -1 you -1 use -1 the -1 spy -1 then -1 the -1 <b>real</b> -1 methods -1 are -1 called -1 (unless -1 a -1 method -1 was -1 stubbed). -1 * -1 <p> -1 * -1 Real -1 spies -1 should -1 be -1 used -1 <b>carefully -1 and -1 occasionally</b>, -1 for -1 example -1 when -1 dealing -1 with -1 legacy -1 code. -1 * -1 * -1 <p> -1 * -1 Spying -1 on -1 real -1 objects -1 can -1 be -1 associated -1 with -1 "partial -1 mocking" -1 concept. -1 * -1 <b>Before -1 the -1 release -1 1.8</b>, -1 Mockito -1 spies -1 were -1 not -1 real -1 partial -1 mocks. -1 * -1 The -1 reason -1 was -1 we -1 thought -1 partial -1 mock -1 is -1 a -1 code -1 smell. -1 * -1 At -1 some -1 point -1 we -1 found -1 legitimate -1 use -1 cases -1 for -1 partial -1 mocks -1 * -1 (3rd -1 party -1 interfaces, -1 interim -1 refactoring -1 of -1 legacy -1 code, -1 the -1 full -1 article -1 is -1 <a -1 href= -1 * -1 "http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring" -1 * -1 >here</a>) -1 * -1 <p> -1 * -1 * -1 <pre> -1 * -1 List -1 list -1 = -1 new -1 LinkedList(); -1 * -1 List -1 spy -1 = -1 spy(list); -1 * -1 * -1 //optionally, -1 you -1 can -1 stub -1 out -1 some -1 methods: -1 * -1 when(spy.size()).thenReturn(100); -1 * -1 * -1 //using -1 the -1 spy -1 calls -1 <b>real</b> -1 methods -1 * -1 spy.add("one"); -1 * -1 spy.add("two"); -1 * -1 * -1 //prints -1 "one" -1 - -1 the -1 first -1 element -1 of -1 a -1 list -1 * -1 System.out.println(spy.get(0)); -1 * -1 * -1 //size() -1 method -1 was -1 stubbed -1 - -1 100 -1 is -1 printed -1 * -1 System.out.println(spy.size()); -1 * -1 * -1 //optionally, -1 you -1 can -1 verify -1 * -1 verify(spy).add("one"); -1 * -1 verify(spy).add("two"); -1 * -1 </pre> -1 * -1 * -1 <h4>Important -1 gotcha -1 on -1 spying -1 real -1 objects!</h4> -1 * -1 * -1 1. -1 Sometimes -1 it's -1 impossible -1 to -1 use -1 {@link -1 Mockito#when(Object)} -1 for -1 stubbing -1 spies. -1 Example: -1 * -1 * -1 <pre> -1 * -1 List -1 list -1 = -1 new -1 LinkedList(); -1 * -1 List -1 spy -1 = -1 spy(list); -1 * -1 * -1 //Impossible: -1 real -1 method -1 is -1 called -1 so -1 spy.get(0) -1 throws -1 IndexOutOfBoundsException -1 (the -1 list -1 is -1 yet -1 empty) -1 * -1 when(spy.get(0)).thenReturn("foo"); -1 * -1 * -1 //You -1 have -1 to -1 use -1 doReturn() -1 for -1 stubbing -1 * -1 doReturn("foo").when(spy).get(0); -1 * -1 </pre> -1 * -1 * -1 2. -1 Watch -1 out -1 for -1 final -1 methods. -1 * -1 Mockito -1 doesn't -1 mock -1 final -1 methods -1 so -1 the -1 bottom -1 line -1 is: -1 when -1 you -1 spy -1 on -1 real -1 objects -1 + -1 you -1 try -1 to -1 stub -1 a -1 final -1 method -1 = -1 trouble. -1 * -1 What -1 will -1 happen -1 is -1 the -1 real -1 method -1 will -1 be -1 called -1 *on -1 mock* -1 but -1 *not -1 on -1 the -1 real -1 instance* -1 you -1 passed -1 to -1 the -1 spy() -1 method. -1 * -1 Typically -1 you -1 may -1 get -1 a -1 NullPointerException -1 because -1 mock -1 instances -1 don't -1 have -1 fields -1 initiated. -1 * -1 * -1 <h3 -1 id="14">14. -1 Changing -1 default -1 return -1 values -1 of -1 unstubbed -1 invocations -1 (Since -1 1.7) -1 </h3> -1 * -1 * -1 You -1 can -1 create -1 a -1 mock -1 with -1 specified -1 strategy -1 for -1 its -1 return -1 values. -1 * -1 It's -1 quite -1 advanced -1 feature -1 and -1 typically -1 you -1 don't -1 need -1 it -1 to -1 write -1 decent -1 tests. -1 * -1 However, -1 it -1 can -1 be -1 helpful -1 for -1 working -1 with -1 <b>legacy -1 systems</b>. -1 * -1 <p> -1 * -1 It -1 is -1 the -1 default -1 answer -1 so -1 it -1 will -1 be -1 used -1 <b>only -1 when -1 you -1 don't</b> -1 stub -1 the -1 method -1 call. -1 * -1 * -1 <pre> -1 * -1 Foo -1 mock -1 = -1 mock(Foo.class, -1 Mockito.RETURNS_SMART_NULLS); -1 * -1 Foo -1 mockTwo -1 = -1 mock(Foo.class, -1 new -1 YourOwnAnswer()); -1 * -1 </pre> -1 * -1 * -1 <p> -1 * -1 Read -1 more -1 about -1 this -1 interesting -1 implementation -1 of -1 <i>Answer</i>: -1 {@link -1 Mockito#RETURNS_SMART_NULLS} -1 * -1 * -1 <h3 -1 id="15">15. -1 Capturing -1 arguments -1 for -1 further -1 assertions -1 (Since -1 1.8.0) -1 </h3> -1 * -1 * -1 Mockito -1 verifies -1 argument -1 values -1 in -1 natural -1 java -1 style: -1 by -1 using -1 an -1 equals() -1 method. -1 * -1 This -1 is -1 also -1 the -1 recommended -1 way -1 of -1 matching -1 arguments -1 because -1 it -1 makes -1 tests -1 clean -1 & -1 simple. -1 * -1 In -1 some -1 situations -1 though, -1 it -1 is -1 helpful -1 to -1 assert -1 on -1 certain -1 arguments -1 after -1 the -1 actual -1 verification. -1 * -1 For -1 example: -1 * -1 <pre> -1 * -1 ArgumentCaptor&lt;Person&gt; -1 argument -1 = -1 ArgumentCaptor.forClass(Person.class); -1 * -1 verify(mock).doSomething(argument.capture()); -1 * -1 assertEquals("John", -1 argument.getValue().getName()); -1 * -1 </pre> -1 * -1 * -1 <b>Warning:</b> -1 it -1 is -1 recommended -1 to -1 use -1 ArgumentCaptor -1 with -1 verification -1 <b>but -1 not</b> -1 with -1 stubbing. -1 * -1 Using -1 ArgumentCaptor -1 with -1 stubbing -1 may -1 decrease -1 test -1 readability -1 because -1 captor -1 is -1 created -1 outside -1 of -1 assert -1 (aka -1 verify -1 or -1 'then') -1 block. -1 * -1 Also -1 it -1 may -1 reduce -1 defect -1 localization -1 because -1 if -1 stubbed -1 method -1 was -1 not -1 called -1 then -1 no -1 argument -1 is -1 captured. -1 * -1 <p> -1 * -1 In -1 a -1 way -1 ArgumentCaptor -1 is -1 related -1 to -1 custom -1 argument -1 matchers -1 (see -1 javadoc -1 for -1 {@link -1 ArgumentMatcher} -1 class). -1 * -1 Both -1 techniques -1 can -1 be -1 used -1 for -1 making -1 sure -1 certain -1 arguments -1 where -1 passed -1 to -1 mocks. -1 * -1 However, -1 ArgumentCaptor -1 may -1 be -1 a -1 better -1 fit -1 if: -1 * -1 <ul> -1 * -1 <li>custom -1 argument -1 matcher -1 is -1 not -1 likely -1 to -1 be -1 reused</li> -1 * -1 <li>you -1 just -1 need -1 it -1 to -1 assert -1 on -1 argument -1 values -1 to -1 complete -1 verification</li> -1 * -1 </ul> -1 * -1 Custom -1 argument -1 matchers -1 via -1 {@link -1 ArgumentMatcher} -1 are -1 usually -1 better -1 for -1 stubbing. -1 * -1 * -1 <h3 -1 id="16">16. -1 Real -1 partial -1 mocks -1 (Since -1 1.8.0) -1 </h3> -1 * -1 * -1 Finally, -1 after -1 many -1 internal -1 debates -1 & -1 discussions -1 on -1 the -1 mailing -1 list, -1 partial -1 mock -1 support -1 was -1 added -1 to -1 Mockito. -1 * -1 Previously -1 we -1 considered -1 partial -1 mocks -1 as -1 code -1 smells. -1 However, -1 we -1 found -1 a -1 legitimate -1 use -1 case -1 for -1 partial -1 mocks -1 - -1 more -1 reading: -1 * -1 <a -1 href="http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring">here</a> -1 * -1 <p> -1 * -1 <b>Before -1 release -1 1.8</b> -1 spy() -1 was -1 not -1 producing -1 real -1 partial -1 mocks -1 and -1 it -1 was -1 confusing -1 for -1 some -1 users. -1 * -1 Read -1 more -1 about -1 spying: -1 <a -1 href="#13">here</a> -1 or -1 in -1 javadoc -1 for -1 {@link -1 Mockito#spy(Object)} -1 method. -1 * -1 <p> -1 * -1 <pre> -1 * -1 //you -1 can -1 create -1 partial -1 mock -1 with -1 spy() -1 method: -1 * -1 List -1 list -1 = -1 spy(new -1 LinkedList()); -1 * -1 * -1 //you -1 can -1 enable -1 partial -1 mock -1 capabilities -1 selectively -1 on -1 mocks: -1 * -1 Foo -1 mock -1 = -1 mock(Foo.class); -1 * -1 //Be -1 sure -1 the -1 real -1 implementation -1 is -1 'safe'. -1 * -1 //If -1 real -1 implementation -1 throws -1 exceptions -1 or -1 depends -1 on -1 specific -1 state -1 of -1 the -1 object -1 then -1 you're -1 in -1 trouble. -1 * -1 when(mock.someMethod()).thenCallRealMethod(); -1 * -1 </pre> -1 * -1 * -1 As -1 usual -1 you -1 are -1 going -1 to -1 read -1 <b>the -1 partial -1 mock -1 warning</b>: -1 * -1 Object -1 oriented -1 programming -1 is -1 more -1 less -1 tackling -1 complexity -1 by -1 dividing -1 the -1 complexity -1 into -1 separate, -1 specific, -1 SRPy -1 objects. -1 * -1 How -1 does -1 partial -1 mock -1 fit -1 into -1 this -1 paradigm? -1 Well, -1 it -1 just -1 doesn't... -1 * -1 Partial -1 mock -1 usually -1 means -1 that -1 the -1 complexity -1 has -1 been -1 moved -1 to -1 a -1 different -1 method -1 on -1 the -1 same -1 object. -1 * -1 In -1 most -1 cases, -1 this -1 is -1 not -1 the -1 way -1 you -1 want -1 to -1 design -1 your -1 application. -1 * -1 <p> -1 * -1 However, -1 there -1 are -1 rare -1 cases -1 when -1 partial -1 mocks -1 come -1 handy: -1 * -1 dealing -1 with -1 code -1 you -1 cannot -1 change -1 easily -1 (3rd -1 party -1 interfaces, -1 interim -1 refactoring -1 of -1 legacy -1 code -1 etc.) -1 * -1 However, -1 I -1 wouldn't -1 use -1 partial -1 mocks -1 for -1 new, -1 test-driven -1 & -1 well-designed -1 code. -1 * -1 * -1 <h3 -1 id="17">17. -1 Resetting -1 mocks -1 (Since -1 1.8.0) -1 </h3> -1 * -1 * -1 Smart -1 Mockito -1 users -1 hardly -1 use -1 this -1 feature -1 because -1 they -1 know -1 it -1 could -1 be -1 a -1 sign -1 of -1 poor -1 tests. -1 * -1 Normally, -1 you -1 don't -1 need -1 to -1 reset -1 your -1 mocks, -1 just -1 create -1 new -1 mocks -1 for -1 each -1 test -1 method. -1 * -1 <p> -1 * -1 Instead -1 of -1 reset() -1 please -1 consider -1 writing -1 simple, -1 small -1 and -1 focused -1 test -1 methods -1 over -1 lengthy, -1 over-specified -1 tests. -1 * -1 <b>First -1 potential -1 code -1 smell -1 is -1 reset() -1 in -1 the -1 middle -1 of -1 the -1 test -1 method.</b> -1 This -1 probably -1 means -1 you're -1 testing -1 too -1 much. -1 * -1 Follow -1 the -1 whisper -1 of -1 your -1 test -1 methods: -1 "Please -1 keep -1 us -1 small -1 & -1 focused -1 on -1 single -1 behavior". -1 * -1 There -1 are -1 several -1 threads -1 about -1 it -1 on -1 mockito -1 mailing -1 list. -1 * -1 <p> -1 * -1 The -1 only -1 reason -1 we -1 added -1 reset() -1 method -1 is -1 to -1 * -1 make -1 it -1 possible -1 to -1 work -1 with -1 container-injected -1 mocks. -1 * -1 See -1 issue -1 55 -1 (<a -1 href="http://code.google.com/p/mockito/issues/detail?id=55">here</a>) -1 * -1 or -1 FAQ -1 (<a -1 href="http://code.google.com/p/mockito/wiki/FAQ">here</a>). -1 * -1 <p> -1 * -1 <b>Don't -1 harm -1 yourself.</b> -1 reset() -1 in -1 the -1 middle -1 of -1 the -1 test -1 method -1 is -1 a -1 code -1 smell -1 (you're -1 probably -1 testing -1 too -1 much). -1 * -1 <pre> -1 * -1 List -1 mock -1 = -1 mock(List.class); -1 * -1 when(mock.size()).thenReturn(10); -1 * -1 mock.add(1); -1 * -1 * -1 reset(mock); -1 * -1 //at -1 this -1 point -1 the -1 mock -1 forgot -1 any -1 interactions -1 & -1 stubbing -1 * -1 </pre> -1 * -1 * -1 <h3 -1 id="18">18. -1 Troubleshooting -1 & -1 validating -1 framework -1 usage -1 (Since -1 1.8.0) -1 </h3> -1 * -1 * -1 First -1 of -1 all, -1 in -1 case -1 of -1 any -1 trouble, -1 I -1 encourage -1 you -1 to -1 read -1 the -1 Mockito -1 FAQ: -1 * -1 <a -1 href="http://code.google.com/p/mockito/wiki/FAQ">http://code.google.com/p/mockito/wiki/FAQ</a> -1 * -1 <p> -1 * -1 In -1 case -1 of -1 questions -1 you -1 may -1 also -1 post -1 to -1 mockito -1 mailing -1 list: -1 * -1 <a -1 href="http://groups.google.com/group/mockito">http://groups.google.com/group/mockito</a> -1 * -1 <p> -1 * -1 Next, -1 you -1 should -1 know -1 that -1 Mockito -1 validates -1 if -1 you -1 use -1 it -1 correctly -1 <b>all -1 the -1 time</b>. -1 * -1 However, -1 there's -1 a -1 gotcha -1 so -1 please -1 read -1 the -1 javadoc -1 for -1 {@link -1 Mockito#validateMockitoUsage()} -1 * -1 * -1 <h3 -1 id="19">19. -1 Aliases -1 for -1 behavior -1 driven -1 development -1 (Since -1 1.8.0) -1 </h3> -1 * -1 * -1 Behavior -1 Driven -1 Development -1 style -1 of -1 writing -1 tests -1 uses -1 <b>//given -1 //when -1 //then</b> -1 comments -1 as -1 fundamental -1 parts -1 of -1 your -1 test -1 methods. -1 * -1 This -1 is -1 exactly -1 how -1 we -1 write -1 our -1 tests -1 and -1 we -1 warmly -1 encourage -1 you -1 to -1 do -1 so! -1 * -1 <p> -1 * -1 Start -1 learning -1 about -1 BDD -1 here: -1 <a -1 href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">http://en.wikipedia.org/wiki/Behavior_Driven_Development</a> -1 * -1 <p> -1 * -1 The -1 problem -1 is -1 that -1 current -1 stubbing -1 api -1 with -1 canonical -1 role -1 of -1 <b>when</b> -1 word -1 does -1 not -1 integrate -1 nicely -1 with -1 <b>//given -1 //when -1 //then</b> -1 comments. -1 * -1 It's -1 because -1 stubbing -1 belongs -1 to -1 <b>given</b> -1 component -1 of -1 the -1 test -1 and -1 not -1 to -1 the -1 <b>when</b> -1 component -1 of -1 the -1 test. -1 * -1 Hence -1 {@link -1 BDDMockito} -1 class -1 introduces -1 an -1 alias -1 so -1 that -1 you -1 stub -1 method -1 calls -1 with -1 {@link -1 BDDMockito#given(Object)} -1 method. -1 * -1 Now -1 it -1 really -1 nicely -1 integrates -1 with -1 the -1 <b>given</b> -1 component -1 of -1 a -1 BDD -1 style -1 test! -1 * -1 <p> -1 * -1 Here -1 is -1 how -1 the -1 test -1 might -1 look -1 like: -1 * -1 <pre> -1 * -1 import -1 static -1 org.mockito.BDDMockito.*; -1 * -1 * -1 Seller -1 seller -1 = -1 mock(Seller.class); -1 * -1 Shop -1 shop -1 = -1 new -1 Shop(seller); -1 * -1 * -1 public -1 void -1 shouldBuyBread() -1 throws -1 Exception -1 { -1 * -1 //given -1 * -1 given(seller.askForBread()).willReturn(new -1 Bread()); -1 * -1 * -1 //when -1 * -1 Goods -1 goods -1 = -1 shop.buyBread(); -1 * -1 * -1 //then -1 * -1 assertThat(goods, -1 containBread()); -1 * -1 } -1 * -1 </pre> -1 * -1 * -1 <h3 -1 id="20">20. -1 (**New**) -1 Serializable -1 mocks -1 (Since -1 1.8.1) -1 </h3> -1 * -1 * -1 Mocks -1 can -1 be -1 made -1 serializable. -1 With -1 this -1 feature -1 you -1 can -1 use -1 a -1 mock -1 in -1 a -1 place -1 that -1 requires -1 dependencies -1 to -1 be -1 serializable. -1 * -1 <p> -1 * -1 WARNING: -1 This -1 should -1 be -1 rarely -1 used -1 in -1 unit -1 testing. -1 * -1 <p> -1 * -1 The -1 behaviour -1 was -1 implemented -1 for -1 a -1 specific -1 use -1 case -1 of -1 a -1 BDD -1 spec -1 that -1 had -1 an -1 unreliable -1 external -1 dependency. -1 This -1 * -1 was -1 in -1 a -1 web -1 environment -1 and -1 the -1 objects -1 from -1 the -1 external -1 dependency -1 were -1 being -1 serialized -1 to -1 pass -1 between -1 layers. -1 * -1 <p> -1 * -1 To -1 create -1 serializable -1 mock -1 use -1 {@link -1 MockSettings#serializable()}: -1 * -1 <pre> -1 * -1 List -1 serializableMock -1 = -1 mock(List.class, -1 withSettings().serializable()); -1 * -1 </pre> -1 * -1 <p> -1 * -1 The -1 mock -1 can -1 be -1 serialized -1 assuming -1 all -1 the -1 normal -1 <a -1 href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'> -1 * -1 serialization -1 requirements</a> -1 are -1 met -1 by -1 the -1 class. -1 * -1 <p> -1 * -1 Making -1 a -1 real -1 object -1 spy -1 serializable -1 is -1 a -1 bit -1 more -1 effort -1 as -1 the -1 spy(...) -1 method -1 does -1 not -1 have -1 an -1 overloaded -1 version -1 * -1 which -1 accepts -1 MockSettings. -1 No -1 worries, -1 you -1 will -1 hardly -1 ever -1 use -1 it. -1 * -1 * -1 <pre> -1 * -1 List<Object> -1 list -1 = -1 new -1 ArrayList<Object>(); -1 * -1 List<Object> -1 spy -1 = -1 mock(ArrayList.class, -1 withSettings() -1 * -1 .spiedInstance(list) -1 * -1 .defaultAnswer(CALLS_REAL_METHODS) -1 * -1 .serializable()); -1 * -1 </pre> -1 */ -1 @SuppressWarnings("unchecked") -1 public -1 class -1 Mockito -1 extends -1 Matchers -1 { -1 private -1 static -1 final -1 MockitoCore -1 MOCKITO_CORE -1 = -1 new -1 MockitoCore(); -1 /** -1 * -1 The -1 default -1 Answer -1 of -1 every -1 mock -1 <b>if</b> -1 the -1 mock -1 was -1 not -1 stubbed. -1 * -1 Typically -1 it -1 just -1 returns -1 some -1 empty -1 value. -1 * -1 <p> -1 * -1 {@link -1 Answer} -1 can -1 be -1 used -1 to -1 define -1 the -1 return -1 values -1 of -1 unstubbed -1 invocations. -1 * -1 <p> -1 * -1 This -1 implementation -1 first -1 tries -1 the -1 global -1 configuration. -1 * -1 If -1 there -1 is -1 no -1 global -1 configuration -1 then -1 it -1 uses -1 {@link -1 ReturnsEmptyValues} -1 (returns -1 zeros, -1 empty -1 collections, -1 nulls, -1 etc.) -1 */ -1 public -1 static -1 final -1 Answer<Object> -1 RETURNS_DEFAULTS -1 = -1 new -1 GloballyConfiguredAnswer(); -1 /** -1 * -1 Optional -1 Answer -1 to -1 be -1 used -1 with -1 {@link -1 Mockito#mock(Class, -1 Answer)} -1 * -1 <p> -1 * -1 {@link -1 Answer} -1 can -1 be -1 used -1 to -1 define -1 the -1 return -1 values -1 of -1 unstubbed -1 invocations. -1 * -1 <p> -1 * -1 This -1 implementation -1 can -1 be -1 helpful -1 when -1 working -1 with -1 legacy -1 code. -1 * -1 Unstubbed -1 methods -1 often -1 return -1 null. -1 If -1 your -1 code -1 uses -1 the -1 object -1 returned -1 by -1 an -1 unstubbed -1 call -1 you -1 get -1 a -1 NullPointerException. -1 * -1 This -1 implementation -1 of -1 Answer -1 <b>returns -1 SmartNull -1 instead -1 of -1 null</b>. -1 * -1 SmartNull -1 gives -1 nicer -1 exception -1 message -1 than -1 NPE -1 because -1 it -1 points -1 out -1 the -1 line -1 where -1 unstubbed -1 method -1 was -1 called. -1 You -1 just -1 click -1 on -1 the -1 stack -1 trace. -1 * -1 <p> -1 * -1 ReturnsSmartNulls -1 first -1 tries -1 to -1 return -1 ordinary -1 return -1 values -1 (see -1 {@link -1 ReturnsMoreEmptyValues}) -1 * -1 then -1 it -1 tries -1 to -1 return -1 SmartNull. -1 If -1 the -1 return -1 type -1 is -1 final -1 then -1 plain -1 null -1 is -1 returned. -1 * -1 <p> -1 * -1 ReturnsSmartNulls -1 will -1 be -1 probably -1 the -1 default -1 return -1 values -1 strategy -1 in -1 Mockito -1 2.0 -1 * -1 <p> -1 * -1 Example: -1 * -1 <pre> -1 * -1 Foo -1 mock -1 = -1 (Foo.class, -1 RETURNS_SMART_NULLS); -1 * -1 * -1 //calling -1 unstubbed -1 method -1 here: -1 * -1 Stuff -1 stuff -1 = -1 mock.getStuff(); -1 * -1 * -1 //using -1 object -1 returned -1 by -1 unstubbed -1 call: -1 * -1 stuff.doSomething(); -1 * -1 * -1 //Above -1 doesn't -1 yield -1 NullPointerException -1 this -1 time! -1 * -1 //Instead, -1 SmartNullPointerException -1 is -1 thrown. -1 * -1 //Exception's -1 cause -1 links -1 to -1 unstubbed -1 <i>mock.getStuff()</i> -1 - -1 just -1 click -1 on -1 the -1 stack -1 trace. -1 * -1 </pre> -1 */ -1 public -1 static -1 final -1 Answer<Object> -1 RETURNS_SMART_NULLS -1 = -1 new -1 ReturnsSmartNulls(); -1 /** -1 * -1 Optional -1 Answer -1 to -1 be -1 used -1 with -1 {@link -1 Mockito#mock(Class, -1 Answer)} -1 * -1 <p> -1 * -1 {@link -1 Answer} -1 can -1 be -1 used -1 to -1 define -1 the -1 return -1 values -1 of -1 unstubbed -1 invocations. -1 * -1 <p> -1 * -1 This -1 implementation -1 can -1 be -1 helpful -1 when -1 working -1 with -1 legacy -1 code. -1 * -1 <p> -1 * -1 ReturnsMocks -1 first -1 tries -1 to -1 return -1 ordinary -1 return -1 values -1 (see -1 {@link -1 ReturnsMoreEmptyValues}) -1 * -1 then -1 it -1 tries -1 to -1 return -1 mocks. -1 If -1 the -1 return -1 type -1 cannot -1 be -1 mocked -1 (e.g. -1 is -1 final) -1 then -1 plain -1 null -1 is -1 returned. -1 * -1 <p> -1 */ -1 public -1 static -1 final -1 Answer<Object> -1 RETURNS_MOCKS -1 = -1 new -1 ReturnsMocks(); -1 /** -1 * -1 Optional -1 Answer -1 to -1 be -1 used -1 with -1 {@link -1 Mockito#mock(Class, -1 Answer)} -1 * -1 <p> -1 * -1 {@link -1 Answer} -1 can -1 be -1 used -1 to -1 define -1 the -1 return -1 values -1 of -1 unstubbed -1 invocations. -1 * -1 <p> -1 * -1 This -1 implementation -1 can -1 be -1 helpful -1 when -1 working -1 with -1 legacy -1 code. -1 * -1 When -1 this -1 implementation -1 is -1 used, -1 unstubbed -1 methods -1 will -1 delegate -1 to -1 the -1 real -1 implementation. -1 * -1 This -1 is -1 a -1 way -1 to -1 create -1 a -1 partial -1 mock -1 object -1 that -1 calls -1 real -1 methods -1 by -1 default. -1 * -1 <p> -1 * -1 As -1 usual -1 you -1 are -1 going -1 to -1 read -1 <b>the -1 partial -1 mock -1 warning</b>: -1 * -1 Object -1 oriented -1 programming -1 is -1 more -1 less -1 tackling -1 complexity -1 by -1 dividing -1 the -1 complexity -1 into -1 separate, -1 specific, -1 SRPy -1 objects. -1 * -1 How -1 does -1 partial -1 mock -1 fit -1 into -1 this -1 paradigm? -1 Well, -1 it -1 just -1 doesn't... -1 * -1 Partial -1 mock -1 usually -1 means -1 that -1 the -1 complexity -1 has -1 been -1 moved -1 to -1 a -1 different -1 method -1 on -1 the -1 same -1 object. -1 * -1 In -1 most -1 cases, -1 this -1 is -1 not -1 the -1 way -1 you -1 want -1 to -1 design -1 your -1 application. -1 * -1 <p> -1 * -1 However, -1 there -1 are -1 rare -1 cases -1 when -1 partial -1 mocks -1 come -1 handy: -1 * -1 dealing -1 with -1 code -1 you -1 cannot -1 change -1 easily -1 (3rd -1 party -1 interfaces, -1 interim -1 refactoring -1 of -1 legacy -1 code -1 etc.) -1 * -1 However, -1 I -1 wouldn't -1 use -1 partial -1 mocks -1 for -1 new, -1 test-driven -1 & -1 well-designed -1 code. -1 * -1 <p> -1 * -1 Example: -1 * -1 <pre> -1 * -1 Foo -1 mock -1 = -1 mock(Foo.class, -1 CALLS_REAL_METHODS); -1 * -1 * -1 // -1 this -1 calls -1 the -1 real -1 implementation -1 of -1 Foo.getSomething() -1 * -1 value -1 = -1 mock.getSomething(); -1 * -1 * -1 when(mock.getSomething()).thenReturn(fakeValue); -1 * -1 * -1 // -1 now -1 fakeValue -1 is -1 returned -1 * -1 value -1 = -1 mock.getSomething(); -1 * -1 </pre> -1 */ -1 public -1 static -1 final -1 Answer<Object> -1 CALLS_REAL_METHODS -1 = -1 new -1 CallsRealMethods(); -1 /** -1 * -1 Creates -1 mock -1 object -1 of -1 given -1 class -1 or -1 interface. -1 * -1 <p> -1 * -1 See -1 examples -1 in -1 javadoc -1 for -1 {@link -1 Mockito} -1 class -1 * -1 * -1 @param -1 classToMock -1 class -1 or -1 interface -1 to -1 mock -1 * -1 @return -1 mock -1 object -1 */ -1 public -1 static -1 <T> -1 T -1 mock(Class<T> -1 classToMock) -1 { -1 return -1 mock(classToMock, -1 withSettings().defaultAnswer(RETURNS_DEFAULTS)); -1 } -1 /** -1 * -1 Specifies -1 mock -1 name. -1 Naming -1 mocks -1 can -1 be -1 helpful -1 for -1 debugging -1 - -1 the -1 name -1 is -1 used -1 in -1 all -1 verification -1 errors. -1 * -1 <p> -1 * -1 Beware -1 that -1 naming -1 mocks -1 is -1 not -1 a -1 solution -1 for -1 complex -1 code -1 which -1 uses -1 too -1 many -1 mocks -1 or -1 collaborators. -1 * -1 <b>If -1 you -1 have -1 too -1 many -1 mocks -1 then -1 refactor -1 the -1 code</b> -1 so -1 that -1 it's -1 easy -1 to -1 test/debug -1 without -1 necessity -1 of -1 naming -1 mocks. -1 * -1 <p> -1 * -1 <b>If -1 you -1 use -1 &#064;Mock -1 annotation -1 then -1 you've -1 got -1 naming -1 mocks -1 for -1 free!</b> -1 &#064;Mock -1 uses -1 field -1 name -1 as -1 mock -1 name. -1 {@link -1 Mock -1 Read -1 more.} -1 * -1 <p> -1 * -1 * -1 See -1 examples -1 in -1 javadoc -1 for -1 {@link -1 Mockito} -1 class -1 * -1 * -1 @param -1 classToMock -1 class -1 or -1 interface -1 to -1 mock -1 * -1 @param -1 name -1 of -1 the -1 mock -1 * -1 @return -1 mock -1 object -1 */ -1 public -1 static -1 <T> -1 T -1 mock(Class<T> -1 classToMock, -1 String -1 name) -1 { -1 return -1 mock(classToMock, -1 withSettings() -1 .name(name) -1 .defaultAnswer(RETURNS_DEFAULTS)); -1 } -1 /** -1 * -1 @deprecated -1 * -1 <b>Please -1 use -1 mock(Foo.class, -1 defaultAnswer);</b> -1 * -1 <p> -1 * -1 See -1 {@link -1 Mockito#mock(Class, -1 Answer)} -1 * -1 <p> -1 * -1 Why -1 it -1 is -1 deprecated? -1 ReturnValues -1 is -1 being -1 replaced -1 by -1 Answer -1 * -1 for -1 better -1 consistency -1 & -1 interoperability -1 of -1 the -1 framework. -1 * -1 Answer -1 interface -1 has -1 been -1 in -1 Mockito -1 for -1 a -1 while -1 and -1 it -1 has -1 the -1 same -1 responsibility -1 as -1 ReturnValues. -1 * -1 There's -1 no -1 point -1 in -1 mainting -1 exactly -1 the -1 same -1 interfaces. -1 * -1 <p> -1 * -1 Creates -1 mock -1 with -1 a -1 specified -1 strategy -1 for -1 its -1 return -1 values. -1 * -1 It's -1 quite -1 advanced -1 feature -1 and -1 typically -1 you -1 don't -1 need -1 it -1 to -1 write -1 decent -1 tests. -1 * -1 However -1 it -1 can -1 be -1 helpful -1 when -1 working -1 with -1 legacy -1 systems. -1 * -1 <p> -1 * -1 Obviously -1 return -1 values -1 are -1 used -1 only -1 when -1 you -1 don't -1 stub -1 the -1 method -1 call. -1 * -1 * -1 <pre> -1 * -1 Foo -1 mock -1 = -1 mock(Foo.class, -1 Mockito.RETURNS_SMART_NULLS); -1 * -1 Foo -1 mockTwo -1 = -1 mock(Foo.class, -1 new -1 YourOwnReturnValues()); -1 * -1 </pre> -1 * -1 * -1 <p>See -1 examples -1 in -1 javadoc -1 for -1 {@link -1 Mockito} -1 class</p> -1 * -1 * -1 @param -1 classToMock -1 class -1 or -1 interface -1 to -1 mock -1 * -1 @param -1 returnValues -1 default -1 return -1 values -1 for -1 unstubbed -1 methods -1 * -1 * -1 @return -1 mock -1 object -1 */ -1 @Deprecated -1 public -1 static -1 <T> -1 T -1 mock(Class<T> -1 classToMock, -1 ReturnValues -1 returnValues) -1 { -1 return -1 mock(classToMock, -1 withSettings().defaultAnswer(new -1 AnswerReturnValuesAdapter(returnValues))); -1 } -1 /** -1 * -1 Creates -1 mock -1 with -1 a -1 specified -1 strategy -1 for -1 its -1 answers -1 to -1 interactions. -1 * -1 It's -1 quite -1 advanced -1 feature -1 and -1 typically -1 you -1 don't -1 need -1 it -1 to -1 write -1 decent -1 tests. -1 * -1 However -1 it -1 can -1 be -1 helpful -1 when -1 working -1 with -1 legacy -1 systems. -1 * -1 <p> -1 * -1 It -1 is -1 the -1 default -1 answer -1 so -1 it -1 will -1 be -1 used -1 <b>only -1 when -1 you -1 don't</b> -1 stub -1 the -1 method -1 call. -1 * -1 * -1 <pre> -1 * -1 Foo -1 mock -1 = -1 mock(Foo.class, -1 RETURNS_SMART_NULLS); -1 * -1 Foo -1 mockTwo -1 = -1 mock(Foo.class, -1 new -1 YourOwnAnswer()); -1 * -1 </pre> -1 * -1 * -1 <p>See -1 examples -1 in -1 javadoc -1 for -1 {@link -1 Mockito} -1 class</p> -1 * -1 * -1 @param -1 classToMock -1 class -1 or -1 interface -1 to -1 mock -1 * -1 @param -1 defaultAnswer -1 default -1 answer -1 for -1 unstubbed -1 methods -1 * -1 * -1 @return -1 mock -1 object -1 */ -1 public -1 static -1 <T> -1 T -1 mock(Class<T> -1 classToMock, -1 Answer -1 defaultAnswer) -1 { -1 return -1 mock(classToMock, -1 withSettings().defaultAnswer(defaultAnswer)); -1 } -1 /** -1 * -1 Creates -1 a -1 mock -1 with -1 some -1 non-standard -1 settings. -1 * -1 <p> -1 * -1 The -1 number -1 of -1 configuration -1 points -1 for -1 a -1 mock -1 grows -1 * -1 so -1 we -1 need -1 a -1 fluent -1 way -1 to -1 introduce -1 new -1 configuration -1 without -1 adding -1 more -1 and -1 more -1 overloaded -1 Mockito.mock() -1 methods. -1 * -1 Hence -1 {@link -1 MockSettings}. -1 * -1 <pre> -1 * -1 Listener -1 mock -1 = -1 mock(Listener.class, -1 withSettings() -1 * -1 .name("firstListner").defaultBehavior(RETURNS_SMART_NULLS)); -1 * -1 ); -1 * -1 </pre> -1 * -1 <b>Use -1 it -1 carefully -1 and -1 occasionally</b>. -1 What -1 might -1 be -1 reason -1 your -1 test -1 needs -1 non-standard -1 mocks? -1 * -1 Is -1 the -1 code -1 under -1 test -1 so -1 complicated -1 that -1 it -1 requires -1 non-standard -1 mocks? -1 * -1 Wouldn't -1 you -1 prefer -1 to -1 refactor -1 the -1 code -1 under -1 test -1 so -1 it -1 is -1 testable -1 in -1 a -1 simple -1 way? -1 * -1 <p> -1 * -1 See -1 also -1 {@link -1 Mockito#withSettings()} -1 * -1 <p> -1 * -1 See -1 examples -1 in -1 javadoc -1 for -1 {@link -1 Mockito} -1 class -1 * -1 * -1 @param -1 classToMock -1 class -1 or -1 interface -1 to -1 mock -1 * -1 @param -1 mockSettings -1 additional -1 mock -1 settings -1 * -1 @return -1 mock -1 object -1 */ -1 public -1 static -1 <T> -1 T -1 mock(Class<T> -1 classToMock, -1 MockSettings -1 mockSettings) -1 { -1 ---- -1 ---return -1 ---MOCKITO_CORE.mock(classToMock, -1 ---mockSettings); -1 ++++ -1 +++return -1 +++MOCKITO_CORE.mock(classToMock, -1 +++mockSettings, -1 +++true); -1 } -1 /** -1 * -1 Creates -1 a -1 spy -1 of -1 the -1 real -1 object. -1 The -1 spy -1 calls -1 <b>real</b> -1 methods -1 unless -1 they -1 are -1 stubbed. -1 * -1 <p> -1 * -1 Real -1 spies -1 should -1 be -1 used -1 <b>carefully -1 and -1 occasionally</b>, -1 for -1 example -1 when -1 dealing -1 with -1 legacy -1 code. -1 * -1 <p> -1 * -1 As -1 usual -1 you -1 are -1 going -1 to -1 read -1 <b>the -1 partial -1 mock -1 warning</b>: -1 * -1 Object -1 oriented -1 programming -1 is -1 more -1 less -1 tackling -1 complexity -1 by -1 dividing -1 the -1 complexity -1 into -1 separate, -1 specific, -1 SRPy -1 objects. -1 * -1 How -1 does -1 partial -1 mock -1 fit -1 into -1 this -1 paradigm? -1 Well, -1 it -1 just -1 doesn't... -1 * -1 Partial -1 mock -1 usually -1 means -1 that -1 the -1 complexity -1 has -1 been -1 moved -1 to -1 a -1 different -1 method -1 on -1 the -1 same -1 object. -1 * -1 In -1 most -1 cases, -1 this -1 is -1 not -1 the -1 way -1 you -1 want -1 to -1 design -1 your -1 application. -1 * -1 <p> -1 * -1 However, -1 there -1 are -1 rare -1 cases -1 when -1 partial -1 mocks -1 come -1 handy: -1 * -1 dealing -1 with -1 code -1 you -1 cannot -1 change -1 easily -1 (3rd -1 party -1 interfaces, -1 interim -1 refactoring -1 of -1 legacy -1 code -1 etc.) -1 * -1 However, -1 I -1 wouldn't -1 use -1 partial -1 mocks -1 for -1 new, -1 test-driven -1 & -1 well-designed -1 code. -1 * -1 <p> -1 * -1 Example: -1 * -1 * -1 <pre> -1 * -1 List -1 list -1 = -1 new -1 LinkedList(); -1 * -1 List -1 spy -1 = -1 spy(list); -1 * -1 * -1 //optionally, -1 you -1 can -1 stub -1 out -1 some -1 methods: -1 * -1 when(spy.size()).thenReturn(100); -1 * -1 * -1 //using -1 the -1 spy -1 calls -1 <b>real</b> -1 methods -1 * -1 spy.add("one"); -1 * -1 spy.add("two"); -1 * -1 * -1 //prints -1 "one" -1 - -1 the -1 first -1 element -1 of -1 a -1 list -1 * -1 System.out.println(spy.get(0)); -1 * -1 * -1 //size() -1 method -1 was -1 stubbed -1 - -1 100 -1 is -1 printed -1 * -1 System.out.println(spy.size()); -1 * -1 * -1 //optionally, -1 you -1 can -1 verify -1 * -1 verify(spy).add("one"); -1 * -1 verify(spy).add("two"); -1 * -1 </pre> -1 * -1 * -1 <h4>Important -1 gotcha -1 on -1 spying -1 real -1 objects!</h4> -1 * -1 * -1 1. -1 Sometimes -1 it's -1 impossible -1 to -1 use -1 {@link -1 Mockito#when(Object)} -1 for -1 stubbing -1 spies. -1 Example: -1 * -1 * -1 <pre> -1 * -1 List -1 list -1 = -1 new -1 LinkedList(); -1 * -1 List -1 spy -1 = -1 spy(list); -1 * -1 * -1 //Impossible: -1 real -1 method -1 is -1 called -1 so -1 spy.get(0) -1 throws -1 IndexOutOfBoundsException -1 (the -1 list -1 is -1 yet -1 empty) -1 * -1 when(spy.get(0)).thenReturn("foo"); -1 * -1 * -1 //You -1 have -1 to -1 use -1 doReturn() -1 for -1 stubbing -1 * -1 doReturn("foo").when(spy).get(0); -1 * -1 </pre> -1 * -1 * -1 2. -1 Watch -1 out -1 for -1 final -1 methods. -1 * -1 Mockito -1 doesn't -1 mock -1 final -1 methods -1 so -1 the -1 bottom -1 line -1 is: -1 when -1 you -1 spy -1 on -1 real -1 objects -1 + -1 you -1 try -1 to -1 stub -1 a -1 final -1 method -1 = -1 trouble. -1 * -1 What -1 will -1 happen -1 is -1 the -1 real -1 method -1 will -1 be -1 called -1 *on -1 mock* -1 but -1 *not -1 on -1 the -1 real -1 instance* -1 you -1 passed -1 to -1 the -1 spy() -1 method. -1 * -1 Typically -1 you -1 may -1 get -1 a -1 NullPointerException -1 because -1 mock -1 instances -1 don't -1 have -1 fields -1 initiated. -1 * -1 * -1 <p> -1 * -1 See -1 examples -1 in -1 javadoc -1 for -1 {@link -1 Mockito} -1 class -1 * -1 * -1 @param -1 object -1 * -1 to -1 spy -1 on -1 * -1 @return -1 a -1 spy -1 of -1 the -1 real -1 object -1 */ -1 public -1 static -1 <T> -1 T -1 spy(T -1 object) -1 { -1 return -1 MOCKITO_CORE.mock((Class<T>) -1 object.getClass(), -1 withSettings() -1 .spiedInstance(object) -1 ---- -1 ---.defaultAnswer(CALLS_REAL_METHODS)); -1 ++++ -1 +++.defaultAnswer(CALLS_REAL_METHODS), -1 +++true); -1 } -1 /** -1 * -1 <pre> -1 * -1 //Instead -1 of: -1 * -1 stub(mock.count()).toReturn(10); -1 * -1 * -1 //Please -1 do: -1 * -1 when(mock.count()).thenReturn(10); -1 * -1 </pre> -1 * -1 * -1 Many -1 users -1 found -1 stub() -1 confusing -1 therefore -1 stub() -1 has -1 been -1 deprecated -1 in -1 favor -1 of -1 {@link -1 Mockito#when(Object)} -1 * -1 <p> -1 * -1 How -1 to -1 fix -1 deprecation -1 warnings? -1 Typically -1 it's -1 just -1 few -1 minutes -1 of -1 search -1 & -1 replace -1 job: -1 * -1 <pre> -1 * -1 Mockito.stub; -1 <i>replace -1 with:</i> -1 Mockito.when; -1 * -1 stub( -1 <i>replace -1 with:</i> -1 when( -1 * -1 .toReturn( -1 <i>replace -1 with:</i> -1 .thenReturn( -1 * -1 .toThrow( -1 <i>replace -1 with:</i> -1 .thenThrow( -1 * -1 .toAnswer( -1 <i>replace -1 with:</i> -1 .thenAnswer( -1 * -1 </pre> -1 * -1 If -1 you're -1 an -1 existing -1 user -1 then -1 sorry -1 for -1 making -1 your -1 code -1 littered -1 with -1 deprecation -1 warnings. -1 ------ -1 ---a/src/org/mockito/internal/MockitoCore.java -1 ++++++ -1 +++b/src/org/mockito/internal/MockitoCore.java -1 @@ -1 -1,38 -1 +1,39 -1 @@ -1 /* -1 * -1 Copyright -1 (c) -1 2007 -1 Mockito -1 contributors -1 * -1 This -1 program -1 is -1 made -1 available -1 under -1 the -1 terms -1 of -1 the -1 MIT -1 License. -1 */ -1 package -1 org.mockito.internal; -1 import -1 org.mockito.InOrder; -1 import -1 org.mockito.MockSettings; -1 import -1 org.mockito.exceptions.Reporter; -1 import -1 org.mockito.exceptions.misusing.NotAMockException; -1 import -1 org.mockito.internal.creation.MockSettingsImpl; -1 import -1 org.mockito.internal.invocation.Invocation; -1 import -1 org.mockito.internal.progress.IOngoingStubbing; -1 import -1 org.mockito.internal.progress.MockingProgress; -1 import -1 org.mockito.internal.progress.ThreadSafeMockingProgress; -1 import -1 org.mockito.internal.stubbing.OngoingStubbingImpl; -1 import -1 org.mockito.internal.stubbing.StubberImpl; -1 import -1 org.mockito.internal.util.MockUtil; -1 import -1 org.mockito.internal.verification.api.VerificationMode; -1 import -1 org.mockito.stubbing.*; -1 import -1 java.util.Arrays; -1 import -1 java.util.List; -1 @SuppressWarnings("unchecked") -1 public -1 class -1 MockitoCore -1 { -1 private -1 final -1 Reporter -1 reporter -1 = -1 new -1 Reporter(); -1 private -1 final -1 MockUtil -1 mockUtil -1 = -1 new -1 MockUtil(); -1 private -1 final -1 MockingProgress -1 mockingProgress -1 = -1 new -1 ThreadSafeMockingProgress(); -1 ---- -1 ---public -1 ---<T> -1 ---T -1 ---mock(Class<T> -1 ---classToMock, -1 ---MockSettings -1 ---mockSettings, -1 ---boolean -1 ---shouldResetOngoingStubbing) -1 ---{ -1 ---return -1 ---mock(classToMock, -1 ---mockSettings); -1 ---} -1 ---- -1 ---public -1 ---<T> -1 ---T -1 ---mock(Class<T> -1 ---classToMock, -1 ---MockSettings -1 ---mockSettings) -1 ---{ -1 ++++ -1 +++public -1 +++<T> -1 +++T -1 +++mock(Class<T> -1 +++classToMock, -1 +++MockSettings -1 +++mockSettings, -1 +++boolean -1 +++shouldResetOngoingStubbing) -1 +++{ -1 mockingProgress.validateState(); -1 ++++ -1 +++if -1 +++(shouldResetOngoingStubbing) -1 +++{ -1 mockingProgress.resetOngoingStubbing(); -1 ++++ -1 +++} -1 return -1 mockUtil.createMock(classToMock, -1 (MockSettingsImpl) -1 mockSettings); -1 } -1 -2
package -1 org.mockito.internal.configuration.injection; -1 import -1 org.mockito.exceptions.base.MockitoException; -1 ++++import -1 +++org.mockito.internal.util.reflection.BeanPropertySetter; -1 import -1 org.mockito.internal.util.reflection.FieldSetter; -1 import -1 java.lang.reflect.Field; -1 @@ -1 -22,7 -1 +23,9 -1 @@ -1 public -1 OngoingInjecter -1 filterCandidate(final -1 Collection<Object> -1 mocks, -1 final -1 Fie -1 return -1 new -1 OngoingInjecter() -1 { -1 public -1 boolean -1 thenInject() -1 { -1 try -1 { -1 ++++ -1 +++if -1 +++(!new -1 +++BeanPropertySetter(fieldInstance, -1 +++field).set(matchingMock)) -1 +++{ -1 new -1 FieldSetter(fieldInstance, -1 field).set(matchingMock); -1 ++++ -1 +++} -1 } -1 catch -1 (Exception -1 e) -1 { -1 throw -1 new -1 MockitoException("Problems -1 injecting -1 dependency -1 in -1 " -1 + -1 field.getName(), -1 e); -1 } -1 -2
import -1 org.mockito.internal.stubbing.OngoingStubbingImpl; -1 import -1 org.mockito.internal.stubbing.StubbedInvocationMatcher; -1 import -1 org.mockito.internal.stubbing.VoidMethodStubbableImpl; -1 ++++import -1 +++org.mockito.internal.verification.MockAwareVerificationMode; -1 import -1 org.mockito.internal.verification.VerificationDataImpl; -1 import -1 org.mockito.stubbing.Answer; -1 import -1 org.mockito.stubbing.VoidMethodStubbable; -1 @@ -1 -73,9 -1 +74,11 -1 @@ -1 public -1 Object -1 handle(Invocation -1 invocation) -1 throws -1 Throwable -1 { -1 if -1 (verificationMode -1 != -1 null) -1 { -1 //We -1 need -1 to -1 check -1 if -1 verification -1 was -1 started -1 on -1 the -1 correct -1 mock -1 // -1 - -1 see -1 VerifyingWithAnExtraCallToADifferentMockTest -1 ++++ -1 +++if -1 +++(verificationMode -1 +++instanceof -1 +++MockAwareVerificationMode -1 +++&& -1 +++((MockAwareVerificationMode) -1 +++verificationMode).getMock() -1 +++== -1 +++invocation.getMock()) -1 +++{ -1 VerificationDataImpl -1 data -1 = -1 new -1 VerificationDataImpl(invocationContainerImpl.getInvocations(), -1 invocationMatcher); -1 verificationMode.verify(data); -1 return -1 null; -1 ++++ -1 +++} -1 } -1 invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher); -1 ------ -1 ---a/src/org/mockito/internal/MockitoCore.java -1 ++++++ -1 +++b/src/org/mockito/internal/MockitoCore.java -1 @@ -1 -20,6 -1 +20,7 -1 @@ -1 import -1 org.mockito.internal.stubbing.OngoingStubbingImpl; -1 import -1 org.mockito.internal.stubbing.StubberImpl; -1 import -1 org.mockito.internal.util.MockUtil; -1 ++++import -1 +++org.mockito.internal.verification.MockAwareVerificationMode; -1 import -1 org.mockito.internal.verification.VerificationDataImpl; -1 import -1 org.mockito.internal.verification.VerificationModeFactory; -1 import -1 org.mockito.internal.verification.api.InOrderContext; -1 @@ -1 -70,7 -1 +71,7 -1 @@ -1 public -1 IOngoingStubbing -1 stub() -1 { -1 } -1 else -1 if -1 (!mockUtil.isMock(mock)) -1 { -1 reporter.notAMockPassedToVerify(); -1 } -1 ---- -1 ---mockingProgress.verificationStarted(mode); -1 ++++ -1 +++mockingProgress.verificationStarted(new -1 +++MockAwareVerificationMode(mock, -1 +++mode)); -1 return -1 mock; -1 } -1 -2
public -1 Class -1 getGenericType(Field -1 field) -1 { -1 Type -1 generic -1 = -1 field.getGenericType(); -1 if -1 (generic -1 != -1 null -1 && -1 generic -1 instanceof -1 ParameterizedType) -1 { -1 Type -1 actual -1 = -1 ((ParameterizedType) -1 generic).getActualTypeArguments()[0]; -1 ++++ -1 +++if -1 +++(actual -1 +++instanceof -1 +++Class) -1 +++{ -1 return -1 (Class) -1 actual; -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(actual -1 +++instanceof -1 +++ParameterizedType) -1 +++{ -1 //in -1 case -1 of -1 nested -1 generics -1 we -1 don't -1 go -1 deep -1 ++++ -1 +++return -1 +++(Class) -1 +++((ParameterizedType) -1 +++actual).getRawType(); -1 ++++ -1 +++} -1 } -1 return -1 Object.class; -1 -2
public -1 Object -1 handle(Invocation -1 invocation) -1 throws -1 Throwable -1 { -1 if -1 (verificationMode -1 != -1 null) -1 { -1 //We -1 need -1 to -1 check -1 if -1 verification -1 was -1 started -1 on -1 the -1 correct -1 mock -1 // -1 - -1 see -1 VerifyingWithAnExtraCallToADifferentMockTest -1 (bug -1 138) -1 ---- -1 ---if -1 ---(verificationMode -1 ---instanceof -1 ---MockAwareVerificationMode -1 ---&& -1 ---((MockAwareVerificationMode) -1 ---verificationMode).getMock() -1 ---== -1 ---invocation.getMock()) -1 ---{ -1 ++++ -1 +++if -1 +++(((MockAwareVerificationMode) -1 +++verificationMode).getMock() -1 +++== -1 +++invocation.getMock()) -1 +++{ -1 VerificationDataImpl -1 data -1 = -1 new -1 VerificationDataImpl(invocationContainerImpl, -1 invocationMatcher); -1 verificationMode.verify(data); -1 return -1 null; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 // -1 this -1 means -1 there -1 is -1 an -1 invocation -1 on -1 a -1 different -1 mock. -1 Re-adding -1 verification -1 mode -1 // -1 - -1 see -1 VerifyingWithAnExtraCallToADifferentMockTest -1 (bug -1 138) -1 ++++ -1 +++mockingProgress.verificationStarted(verificationMode); -1 } -1 } -1 -2
private -1 Object -1 spiedInstance; -1 private -1 Answer<Object> -1 defaultAnswer; -1 private -1 MockName -1 mockName; -1 ++++ -1 +++private -1 +++boolean -1 +++serializable; -1 public -1 MockSettings -1 serializable() -1 { -1 ---- -1 ---return -1 ---this.extraInterfaces(java.io.Serializable.class); -1 ++++ -1 +++this.serializable -1 +++= -1 +++true; -1 ++++ -1 +++return -1 +++this; -1 } -1 public -1 MockSettings -1 extraInterfaces(Class<?>... -1 extraInterfaces) -1 { -1 @@ -1 -71,7 -1 +73,7 -1 @@ -1 public -1 MockSettings -1 defaultAnswer(Answer -1 defaultAnswer) -1 { -1 } -1 public -1 boolean -1 isSerializable() -1 { -1 ---- -1 ---return -1 ---extraInterfaces -1 ---!= -1 ---null -1 ---&& -1 ---java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class); -1 ++++ -1 +++return -1 +++serializable; -1 } -1 public -1 void -1 initiateMockName(Class -1 classToMock) -1 { -1 ------ -1 ---a/src/org/mockito/internal/util/MockUtil.java -1 ++++++ -1 +++b/src/org/mockito/internal/util/MockUtil.java -1 @@ -1 -16,6 -1 +16,7 -1 @@ -1 import -1 org.mockito.internal.creation.jmock.ClassImposterizer; -1 import -1 org.mockito.internal.util.reflection.LenientCopyTool; -1 ++++import -1 +++java.io.Serializable; -1 @SuppressWarnings("unchecked") -1 public -1 class -1 MockUtil -1 { -1 @@ -1 -42,7 -1 +43,11 -1 @@ -1 public -1 MockUtil() -1 { -1 Class<?>[] -1 interfaces -1 = -1 settings.getExtraInterfaces(); -1 Class<?>[] -1 ancillaryTypes; -1 ++++ -1 +++if -1 +++(settings.isSerializable()) -1 +++{ -1 ++++ -1 +++ancillaryTypes -1 +++= -1 +++interfaces -1 +++== -1 +++null -1 +++? -1 +++new -1 +++Class<?>[] -1 +++{Serializable.class} -1 +++: -1 +++new -1 +++ArrayUtils().concat(interfaces, -1 +++Serializable.class); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ancillaryTypes -1 = -1 interfaces -1 == -1 null -1 ? -1 new -1 Class<?>[0] -1 : -1 interfaces; -1 ++++ -1 +++} -1 Object -1 spiedInstance -1 = -1 settings.getSpiedInstance(); -1 -2
Object -1 returnValueFor(Class<?> -1 type) -1 { -1 return -1 Primitives.defaultValueForPrimitiveOrWrapper(type); -1 //new -1 instances -1 are -1 used -1 instead -1 of -1 Collections.emptyList(), -1 etc. -1 //to -1 avoid -1 UnsupportedOperationException -1 if -1 code -1 under -1 test -1 modifies -1 returned -1 collection -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(type -1 +++== -1 +++Iterable.class) -1 +++{ -1 ++++ -1 +++return -1 +++new -1 +++ArrayList<Object>(0); -1 } -1 else -1 if -1 (type -1 == -1 Collection.class) -1 { -1 return -1 new -1 LinkedList<Object>(); -1 } -1 else -1 if -1 (type -1 == -1 Set.class) -1 { -1 -2
public -1 class -1 Equality -1 { -1 public -1 static -1 boolean -1 areEqual(Object -1 o1, -1 Object -1 o2) -1 { -1 ---- -1 ---if -1 ---(o1 -1 ---== -1 ---null -1 ---|| -1 ---o2 -1 ---== -1 ---null) -1 ---{ -1 ++++ -1 +++if -1 +++(o1 -1 +++== -1 +++o2 -1 +++) -1 +++{ -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(o1 -1 +++== -1 +++null -1 +++|| -1 +++o2 -1 +++== -1 +++null) -1 +++{ -1 return -1 o1 -1 == -1 null -1 && -1 o2 -1 == -1 null; -1 } -1 else -1 if -1 (isArray(o1)) -1 { -1 return -1 isArray(o2) -1 && -1 areArraysEqual(o1, -1 o2); -1 -2
public -1 ByteBuddyMockMaker() -1 { -1 settings.getTypeToMock(), -1 settings.getExtraInterfaces() -1 ); -1 ++++ -1 +++Instantiator -1 +++instantiator -1 +++= -1 +++new -1 +++InstantiatorProvider().getInstantiator(settings); -1 T -1 mockInstance -1 = -1 null; -1 try -1 { -1 ---- -1 ---mockInstance -1 ---= -1 ---classInstantiator.instantiate(mockedProxyType); -1 ++++ -1 +++mockInstance -1 +++= -1 +++instantiator.newInstance(mockedProxyType); -1 MockMethodInterceptor.MockAccess -1 mockAccess -1 = -1 (MockMethodInterceptor.MockAccess) -1 mockInstance; -1 mockAccess.setMockitoInterceptor(new -1 MockMethodInterceptor(asInternalMockHandler(handler), -1 settings)); -1 @@ -1 -42,7 -1 +43,7 -1 @@ -1 public -1 ByteBuddyMockMaker() -1 { -1 " -1 class -1 to -1 mock -1 : -1 " -1 + -1 describeClass(mockedProxyType), -1 " -1 created -1 class -1 : -1 " -1 + -1 describeClass(settings.getTypeToMock()), -1 " -1 proxy -1 instance -1 class -1 : -1 " -1 + -1 describeClass(mockInstance), -1 ---- -1 ---" -1 ---instance -1 ---creation -1 ---by -1 ---: -1 ---" -1 ---+ -1 ---classInstantiator.getClass().getSimpleName(), -1 ++++ -1 +++" -1 +++instance -1 +++creation -1 +++by -1 +++: -1 +++" -1 ++++ -1 +++instantiator.getClass().getSimpleName(), -1 "", -1 "You -1 might -1 experience -1 classloading -1 issues, -1 please -1 ask -1 the -1 mockito -1 mailing-list.", -1 "" -1 -2
private -1 boolean -1 injectMockCandidates(Class<?> -1 awaitingInjectionClazz, -1 Set<Object -1 private -1 boolean -1 injectMockCandidatesOnFields(Set<Object> -1 mocks, -1 Object -1 instance, -1 boolean -1 injectionOccurred, -1 List<Field> -1 orderedInstanceFields) -1 { -1 for -1 (Iterator<Field> -1 it -1 = -1 orderedInstanceFields.iterator(); -1 it.hasNext(); -1 ) -1 { -1 Field -1 field -1 = -1 it.next(); -1 ---- -1 ---Object -1 ---injected -1 ---= -1 ---mockCandidateFilter.filterCandidate(mocks, -1 ---field, -1 ---instance).thenInject(); -1 ++++ -1 +++Object -1 +++injected -1 +++= -1 +++mockCandidateFilter.filterCandidate(mocks, -1 +++field, -1 +++orderedInstanceFields, -1 +++instance).thenInject(); -1 if -1 (injected -1 != -1 null) -1 { -1 injectionOccurred -1 |= -1 true; -1 mocks.remove(injected); -1 ------ -1 ---a/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java -1 ++++++ -1 +++b/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java -1 @@ -1 -10,6 -1 +10,7 -1 @@ -1 import -1 java.lang.reflect.Field; -1 import -1 java.util.Collection; -1 ++++import -1 +++java.util.List; -1 /** -1 * -1 This -1 node -1 returns -1 an -1 actual -1 injecter -1 which -1 will -1 be -1 either -1 : -1 @@ -1 -20,7 -1 +21,7 -1 @@ -1 * -1 </ul> -1 */ -1 public -1 class -1 FinalMockCandidateFilter -1 implements -1 MockCandidateFilter -1 { -1 ---- -1 ---public -1 ---OngoingInjecter -1 ---filterCandidate(final -1 ---Collection<Object> -1 ---mocks, -1 ---final -1 ---Field -1 ---field, -1 ---final -1 ---Object -1 ---fieldInstance) -1 ---{ -1 ++++ -1 +++public -1 +++OngoingInjecter -1 +++filterCandidate(final -1 +++Collection<Object> -1 +++mocks, -1 +++final -1 +++Field -1 +++field, -1 +++List<Field> -1 +++fields, -1 +++final -1 +++Object -1 +++fieldInstance) -1 +++{ -1 if(mocks.size() -1 == -1 1) -1 { -1 final -1 Object -1 matchingMock -1 = -1 mocks.iterator().next(); -1 ------ -1 ---a/src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java -1 ++++++ -1 +++b/src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java -1 @@ -1 -6,13 -1 +6,14 -1 @@ -1 import -1 java.lang.reflect.Field; -1 import -1 java.util.Collection; -1 ++++import -1 +++java.util.List; -1 public -1 interface -1 MockCandidateFilter -1 { -1 OngoingInjecter -1 filterCandidate( -1 Collection<Object> -1 mocks, -1 Field -1 fieldToBeInjected, -1 ---- -1 ---Object -1 ---fieldInstance -1 ++++ -1 +++List<Field> -1 +++fields, -1 +++Object -1 +++instance -1 ); -1 } -1 ------ -1 ---a/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java -1 ++++++ -1 +++b/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java -1 @@ -1 -20,7 -1 +20,7 -1 @@ -1 public -1 NameBasedCandidateFilter(MockCandidateFilter -1 next) -1 { -1 } -1 public -1 OngoingInjecter -1 filterCandidate(Collection<Object> -1 mocks, -1 ---- -1 ---Field -1 ---field, -1 ---Object -1 ---fieldInstance) -1 ---{ -1 ++++ -1 +++Field -1 +++field, -1 +++List<Field> -1 +++fields, -1 +++Object -1 +++fieldInstance) -1 +++{ -1 List<Object> -1 mockNameMatches -1 = -1 new -1 ArrayList<Object>(); -1 if -1 (mocks.size() -1 > -1 1) -1 { -1 for -1 (Object -1 mock -1 : -1 mocks) -1 { -1 @@ -1 -28,7 -1 +28,7 -1 @@ -1 public -1 OngoingInjecter -1 filterCandidate(Collection<Object> -1 mocks, -1 mockNameMatches.add(mock); -1 } -1 } -1 ---- -1 ---return -1 ---next.filterCandidate(mockNameMatches, -1 ---field, -1 ++++ -1 +++return -1 +++next.filterCandidate(mockNameMatches, -1 +++field, -1 +++fields, -1 fieldInstance); -1 /* -1 * -1 In -1 this -1 case -1 we -1 have -1 to -1 check -1 whether -1 we -1 have -1 conflicting -1 naming -1 @@ -1 -39,7 -1 +39,23 -1 @@ -1 public -1 OngoingInjecter -1 filterCandidate(Collection<Object> -1 mocks, -1 * -1 whenever -1 we -1 find -1 a -1 field -1 that -1 does -1 match -1 its -1 name -1 with -1 the -1 mock -1 * -1 name, -1 we -1 should -1 take -1 that -1 field -1 instead. -1 */ -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(mocks.size() -1 +++== -1 +++1) -1 +++{ -1 ++++ -1 +++String -1 +++mockName -1 +++= -1 +++mockUtil.getMockName(mocks.iterator().next()) -1 ++++ -1 +++.toString(); -1 ++++ -1 ++++ -1 +++for -1 +++(Field -1 +++otherField -1 +++: -1 +++fields) -1 +++{ -1 ++++ -1 +++if -1 +++(!otherField.equals(field) -1 ++++ -1 +++&& -1 +++otherField.getType().equals(field.getType()) -1 ++++ -1 +++&& -1 +++otherField.getName().equals(mockName)) -1 +++{ -1 ++++ -1 ++++ -1 +++return -1 +++new -1 +++OngoingInjecter() -1 +++{ -1 ++++ -1 +++public -1 +++Object -1 +++thenInject() -1 +++{ -1 ++++ -1 +++return -1 +++null; -1 ++++ -1 +++} -1 ++++ -1 +++}; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 } -1 ---- -1 ---return -1 ---next.filterCandidate(mocks, -1 ---field, -1 ---fieldInstance); -1 ++++ -1 +++return -1 +++next.filterCandidate(mocks, -1 +++field, -1 +++fields, -1 +++fieldInstance); -1 } -1 } -1 ------ -1 ---a/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java -1 ++++++ -1 +++b/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java -1 @@ -1 -17,7 -1 +17,7 -1 @@ -1 public -1 TypeBasedCandidateFilter(MockCandidateFilter -1 next) -1 { -1 this.next -1 = -1 next; -1 } -1 ---- -1 ---public -1 ---OngoingInjecter -1 ---filterCandidate(Collection<Object> -1 ---mocks, -1 ---Field -1 ---field, -1 ---Object -1 ---fieldInstance) -1 ---{ -1 ++++ -1 +++public -1 +++OngoingInjecter -1 +++filterCandidate(Collection<Object> -1 +++mocks, -1 +++Field -1 +++field, -1 +++List<Field> -1 +++fields, -1 +++Object -1 +++fieldInstance) -1 +++{ -1 List<Object> -1 mockTypeMatches -1 = -1 new -1 ArrayList<Object>(); -1 for -1 (Object -1 mock -1 : -1 mocks) -1 { -1 if -1 (field.getType().isAssignableFrom(mock.getClass())) -1 { -1 @@ -1 -25,6 -1 +25,6 -1 @@ -1 public -1 OngoingInjecter -1 filterCandidate(Collection<Object> -1 mocks, -1 Field -1 field, -1 Ob -1 } -1 } -1 ---- -1 ---return -1 ---next.filterCandidate(mockTypeMatches, -1 ---field, -1 ---fieldInstance); -1 ++++ -1 +++return -1 +++next.filterCandidate(mockTypeMatches, -1 +++field, -1 +++fields, -1 +++fieldInstance); -1 } -1 } -1 -2
public -1 ConstructorInstantiator(Object -1 outerClassInstance) -1 { -1 if -1 (outerClassInstance -1 == -1 null) -1 { -1 return -1 noArgConstructor(cls); -1 } -1 ---- -1 ---return -1 ---withOuterClass(cls); -1 ++++ -1 +++return -1 +++withParams(cls, -1 +++outerClassInstance); -1 } -1 ---- -1 ---private -1 ---<T> -1 ---T -1 ---withOuterClass(Class<T> -1 ---cls) -1 ---{ -1 ++++ -1 +++private -1 +++static -1 +++<T> -1 +++T -1 +++withParams(Class<T> -1 +++cls, -1 +++Object... -1 +++params) -1 +++{ -1 try -1 { -1 //this -1 is -1 kind -1 of -1 overengineered -1 because -1 we -1 don't -1 need -1 to -1 support -1 more -1 params -1 //however, -1 I -1 know -1 we -1 will -1 be -1 needing -1 it -1 :) -1 ---- -1 ---Constructor<T> -1 ---c -1 ---= -1 ---cls.getDeclaredConstructor(outerClassInstance.getClass()); -1 ---- -1 ---return -1 ---c.newInstance(outerClassInstance); -1 ++++ -1 +++for -1 +++(Constructor<?> -1 +++constructor -1 +++: -1 +++cls.getDeclaredConstructors()) -1 +++{ -1 ++++ -1 +++Class<?>[] -1 +++types -1 +++= -1 +++constructor.getParameterTypes(); -1 ++++ -1 +++if -1 +++(paramsMatch(types, -1 +++params)) -1 +++{ -1 ++++ -1 +++return -1 +++(T) -1 +++constructor.newInstance(params); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 } -1 catch -1 (Exception -1 e) -1 { -1 throw -1 paramsException(cls, -1 e); -1 } -1 ++++ -1 +++throw -1 +++paramsException(cls, -1 +++null); -1 } -1 private -1 static -1 <T> -1 InstantationException -1 paramsException(Class<T> -1 cls, -1 Exception -1 e) -1 { -1 @@ -1 -33,6 -1 +38,17 -1 @@ -1 public -1 ConstructorInstantiator(Object -1 outerClassInstance) -1 { -1 + -1 cls.getSimpleName() -1 + -1 "'.\nPlease -1 ensure -1 that -1 the -1 outer -1 instance -1 has -1 correct -1 type -1 and -1 that -1 the -1 target -1 class -1 has -1 parameter-less -1 constructor.", -1 e); -1 } -1 ++++ -1 +++private -1 +++static -1 +++boolean -1 +++paramsMatch(Class<?>[] -1 +++types, -1 +++Object[] -1 +++params) -1 +++{ -1 ++++ -1 +++if -1 +++(params.length -1 +++!= -1 +++types.length) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++params.length; -1 +++i++) -1 +++{ -1 ++++ -1 +++if -1 +++(!types[i].isInstance(params[i])) -1 +++{ -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 private -1 static -1 <T> -1 T -1 noArgConstructor(Class<T> -1 cls) -1 { -1 try -1 { -1 -2
private -1 static -1 final -1 long -1 serialVersionUID -1 = -1 -7105341425736035847L; -1 ---- -1 ---private -1 ---MockitoCore -1 ---mockitoCore -1 ---= -1 ---new -1 ---MockitoCore(); -1 ---- -1 ---private -1 ---ReturnsEmptyValues -1 ---delegate -1 ---= -1 ---new -1 ---ReturnsEmptyValues(); -1 ++++ -1 +++private -1 +++transient -1 +++MockitoCore -1 +++mockitoCore; -1 ++++ -1 +++private -1 +++transient -1 +++ReturnsEmptyValues -1 +++delegate; -1 public -1 Object -1 answer(InvocationOnMock -1 invocation) -1 throws -1 Throwable -1 { -1 GenericMetadataSupport -1 returnTypeGenericMetadata -1 = -1 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod()); -1 Class<?> -1 rawType -1 = -1 returnTypeGenericMetadata.rawType(); -1 ++++ -1 +++instantiateMockitoCoreIfNeeded(); -1 ++++ -1 +++instantiateDelegateIfNeeded(); -1 if -1 (!mockitoCore.isTypeMockable(rawType)) -1 { -1 return -1 delegate.returnValueFor(rawType); -1 } -1 @@ -1 -56,7 -1 +58,17 -1 @@ -1 public -1 Object -1 answer(InvocationOnMock -1 invocation) -1 throws -1 Throwable -1 { -1 return -1 getMock(invocation, -1 returnTypeGenericMetadata); -1 } -1 ++++ -1 +++private -1 +++synchronized -1 +++void -1 +++instantiateMockitoCoreIfNeeded() -1 +++{ -1 ++++ -1 +++if -1 +++(mockitoCore -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++mockitoCore -1 +++= -1 +++new -1 +++MockitoCore(); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++private -1 +++synchronized -1 +++void -1 +++instantiateDelegateIfNeeded() -1 +++{ -1 ++++ -1 +++if -1 +++(delegate -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++delegate -1 +++= -1 +++new -1 +++ReturnsEmptyValues(); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 private -1 Object -1 getMock(InvocationOnMock -1 invocation, -1 GenericMetadataSupport -1 returnTypeGenericMetadata) -1 throws -1 Throwable -1 { -1 InternalMockHandler<Object> -1 handler -1 = -1 new -1 MockUtil().getMockHandler(invocation.getMock()); -1 @@ -1 -97,6 -1 +109,7 -1 @@ -1 private -1 MockSettings -1 withSettingsUsing(GenericMetadataSupport -1 returnTypeGenericM -1 : -1 withSettings(); -1 return -1 mockSettings -1 ++++ -1 +++.serializable() -1 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata)); -1 } -1 @@ -1 -111,7 -1 +124,7 -1 @@ -1 protected -1 GenericMetadataSupport -1 actualParameterizedType(Object -1 mock) -1 { -1 private -1 Object -1 recordDeepStubMock(final -1 Object -1 mock, -1 InvocationContainerImpl -1 container) -1 throws -1 Throwable -1 { -1 ---- -1 ---container.addAnswer(new -1 ---Answer<Object>() -1 ---{ -1 ++++ -1 +++container.addAnswer(new -1 +++SerializableAnswer() -1 +++{ -1 public -1 Object -1 answer(InvocationOnMock -1 invocation) -1 throws -1 Throwable -1 { -1 return -1 mock; -1 } -1 @@ -1 -120,7 -1 +133,9 -1 @@ -1 public -1 Object -1 answer(InvocationOnMock -1 invocation) -1 throws -1 Throwable -1 { -1 return -1 mock; -1 } -1 ++++ -1 +++abstract -1 +++class -1 +++SerializableAnswer -1 +++implements -1 +++Answer<Object>, -1 +++Serializable -1 +++{ -1 ++++ -1 +++} -1 protected -1 GenericMetadataSupport -1 actualParameterizedType(Object -1 mock) -1 { -1 -2
public -1 void -1 injectMocksOnFields(Set<Field> -1 injectMocksFields, -1 Set<Object> -1 mocks, -1 private -1 void -1 injectMockCandidate(Class<?> -1 awaitingInjectionClazz, -1 Set<Object> -1 mocks, -1 Object -1 fieldInstance) -1 { -1 for(Field -1 field -1 : -1 orderedInstanceFieldsFrom(awaitingInjectionClazz)) -1 { -1 ---- -1 ---mockCandidateFilter.filterCandidate(mocks, -1 ---field, -1 ---fieldInstance).thenInject(); -1 ++++ -1 +++Object -1 +++injected -1 +++= -1 +++mockCandidateFilter.filterCandidate(mocks, -1 +++field, -1 +++fieldInstance).thenInject(); -1 ++++ -1 +++mocks.remove(injected); -1 } -1 } -1 -2
public -1 Object -1 answer(InvocationOnMock -1 invocation) -1 { -1 //see -1 issue -1 184. -1 //mocks -1 by -1 default -1 should -1 return -1 0 -1 if -1 references -1 are -1 the -1 same, -1 otherwise -1 some -1 other -1 value -1 because -1 they -1 are -1 not -1 the -1 same. -1 Hence -1 we -1 return -1 1 -1 (anything -1 but -1 0 -1 is -1 good). -1 //Only -1 for -1 compareTo() -1 method -1 by -1 the -1 Comparable -1 interface -1 ---- -1 ---return -1 ---1; -1 ++++ -1 +++return -1 +++invocation.getMock() -1 +++== -1 +++invocation.getArguments()[0] -1 +++? -1 +++0 -1 +++: -1 +++1; -1 } -1 Class<?> -1 returnType -1 = -1 invocation.getMethod().getReturnType(); -1 -2
public -1 boolean -1 matches(Object -1 actual) -1 { -1 public -1 void -1 describeTo(Description -1 description) -1 { -1 description.appendText("same("); -1 appendQuoting(description); -1 ---- -1 ---description.appendText(wanted.toString()); -1 ++++ -1 +++description.appendText(wanted -1 +++== -1 +++null -1 +++? -1 +++"null" -1 +++: -1 +++wanted.toString()); -1 appendQuoting(description); -1 description.appendText(")"); -1 } -1 -2
/* -1 * -1 Copyright -1 (c) -1 2007 -1 Mockito -1 contributors -1 * -1 This -1 program -1 is -1 made -1 available -1 under -1 the -1 terms -1 of -1 the -1 MIT -1 License. -1 */ -1 package -1 org.mockito.internal.stubbing.defaultanswers; -1 ++++import -1 +++org.mockito.MockSettings; -1 import -1 org.mockito.internal.InternalMockHandler; -1 import -1 org.mockito.internal.creation.settings.CreationSettings; -1 import -1 org.mockito.internal.stubbing.InvocationContainerImpl; -1 import -1 org.mockito.internal.stubbing.StubbedInvocationMatcher; -1 import -1 org.mockito.internal.util.MockCreationValidator; -1 import -1 org.mockito.internal.util.MockUtil; -1 import -1 org.mockito.internal.util.reflection.GenericMetadataSupport; -1 import -1 org.mockito.invocation.InvocationOnMock; -1 import -1 org.mockito.stubbing.Answer; -1 import -1 java.io.Serializable; -1 ++++import -1 +++static -1 +++org.mockito.Mockito.mock; -1 ++++import -1 +++static -1 +++org.mockito.Mockito.withSettings; -1 /** -1 * -1 Returning -1 deep -1 stub -1 implementation. -1 * -1 * -1 Will -1 return -1 previously -1 created -1 mock -1 if -1 the -1 invocation -1 matches. -1 * -1 * -1 <p>Supports -1 nested -1 generic -1 information, -1 with -1 this -1 answer -1 you -1 can -1 write -1 code -1 like -1 this -1 : -1 * -1 * -1 <pre -1 class="code"><code -1 class="java"> -1 * -1 interface -1 GenericsNest&lt;K -1 extends -1 Comparable&lt;K&gt; -1 & -1 Cloneable&gt; -1 extends -1 Map&lt;K, -1 Set&lt;Number&gt;&gt; -1 {} -1 * -1 * -1 GenericsNest&lt;?&gt; -1 mock -1 = -1 mock(GenericsNest.class, -1 new -1 ReturnsGenericDeepStubs()); -1 * -1 Number -1 number -1 = -1 mock.entrySet().iterator().next().getValue().iterator().next(); -1 * -1 </code></pre> -1 * -1 </p> -1 * -1 * -1 @see -1 org.mockito.Mockito#RETURNS_DEEP_STUBS -1 * -1 @see -1 org.mockito.Answers#RETURNS_DEEP_STUBS -1 */ -1 public -1 class -1 ReturnsDeepStubs -1 implements -1 Answer<Object>, -1 Serializable -1 { -1 private -1 static -1 final -1 long -1 serialVersionUID -1 = -1 -7105341425736035847L; -1 private -1 ReturnsEmptyValues -1 delegate -1 = -1 new -1 ReturnsEmptyValues(); -1 public -1 Object -1 answer(InvocationOnMock -1 invocation) -1 throws -1 Throwable -1 { -1 GenericMetadataSupport -1 returnTypeGenericMetadata -1 = -1 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod()); -1 Class<?> -1 rawType -1 = -1 returnTypeGenericMetadata.rawType(); -1 if -1 (!new -1 MockCreationValidator().isTypeMockable(rawType)) -1 { -1 return -1 delegate.returnValueFor(rawType); -1 } -1 ---- -1 ---return -1 ---getMock(invocation); -1 ++++ -1 +++return -1 +++getMock(invocation, -1 +++returnTypeGenericMetadata); -1 } -1 ---- -1 ---private -1 ---Object -1 ---getMock(InvocationOnMock -1 ---invocation) -1 ---throws -1 ---Throwable -1 ---{ -1 ++++ -1 +++private -1 +++Object -1 +++getMock(InvocationOnMock -1 +++invocation, -1 +++GenericMetadataSupport -1 +++returnTypeGenericMetadata) -1 +++throws -1 +++Throwable -1 +++{ -1 InternalMockHandler<Object> -1 handler -1 = -1 new -1 MockUtil().getMockHandler(invocation.getMock()); -1 InvocationContainerImpl -1 container -1 = -1 (InvocationContainerImpl) -1 handler.getInvocationContainer(); -1 // -1 matches -1 invocation -1 for -1 verification -1 for -1 (StubbedInvocationMatcher -1 stubbedInvocationMatcher -1 : -1 container.getStubbedInvocations()) -1 { -1 if(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) -1 { -1 return -1 stubbedInvocationMatcher.answer(invocation); -1 } -1 } -1 // -1 deep -1 stub -1 ---- -1 ---return -1 ---recordDeepStubMock(invocation, -1 ---container); -1 ++++ -1 +++return -1 +++recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), -1 +++container); -1 } -1 /** -1 * -1 Creates -1 a -1 mock -1 using -1 the -1 Generics -1 Metadata. -1 * -1 * -1 @param -1 returnTypeGenericMetadata -1 The -1 metadata -1 to -1 use -1 to -1 create -1 the -1 new -1 mock. -1 * -1 @return -1 The -1 mock -1 */ -1 ++++ -1 +++private -1 +++Object -1 +++createNewDeepStubMock(GenericMetadataSupport -1 +++returnTypeGenericMetadata) -1 +++{ -1 ++++ -1 +++return -1 +++mock( -1 ++++ -1 +++returnTypeGenericMetadata.rawType(), -1 ++++ -1 +++withSettingsUsing(returnTypeGenericMetadata) -1 ++++ -1 +++); -1 ++++ -1 +++} -1 ++++ -1 +++private -1 +++MockSettings -1 +++withSettingsUsing(GenericMetadataSupport -1 +++returnTypeGenericMetadata) -1 +++{ -1 ++++ -1 +++MockSettings -1 +++mockSettings -1 +++= -1 ++++ -1 +++returnTypeGenericMetadata.rawExtraInterfaces().length -1 +++> -1 +++0 -1 +++? -1 ++++ -1 +++withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces()) -1 ++++ -1 +++: -1 +++withSettings(); -1 ++++ -1 +++return -1 +++mockSettings -1 ++++ -1 +++.defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata)); -1 ++++ -1 +++} -1 ++++ -1 +++private -1 +++ReturnsDeepStubs -1 +++returnsDeepStubsAnswerUsing(final -1 +++GenericMetadataSupport -1 +++returnTypeGenericMetadata) -1 +++{ -1 ++++ -1 +++return -1 +++new -1 +++ReturnsDeepStubs() -1 +++{ -1 ++++ -1 +++@Override -1 ++++ -1 +++protected -1 +++GenericMetadataSupport -1 +++actualParameterizedType(Object -1 +++mock) -1 +++{ -1 ++++ -1 +++return -1 +++returnTypeGenericMetadata; -1 ++++ -1 +++} -1 ++++ -1 +++}; -1 ++++ -1 +++} -1 ---- -1 ---private -1 ---Object -1 ---recordDeepStubMock(InvocationOnMock -1 ---invocation, -1 ---InvocationContainerImpl -1 ---container) -1 ---{ -1 ---- -1 ---Class<?> -1 ---clz -1 ---= -1 ---invocation.getMethod().getReturnType(); -1 ---- -1 ---final -1 ---Object -1 ---mock -1 ---= -1 ---org.mockito.Mockito.mock(clz, -1 ---this); -1 ++++ -1 +++private -1 +++Object -1 +++recordDeepStubMock(final -1 +++Object -1 +++mock, -1 +++InvocationContainerImpl -1 +++container) -1 +++throws -1 +++Throwable -1 +++{ -1 container.addAnswer(new -1 Answer<Object>() -1 { -1 -2
public -1 MockUtil() -1 { -1 public -1 <T> -1 void -1 resetMock(T -1 mock) -1 { -1 MockHandlerInterface<T> -1 oldMockHandler -1 = -1 getMockHandler(mock); -1 ---- -1 ---MockHandler<T> -1 ---newMockHandler -1 ---= -1 ---new -1 ---MockHandler<T>(oldMockHandler); -1 ---- -1 ---MethodInterceptorFilter -1 ---newFilter -1 ---= -1 ---new -1 ---MethodInterceptorFilter(newMockHandler, -1 ---(MockSettingsImpl) -1 ---org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); -1 ++++ -1 +++MethodInterceptorFilter -1 +++newFilter -1 +++= -1 +++newMethodInterceptorFilter(oldMockHandler.getMockSettings()); -1 ((Factory) -1 mock).setCallback(0, -1 newFilter); -1 } -1 -2
public -1 static -1 boolean -1 isPrimitiveWrapper(Class<?> -1 type) -1 { -1 primitiveValues.put(int.class, -1 0); -1 primitiveValues.put(long.class, -1 0L); -1 primitiveValues.put(float.class, -1 0F); -1 ---- -1 ---primitiveValues.put(double.class, -1 ---0); -1 ++++ -1 +++primitiveValues.put(double.class, -1 +++0D); -1 } -1 } -1 \ -1 No -1 newline -1 at -1 end -1 of -1 file -1 -2
import -1 org.mockito.exceptions.base.MockitoException; -1 import -1 org.mockito.internal.util.MockUtil; -1 ++++import -1 +++static -1 +++org.mockito.Mockito.withSettings; -1 @SuppressWarnings({"unchecked"}) -1 public -1 class -1 SpyAnnotationEngine -1 implements -1 AnnotationEngine -1 { -1 @@ -1 -46,7 -1 +47,10 -1 @@ -1 public -1 void -1 process(Class<?> -1 context, -1 Object -1 testClass) -1 { -1 // -1 instance -1 has -1 been -1 spied -1 earlier -1 Mockito.reset(instance); -1 } -1 else -1 { -1 ---- -1 ---field.set(testClass, -1 ---Mockito.spy(instance)); -1 ++++ -1 +++field.set(testClass, -1 +++Mockito.mock(instance.getClass(), -1 +++withSettings() -1 ++++ -1 +++.spiedInstance(instance) -1 ++++ -1 +++.defaultAnswer(Mockito.CALLS_REAL_METHODS) -1 ++++ -1 +++.name(field.getName()))); -1 } -1 } -1 catch -1 (IllegalAccessException -1 e) -1 { -1 throw -1 new -1 MockitoException("Problems -1 initiating -1 spied -1 field -1 " -1 + -1 field.getName(), -1 e); -1 -2
import -1 java.io.Serializable; -1 import -1 java.lang.reflect.Method; -1 ++++import -1 +++java.util.Arrays; -1 import -1 org.mockito.Mockito; -1 import -1 org.mockito.cglib.proxy.MethodInterceptor; -1 @@ -1 -57,7 -1 +58,8 -1 @@ -1 public -1 Object -1 intercept(Object -1 obj, -1 Method -1 method, -1 Object[] -1 args, -1 MethodProxy -1 pr -1 } -1 private -1 String -1 formatMethodCall() -1 { -1 ---- -1 ---return -1 ---invocation.getMethod().getName() -1 ---+ -1 ---"()"; -1 ++++ -1 +++String -1 +++args -1 +++= -1 +++Arrays.toString(invocation.getArguments()); -1 ++++ -1 +++return -1 +++invocation.getMethod().getName() -1 ++++ -1 +++"(" -1 ++++ -1 +++args.substring(1, -1 +++args.length() -1 +++- -1 +++1) -1 ++++ -1 +++")"; -1 } -1 } -1 -2
public -1 String -1 toString(PrintSettings -1 printSettings) -1 { -1 public -1 void -1 captureArgumentsFrom(Invocation -1 i) -1 { -1 int -1 k -1 = -1 0; -1 for -1 (Matcher -1 m -1 : -1 matchers) -1 { -1 ---- -1 ---if -1 ---(m -1 ---instanceof -1 ---CapturesArguments) -1 ---{ -1 ++++ -1 +++if -1 +++(m -1 +++instanceof -1 +++CapturesArguments -1 +++&& -1 +++i.getArguments().length -1 +++> -1 +++k) -1 +++{ -1 ((CapturesArguments) -1 m).captureFrom(i.getArguments()[k]); -1 } -1 k++; -1 -2
import -1 org.hamcrest.Matcher; -1 import -1 org.mockito.exceptions.PrintableInvocation; -1 ++++import -1 +++org.mockito.exceptions.Reporter; -1 import -1 org.mockito.internal.debugging.Location; -1 import -1 org.mockito.internal.invocation.realmethod.RealMethod; -1 import -1 org.mockito.internal.matchers.*; -1 @@ -1 -199,6 -1 +200,9 -1 @@ -1 public -1 int -1 getArgumentsCount() -1 { -1 } -1 public -1 Object -1 callRealMethod() -1 throws -1 Throwable -1 { -1 ++++ -1 +++if -1 +++(this.getMethod().getDeclaringClass().isInterface()) -1 +++{ -1 ++++ -1 +++new -1 +++Reporter().cannotCallRealMethodOnInterface(); -1 ++++ -1 +++} -1 return -1 realMethod.invoke(mock, -1 rawArguments); -1 } -1 -2
public -1 boolean -1 hasSameMethod(Invocation -1 candidate) -1 { -1 Method -1 m1 -1 = -1 invocation.getMethod(); -1 Method -1 m2 -1 = -1 candidate.getMethod(); -1 ++++ -1 +++if -1 +++(m1.getName() -1 +++!= -1 +++null -1 +++&& -1 +++m1.getName().equals(m2.getName())) -1 +++{ -1 /* -1 Avoid -1 unnecessary -1 cloning -1 */ -1 ---- -1 ---return -1 ---m1.equals(m2); -1 ++++ -1 +++Class[] -1 +++params1 -1 +++= -1 +++m1.getParameterTypes(); -1 ++++ -1 +++Class[] -1 +++params2 -1 +++= -1 +++m2.getParameterTypes(); -1 ++++ -1 +++if -1 +++(params1.length -1 +++== -1 +++params2.length) -1 +++{ -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++params1.length; -1 +++i++) -1 +++{ -1 ++++ -1 +++if -1 +++(params1[i] -1 +++!= -1 +++params2[i]) -1 ++++ -1 +++return -1 +++false; -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++true; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ++++ -1 +++return -1 +++false; -1 } -1 public -1 Location -1 getLocation() -1 { -1 -2
public -1 static -1 Collection -1 anyCollection() -1 { -1 * -1 @return -1 <code>null</code>. -1 */ -1 public -1 static -1 <T> -1 T -1 isA(Class<T> -1 clazz) -1 { -1 ---- -1 ---return -1 ---reportMatcher(new -1 ---InstanceOf(clazz)).<T>returnNull(); -1 ++++ -1 +++return -1 +++reportMatcher(new -1 +++InstanceOf(clazz)).<T>returnFor(clazz); -1 } -1 /** -1 @@ -1 -476,7 -1 +476,7 -1 @@ -1 public -1 static -1 short -1 eq(short -1 value) -1 { -1 * -1 @return -1 <code>null</code>. -1 */ -1 public -1 static -1 <T> -1 T -1 eq(T -1 value) -1 { -1 ---- -1 ---return -1 ---reportMatcher(new -1 ---Equals(value)).<T>returnNull(); -1 ++++ -1 +++return -1 +++(T) -1 +++reportMatcher(new -1 +++Equals(value)).<T>returnFor((Class) -1 +++value.getClass()); -1 } -1 /** -1 @@ -1 -513,7 -1 +513,7 -1 @@ -1 public -1 static -1 short -1 eq(short -1 value) -1 { -1 * -1 @return -1 <code>null</code>. -1 */ -1 public -1 static -1 <T> -1 T -1 same(T -1 value) -1 { -1 ---- -1 ---return -1 ---reportMatcher(new -1 ---Same(value)).<T>returnNull(); -1 ++++ -1 +++return -1 +++(T) -1 +++reportMatcher(new -1 +++Same(value)).<T>returnFor((Class) -1 +++value.getClass()); -1 } -1 /** -1 -2
public -1 void -1 misplacedArgumentMatcher(Location -1 location) -1 { -1 )); -1 } -1 ---- -1 ---public -1 ---void -1 ---smartNullPointerException(Location -1 ---location) -1 ---{ -1 ++++ -1 +++public -1 +++void -1 +++smartNullPointerException(Object -1 +++obj, -1 +++Location -1 +++location) -1 +++{ -1 throw -1 new -1 SmartNullPointerException(join( -1 "You -1 have -1 a -1 NullPointerException -1 here:", -1 new -1 Location(), -1 ++++ -1 +++obj, -1 "Because -1 this -1 method -1 was -1 *not* -1 stubbed -1 correctly:", -1 location, -1 "" -1 ------ -1 ---a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java -1 ++++++ -1 +++b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java -1 @@ -1 -53,7 -1 +53,7 -1 @@ -1 public -1 Object -1 intercept(Object -1 obj, -1 Method -1 method, -1 Object[] -1 args, -1 MethodProxy -1 pr -1 return -1 "SmartNull -1 returned -1 by -1 unstubbed -1 " -1 + -1 formatMethodCall() -1 + -1 " -1 method -1 on -1 mock"; -1 } -1 ---- -1 ---new -1 ---Reporter().smartNullPointerException(location); -1 ++++ -1 +++new -1 +++Reporter().smartNullPointerException(obj, -1 +++location); -1 return -1 null; -1 } -1 -2
private -1 boolean -1 safelyMatches(Matcher -1 m, -1 Object -1 arg) -1 { -1 } -1 private -1 boolean -1 toStringEquals(Matcher -1 m, -1 Object -1 arg) -1 { -1 ---- -1 ---return -1 ---StringDescription.toString(m).equals(arg.toString()); -1 ++++ -1 +++return -1 +++StringDescription.toString(m).equals(arg -1 +++== -1 +++null? -1 +++"null" -1 +++: -1 +++arg.toString()); -1 } -1 } -1 -2
public -1 Period -1 normalizedStandard(PeriodType -1 type) -1 { -1 int -1 years -1 = -1 getYears(); -1 int -1 months -1 = -1 getMonths(); -1 if -1 (years -1 != -1 0 -1 || -1 months -1 != -1 0) -1 { -1 ---- -1 ---years -1 ---= -1 ---FieldUtils.safeAdd(years, -1 ---months -1 ---/ -1 ---12); -1 ---- -1 ---months -1 ---= -1 ---months -1 ---% -1 ---12; -1 ---- -1 ---if -1 ---(years -1 ---!= -1 ---0) -1 ---{ -1 ---- -1 ---result -1 ---= -1 ---result.withYears(years); -1 ++++ -1 +++long -1 +++totalMonths -1 +++= -1 +++years -1 +++* -1 +++12L -1 ++++ -1 +++months; -1 ++++ -1 +++if -1 +++(type.isSupported(DurationFieldType.YEARS_TYPE)) -1 +++{ -1 ++++ -1 +++int -1 +++normalizedYears -1 +++= -1 +++FieldUtils.safeToInt(totalMonths -1 +++/ -1 +++12); -1 ++++ -1 +++result -1 +++= -1 +++result.withYears(normalizedYears); -1 ++++ -1 +++totalMonths -1 +++= -1 +++totalMonths -1 +++- -1 +++(normalizedYears -1 +++* -1 +++12); -1 } -1 ---- -1 ---if -1 ---(months -1 ---!= -1 ---0) -1 ---{ -1 ---- -1 ---result -1 ---= -1 ---result.withMonths(months); -1 ++++ -1 +++if -1 +++(type.isSupported(DurationFieldType.MONTHS_TYPE)) -1 +++{ -1 ++++ -1 +++int -1 +++normalizedMonths -1 +++= -1 +++FieldUtils.safeToInt(totalMonths); -1 ++++ -1 +++result -1 +++= -1 +++result.withMonths(normalizedMonths); -1 ++++ -1 +++totalMonths -1 +++= -1 +++totalMonths -1 +++- -1 +++normalizedMonths; -1 ++++ -1 +++} -1 ++++ -1 +++if -1 +++(totalMonths -1 +++!= -1 +++0) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++UnsupportedOperationException("Unable -1 +++to -1 +++normalize -1 +++as -1 +++PeriodType -1 +++is -1 +++missing -1 +++either -1 +++years -1 +++or -1 +++months -1 +++but -1 +++period -1 +++has -1 +++a -1 +++month/year -1 +++amount: -1 +++" -1 ++++ -1 +++toString()); -1 } -1 } -1 return -1 result; -1 -2
public -1 void -1 add(DurationFieldType -1 type, -1 int -1 amount) -1 { -1 if -1 (type -1 == -1 null) -1 { -1 throw -1 new -1 IllegalArgumentException("Field -1 must -1 not -1 be -1 null"); -1 } -1 ++++ -1 +++if -1 +++(amount -1 +++!= -1 +++0) -1 +++{ -1 setMillis(type.getField(getChronology()).add(getMillis(), -1 amount)); -1 ++++ -1 +++} -1 } -1 //----------------------------------------------------------------------- -1 @@ -1 -657,7 -1 +659,9 -1 @@ -1 public -1 void -1 setYear(final -1 int -1 year) -1 { -1 * -1 @throws -1 IllegalArgumentException -1 if -1 the -1 value -1 is -1 invalid -1 */ -1 public -1 void -1 addYears(final -1 int -1 years) -1 { -1 ++++ -1 +++if -1 +++(years -1 +++!= -1 +++0) -1 +++{ -1 setMillis(getChronology().years().add(getMillis(), -1 years)); -1 ++++ -1 +++} -1 } -1 //----------------------------------------------------------------------- -1 @@ -1 -678,7 -1 +682,9 -1 @@ -1 public -1 void -1 setWeekyear(final -1 int -1 weekyear) -1 { -1 * -1 @throws -1 IllegalArgumentException -1 if -1 the -1 value -1 is -1 invalid -1 */ -1 public -1 void -1 addWeekyears(final -1 int -1 weekyears) -1 { -1 ++++ -1 +++if -1 +++(weekyears -1 +++!= -1 +++0) -1 +++{ -1 setMillis(getChronology().weekyears().add(getMillis(), -1 weekyears)); -1 ++++ -1 +++} -1 } -1 //----------------------------------------------------------------------- -1 @@ -1 -699,7 -1 +705,9 -1 @@ -1 public -1 void -1 setMonthOfYear(final -1 int -1 monthOfYear) -1 { -1 * -1 @throws -1 IllegalArgumentException -1 if -1 the -1 value -1 is -1 invalid -1 */ -1 public -1 void -1 addMonths(final -1 int -1 months) -1 { -1 ++++ -1 +++if -1 +++(months -1 +++!= -1 +++0) -1 +++{ -1 setMillis(getChronology().months().add(getMillis(), -1 months)); -1 ++++ -1 +++} -1 } -1 //----------------------------------------------------------------------- -1 @@ -1 -720,7 -1 +728,9 -1 @@ -1 public -1 void -1 setWeekOfWeekyear(final -1 int -1 weekOfWeekyear) -1 { -1 * -1 @throws -1 IllegalArgumentException -1 if -1 the -1 value -1 is -1 invalid -1 */ -1 public -1 void -1 addWeeks(final -1 int -1 weeks) -1 { -1 ++++ -1 +++if -1 +++(weeks -1 +++!= -1 +++0) -1 +++{ -1 setMillis(getChronology().weeks().add(getMillis(), -1 weeks)); -1 ++++ -1 +++} -1 } -1 //----------------------------------------------------------------------- -1 @@ -1 -761,7 -1 +771,9 -1 @@ -1 public -1 void -1 setDayOfWeek(final -1 int -1 dayOfWeek) -1 { -1 * -1 @throws -1 IllegalArgumentException -1 if -1 the -1 value -1 is -1 invalid -1 */ -1 public -1 void -1 addDays(final -1 int -1 days) -1 { -1 ++++ -1 +++if -1 +++(days -1 +++!= -1 +++0) -1 +++{ -1 setMillis(getChronology().days().add(getMillis(), -1 days)); -1 ++++ -1 +++} -1 } -1 //----------------------------------------------------------------------- -1 @@ -1 -782,7 -1 +794,9 -1 @@ -1 public -1 void -1 setHourOfDay(final -1 int -1 hourOfDay) -1 { -1 * -1 @throws -1 IllegalArgumentException -1 if -1 the -1 value -1 is -1 invalid -1 */ -1 public -1 void -1 addHours(final -1 int -1 hours) -1 { -1 ++++ -1 +++if -1 +++(hours -1 +++!= -1 +++0) -1 +++{ -1 setMillis(getChronology().hours().add(getMillis(), -1 hours)); -1 ++++ -1 +++} -1 } -1 //----------------------------------------------------------------------- -1 @@ -1 -813,7 -1 +827,9 -1 @@ -1 public -1 void -1 setMinuteOfHour(final -1 int -1 minuteOfHour) -1 { -1 * -1 @throws -1 IllegalArgumentException -1 if -1 the -1 value -1 is -1 invalid -1 */ -1 public -1 void -1 addMinutes(final -1 int -1 minutes) -1 { -1 ++++ -1 +++if -1 +++(minutes -1 +++!= -1 +++0) -1 +++{ -1 setMillis(getChronology().minutes().add(getMillis(), -1 minutes)); -1 ++++ -1 +++} -1 } -1 //----------------------------------------------------------------------- -1 @@ -1 -844,7 -1 +860,9 -1 @@ -1 public -1 void -1 setSecondOfMinute(final -1 int -1 secondOfMinute) -1 { -1 * -1 @throws -1 IllegalArgumentException -1 if -1 the -1 value -1 is -1 invalid -1 */ -1 public -1 void -1 addSeconds(final -1 int -1 seconds) -1 { -1 ++++ -1 +++if -1 +++(seconds -1 +++!= -1 +++0) -1 +++{ -1 setMillis(getChronology().seconds().add(getMillis(), -1 seconds)); -1 ++++ -1 +++} -1 } -1 //----------------------------------------------------------------------- -1 @@ -1 -877,7 -1 +895,9 -1 @@ -1 public -1 void -1 setMillisOfSecond(final -1 int -1 millisOfSecond) -1 { -1 * -1 @throws -1 IllegalArgumentException -1 if -1 the -1 value -1 is -1 invalid -1 */ -1 public -1 void -1 addMillis(final -1 int -1 millis) -1 { -1 ++++ -1 +++if -1 +++(millis -1 +++!= -1 +++0) -1 +++{ -1 setMillis(getChronology().millis().add(getMillis(), -1 millis)); -1 ++++ -1 +++} -1 } -1 //----------------------------------------------------------------------- -1 -2
public -1 Partial(DateTimeFieldType[] -1 types, -1 int[] -1 values, -1 Chronology -1 chronology) -1 { -1 DateTimeFieldType -1 loopType -1 = -1 types[i]; -1 DurationField -1 loopUnitField -1 = -1 loopType.getDurationType().getField(iChronology); -1 if -1 (i -1 > -1 0) -1 { -1 ++++ -1 +++if -1 +++(loopUnitField.isSupported() -1 +++== -1 +++false) -1 +++{ -1 ++++ -1 +++if -1 +++(lastUnitField.isSupported()) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Types -1 +++array -1 +++must -1 +++be -1 +++in -1 +++order -1 +++largest-smallest: -1 +++" -1 ++++ -1 ++++ -1 +++types[i -1 +++- -1 +++1].getName() -1 ++++ -1 +++" -1 +++< -1 +++" -1 ++++ -1 +++loopType.getName()); -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Types -1 +++array -1 +++must -1 +++not -1 +++contain -1 +++duplicate -1 +++unsupported: -1 +++" -1 ++++ -1 ++++ -1 +++types[i -1 +++- -1 +++1].getName() -1 ++++ -1 +++" -1 +++and -1 +++" -1 ++++ -1 +++loopType.getName()); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 int -1 compare -1 = -1 lastUnitField.compareTo(loopUnitField); -1 if -1 (compare -1 < -1 0) -1 { -1 throw -1 new -1 IllegalArgumentException("Types -1 array -1 must -1 be -1 in -1 order -1 largest-smallest: -1 " -1 + -1 types[i -1 - -1 1].getName() -1 + -1 " -1 < -1 " -1 + -1 loopType.getName()); -1 ---- -1 ---} -1 ---else -1 ---if -1 ---(compare -1 ---== -1 ---0) -1 ---{ -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(compare -1 +++== -1 +++0 -1 +++&& -1 +++lastUnitField.equals(loopUnitField)) -1 +++{ -1 if -1 (types[i -1 - -1 1].getRangeDurationType() -1 == -1 null) -1 { -1 if -1 (loopType.getRangeDurationType() -1 == -1 null) -1 { -1 throw -1 new -1 IllegalArgumentException("Types -1 array -1 must -1 not -1 contain -1 duplicate: -1 " -1 + -1 ------ -1 ---a/src/main/java/org/joda/time/field/UnsupportedDurationField.java -1 ++++++ -1 +++b/src/main/java/org/joda/time/field/UnsupportedDurationField.java -1 @@ -1 -224,9 -1 +224,6 -1 @@ -1 public -1 long -1 getUnitMillis() -1 { -1 * -1 @return -1 zero -1 always -1 */ -1 public -1 int -1 compareTo(DurationField -1 durationField) -1 { -1 ---- -1 ---if -1 ---(durationField.isSupported()) -1 ---{ -1 ---- -1 ---return -1 ---1; -1 ---- -1 ---} -1 return -1 0; -1 } -1 -2
public -1 Partial -1 with(DateTimeFieldType -1 fieldType, -1 int -1 value) -1 { -1 System.arraycopy(iValues, -1 i, -1 newValues, -1 i -1 + -1 1, -1 newValues.length -1 - -1 i -1 - -1 1); -1 // -1 use -1 public -1 constructor -1 to -1 ensure -1 full -1 validation -1 // -1 this -1 isn't -1 overly -1 efficient, -1 but -1 is -1 safe -1 ---- -1 ---Partial -1 ---newPartial -1 ---= -1 ---new -1 ---Partial(iChronology, -1 ---newTypes, -1 ---newValues); -1 ++++ -1 +++Partial -1 +++newPartial -1 +++= -1 +++new -1 +++Partial(newTypes, -1 +++newValues, -1 +++iChronology); -1 iChronology.validate(newPartial, -1 newValues); -1 return -1 newPartial; -1 } -1 -2
public -1 void -1 validate(Answer<?> -1 answer, -1 Invocation -1 invocation) -1 { -1 validateDoNothing((DoesNothing) -1 answer, -1 invocation); -1 } -1 ++++ -1 +++if -1 +++(answer -1 +++instanceof -1 +++CallsRealMethods) -1 +++{ -1 ++++ -1 +++validateMockingConcreteClass((CallsRealMethods) -1 +++answer, -1 +++invocation); -1 ++++ -1 +++} -1 } -1 ++++ -1 +++private -1 +++void -1 +++validateMockingConcreteClass(CallsRealMethods -1 +++answer, -1 +++Invocation -1 +++invocation) -1 +++{ -1 ++++ -1 +++if -1 +++(invocation.getMethod().getDeclaringClass().isInterface()) -1 +++{ -1 ++++ -1 +++reporter.cannotCallRealMethodOnInterface(); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 private -1 void -1 validateDoNothing(DoesNothing -1 answer, -1 Invocation -1 invocation) -1 { -1 if -1 (!invocation.isVoid()) -1 { -1 -2
public -1 Partial(DateTimeFieldType[] -1 types, -1 int[] -1 values, -1 Chronology -1 chronology) -1 { -1 DurationField -1 loopUnitField -1 = -1 loopType.getDurationType().getField(iChronology); -1 if -1 (i -1 > -1 0) -1 { -1 int -1 compare -1 = -1 lastUnitField.compareTo(loopUnitField); -1 ---- -1 ---if -1 ---(compare -1 ---< -1 ---0 -1 ---|| -1 ---(compare -1 ---!= -1 ---0 -1 ---&& -1 ---loopUnitField.isSupported() -1 ---== -1 ---false)) -1 ---{ -1 ++++ -1 +++if -1 +++(compare -1 +++< -1 +++0) -1 +++{ -1 throw -1 new -1 IllegalArgumentException("Types -1 array -1 must -1 be -1 in -1 order -1 largest-smallest: -1 " -1 + -1 types[i -1 - -1 1].getName() -1 + -1 " -1 < -1 " -1 + -1 loopType.getName()); -1 } -1 else -1 if -1 (compare -1 == -1 0) -1 { -1 @@ -1 -446,6 -1 +446,9 -1 @@ -1 public -1 Partial -1 with(DateTimeFieldType -1 fieldType, -1 int -1 value) -1 { -1 if -1 (compare -1 > -1 0) -1 { -1 break; -1 } -1 else -1 if -1 (compare -1 == -1 0) -1 { -1 ++++ -1 +++if -1 +++(fieldType.getRangeDurationType() -1 +++== -1 +++null) -1 +++{ -1 ++++ -1 +++break; -1 ++++ -1 +++} -1 DurationField -1 rangeField -1 = -1 fieldType.getRangeDurationType().getField(iChronology); -1 DurationField -1 loopRangeField -1 = -1 loopType.getRangeDurationType().getField(iChronology); -1 if -1 (rangeField.compareTo(loopRangeField) -1 > -1 0) -1 { -1 ------ -1 ---a/src/main/java/org/joda/time/field/UnsupportedDurationField.java -1 ++++++ -1 +++b/src/main/java/org/joda/time/field/UnsupportedDurationField.java -1 @@ -1 -224,6 -1 +224,9 -1 @@ -1 public -1 long -1 getUnitMillis() -1 { -1 * -1 @return -1 zero -1 always -1 */ -1 public -1 int -1 compareTo(DurationField -1 durationField) -1 { -1 ++++ -1 +++if -1 +++(durationField.isSupported()) -1 +++{ -1 ++++ -1 +++return -1 +++1; -1 ++++ -1 +++} -1 return -1 0; -1 } -1 -2
public -1 static -1 DateTimeZone -1 forOffsetHoursMinutes(int -1 hoursOffset, -1 int -1 minutesOff -1 if -1 (hoursOffset -1 < -1 -23 -1 || -1 hoursOffset -1 > -1 23) -1 { -1 throw -1 new -1 IllegalArgumentException("Hours -1 out -1 of -1 range: -1 " -1 + -1 hoursOffset); -1 } -1 ---- -1 ---if -1 ---(minutesOffset -1 ---< -1 ---0 -1 ---|| -1 ---minutesOffset -1 ---> -1 ---59) -1 ---{ -1 ++++ -1 +++if -1 +++(minutesOffset -1 +++< -1 +++-59 -1 +++|| -1 +++minutesOffset -1 +++> -1 +++59) -1 +++{ -1 throw -1 new -1 IllegalArgumentException("Minutes -1 out -1 of -1 range: -1 " -1 + -1 minutesOffset); -1 } -1 ++++ -1 +++if -1 +++(hoursOffset -1 +++> -1 +++0 -1 +++&& -1 +++minutesOffset -1 +++< -1 +++0) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Positive -1 +++hours -1 +++must -1 +++not -1 +++have -1 +++negative -1 +++minutes: -1 +++" -1 ++++ -1 +++minutesOffset); -1 ++++ -1 +++} -1 int -1 offset -1 = -1 0; -1 try -1 { -1 int -1 hoursInMinutes -1 = -1 hoursOffset -1 * -1 60; -1 if -1 (hoursInMinutes -1 < -1 0) -1 { -1 ---- -1 ---minutesOffset -1 ---= -1 ---hoursInMinutes -1 ---- -1 ---minutesOffset; -1 ++++ -1 +++minutesOffset -1 +++= -1 +++hoursInMinutes -1 +++- -1 +++Math.abs(minutesOffset); -1 } -1 else -1 { -1 minutesOffset -1 = -1 hoursInMinutes -1 + -1 minutesOffset; -1 } -1 -2
public -1 static -1 synchronized -1 GJChronology -1 getInstance( -1 cutoverInstant -1 = -1 DEFAULT_CUTOVER; -1 } -1 else -1 { -1 cutoverInstant -1 = -1 gregorianCutover.toInstant(); -1 ++++ -1 +++LocalDate -1 +++cutoverDate -1 +++= -1 +++new -1 +++LocalDate(cutoverInstant.getMillis(), -1 +++GregorianChronology.getInstance(zone)); -1 ++++ -1 +++if -1 +++(cutoverDate.getYear() -1 +++<= -1 +++0) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Cutover -1 +++too -1 +++early. -1 +++Must -1 +++be -1 +++on -1 +++or -1 +++after -1 +++0001-01-01."); -1 ++++ -1 +++} -1 } -1 GJChronology -1 chrono; -1 @@ -1 -976,6 -1 +980,17 -1 @@ -1 public -1 long -1 add(long -1 instant, -1 int -1 value) -1 { -1 if -1 (instant -1 < -1 iCutover) -1 { -1 // -1 Only -1 adjust -1 if -1 gap -1 fully -1 crossed. -1 if -1 (instant -1 + -1 iGapDuration -1 < -1 iCutover) -1 { -1 ++++ -1 +++if -1 +++(iConvertByWeekyear) -1 +++{ -1 ++++ -1 +++int -1 +++wyear -1 +++= -1 +++iGregorianChronology.weekyear().get(instant); -1 ++++ -1 +++if -1 +++(wyear -1 +++<= -1 +++0) -1 +++{ -1 ++++ -1 +++instant -1 +++= -1 +++iGregorianChronology.weekyear().add(instant, -1 +++-1); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++int -1 +++year -1 +++= -1 +++iGregorianChronology.year().get(instant); -1 ++++ -1 +++if -1 +++(year -1 +++<= -1 +++0) -1 +++{ -1 ++++ -1 +++instant -1 +++= -1 +++iGregorianChronology.year().add(instant, -1 +++-1); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 instant -1 = -1 gregorianToJulian(instant); -1 } -1 } -1 @@ -1 -998,6 -1 +1013,17 -1 @@ -1 public -1 long -1 add(long -1 instant, -1 long -1 value) -1 { -1 if -1 (instant -1 < -1 iCutover) -1 { -1 // -1 Only -1 adjust -1 if -1 gap -1 fully -1 crossed. -1 if -1 (instant -1 + -1 iGapDuration -1 < -1 iCutover) -1 { -1 ++++ -1 +++if -1 +++(iConvertByWeekyear) -1 +++{ -1 ++++ -1 +++int -1 +++wyear -1 +++= -1 +++iGregorianChronology.weekyear().get(instant); -1 ++++ -1 +++if -1 +++(wyear -1 +++<= -1 +++0) -1 +++{ -1 ++++ -1 +++instant -1 +++= -1 +++iGregorianChronology.weekyear().add(instant, -1 +++-1); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 +++else -1 +++{ -1 ++++ -1 +++int -1 +++year -1 +++= -1 +++iGregorianChronology.year().get(instant); -1 ++++ -1 +++if -1 +++(year -1 +++<= -1 +++0) -1 +++{ -1 ++++ -1 +++instant -1 +++= -1 +++iGregorianChronology.year().add(instant, -1 +++-1); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 instant -1 = -1 gregorianToJulian(instant); -1 } -1 } -1 -2
public -1 int -1 parseInto(ReadWritableInstant -1 instant, -1 String -1 text, -1 int -1 position) -1 { -1 long -1 instantMillis -1 = -1 instant.getMillis(); -1 Chronology -1 chrono -1 = -1 instant.getChronology(); -1 ++++ -1 +++int -1 +++defaultYear -1 +++= -1 +++DateTimeUtils.getChronology(chrono).year().get(instantMillis); -1 long -1 instantLocal -1 = -1 instantMillis -1 + -1 chrono.getZone().getOffset(instantMillis); -1 chrono -1 = -1 selectChronology(chrono); -1 ---- -1 ---int -1 ---defaultYear -1 ---= -1 ---chrono.year().get(instantLocal); -1 DateTimeParserBucket -1 bucket -1 = -1 new -1 DateTimeParserBucket( -1 instantLocal, -1 chrono, -1 iLocale, -1 iPivotYear, -1 defaultYear); -1 -2
public -1 static -1 DateTimeZone -1 forOffsetHoursMinutes(int -1 hoursOffset, -1 int -1 minutesOff -1 if -1 (hoursOffset -1 == -1 0 -1 && -1 minutesOffset -1 == -1 0) -1 { -1 return -1 DateTimeZone.UTC; -1 } -1 ++++ -1 +++if -1 +++(hoursOffset -1 +++< -1 +++-23 -1 +++|| -1 +++hoursOffset -1 +++> -1 +++23) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Hours -1 +++out -1 +++of -1 +++range: -1 +++" -1 ++++ -1 +++hoursOffset); -1 ++++ -1 +++} -1 if -1 (minutesOffset -1 < -1 0 -1 || -1 minutesOffset -1 > -1 59) -1 { -1 throw -1 new -1 IllegalArgumentException("Minutes -1 out -1 of -1 range: -1 " -1 + -1 minutesOffset); -1 } -1 int -1 offset -1 = -1 0; -1 try -1 { -1 ---- -1 ---int -1 ---hoursInMinutes -1 ---= -1 ---FieldUtils.safeMultiply(hoursOffset, -1 ---60); -1 ++++ -1 +++int -1 +++hoursInMinutes -1 +++= -1 +++hoursOffset -1 +++* -1 +++60; -1 if -1 (hoursInMinutes -1 < -1 0) -1 { -1 ---- -1 ---minutesOffset -1 ---= -1 ---FieldUtils.safeAdd(hoursInMinutes, -1 ----minutesOffset); -1 ++++ -1 +++minutesOffset -1 +++= -1 +++hoursInMinutes -1 +++- -1 +++minutesOffset; -1 } -1 else -1 { -1 ---- -1 ---minutesOffset -1 ---= -1 ---FieldUtils.safeAdd(hoursInMinutes, -1 ---minutesOffset); -1 ++++ -1 +++minutesOffset -1 +++= -1 +++hoursInMinutes -1 ++++ -1 +++minutesOffset; -1 } -1 offset -1 = -1 FieldUtils.safeMultiply(minutesOffset, -1 DateTimeConstants.MILLIS_PER_MINUTE); -1 } -1 catch -1 (ArithmeticException -1 ex) -1 { -1 @@ -1 -280,6 -1 +283,9 -1 @@ -1 public -1 static -1 DateTimeZone -1 forOffsetHoursMinutes(int -1 hoursOffset, -1 int -1 minutesOff -1 * -1 @return -1 the -1 DateTimeZone -1 object -1 for -1 the -1 offset -1 */ -1 public -1 static -1 DateTimeZone -1 forOffsetMillis(int -1 millisOffset) -1 { -1 ++++ -1 +++if -1 +++(millisOffset -1 +++< -1 +++-MAX_MILLIS -1 +++|| -1 +++millisOffset -1 +++> -1 +++MAX_MILLIS) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++IllegalArgumentException("Millis -1 +++out -1 +++of -1 +++range: -1 +++" -1 ++++ -1 +++millisOffset); -1 ++++ -1 +++} -1 String -1 id -1 = -1 printOffset(millisOffset); -1 return -1 fixedOffsetZone(id, -1 millisOffset); -1 } -1 -2
/** -1 Serialization -1 version. -1 */ -1 private -1 static -1 final -1 long -1 serialVersionUID -1 = -1 9386874258972L; -1 /** -1 The -1 start -1 of -1 1972. -1 */ -1 ++++ -1 +++private -1 +++static -1 +++final -1 +++long -1 +++START_1972 -1 +++= -1 +++2L -1 +++* -1 +++365L -1 +++* -1 +++86400L -1 +++* -1 +++1000L; -1 /** -1 The -1 period -1 in -1 the -1 units -1 of -1 this -1 period. -1 */ -1 private -1 volatile -1 int -1 iPeriod; -1 @@ -1 -101,7 -1 +102,7 -1 @@ -1 protected -1 static -1 int -1 between(ReadablePartial -1 start, -1 ReadablePartial -1 end, -1 Readabl -1 throw -1 new -1 IllegalArgumentException("ReadablePartial -1 objects -1 must -1 be -1 contiguous"); -1 } -1 Chronology -1 chrono -1 = -1 DateTimeUtils.getChronology(start.getChronology()).withUTC(); -1 ---- -1 ---int[] -1 ---values -1 ---= -1 ---chrono.get(zeroInstance, -1 ---chrono.set(start, -1 ---0L), -1 ---chrono.set(end, -1 ---0L)); -1 ++++ -1 +++int[] -1 +++values -1 +++= -1 +++chrono.get(zeroInstance, -1 +++chrono.set(start, -1 +++START_1972), -1 +++chrono.set(end, -1 +++START_1972)); -1 return -1 values[0]; -1 } -1 -2
public -1 static -1 LocalDate -1 fromCalendarFields(Calendar -1 calendar) -1 { -1 if -1 (calendar -1 == -1 null) -1 { -1 throw -1 new -1 IllegalArgumentException("The -1 calendar -1 must -1 not -1 be -1 null"); -1 } -1 ++++ -1 +++int -1 +++era -1 +++= -1 +++calendar.get(Calendar.ERA); -1 int -1 yearOfEra -1 = -1 calendar.get(Calendar.YEAR); -1 return -1 new -1 LocalDate( -1 ---- -1 ---yearOfEra, -1 ++++ -1 +++(era -1 +++== -1 +++GregorianCalendar.AD -1 +++? -1 +++yearOfEra -1 +++: -1 +++1 -1 +++- -1 +++yearOfEra), -1 calendar.get(Calendar.MONTH) -1 + -1 1, -1 calendar.get(Calendar.DAY_OF_MONTH) -1 ); -1 @@ -1 -240,7 -1 +241,12 -1 @@ -1 public -1 static -1 LocalDate -1 fromDateFields(Date -1 date) -1 { -1 if -1 (date -1 == -1 null) -1 { -1 throw -1 new -1 IllegalArgumentException("The -1 date -1 must -1 not -1 be -1 null"); -1 } -1 ++++ -1 +++if -1 +++(date.getTime() -1 +++< -1 +++0) -1 +++{ -1 // -1 handle -1 years -1 in -1 era -1 BC -1 ++++ -1 +++GregorianCalendar -1 +++cal -1 +++= -1 +++new -1 +++GregorianCalendar(); -1 ++++ -1 +++cal.setTime(date); -1 ++++ -1 +++return -1 +++fromCalendarFields(cal); -1 ++++ -1 +++} -1 return -1 new -1 LocalDate( -1 date.getYear() -1 + -1 1900, -1 date.getMonth() -1 + -1 1, -1 ------ -1 ---a/src/main/java/org/joda/time/LocalDateTime.java -1 ++++++ -1 +++b/src/main/java/org/joda/time/LocalDateTime.java -1 @@ -1 -196,9 -1 +196,10 -1 @@ -1 public -1 static -1 LocalDateTime -1 fromCalendarFields(Calendar -1 calendar) -1 { -1 if -1 (calendar -1 == -1 null) -1 { -1 throw -1 new -1 IllegalArgumentException("The -1 calendar -1 must -1 not -1 be -1 null"); -1 } -1 ++++ -1 +++int -1 +++era -1 +++= -1 +++calendar.get(Calendar.ERA); -1 int -1 yearOfEra -1 = -1 calendar.get(Calendar.YEAR); -1 return -1 new -1 LocalDateTime( -1 ---- -1 ---yearOfEra, -1 ++++ -1 +++(era -1 +++== -1 +++GregorianCalendar.AD -1 +++? -1 +++yearOfEra -1 +++: -1 +++1 -1 +++- -1 +++yearOfEra), -1 calendar.get(Calendar.MONTH) -1 + -1 1, -1 calendar.get(Calendar.DAY_OF_MONTH), -1 calendar.get(Calendar.HOUR_OF_DAY), -1 @@ -1 -233,7 -1 +234,12 -1 @@ -1 public -1 static -1 LocalDateTime -1 fromDateFields(Date -1 date) -1 { -1 if -1 (date -1 == -1 null) -1 { -1 throw -1 new -1 IllegalArgumentException("The -1 date -1 must -1 not -1 be -1 null"); -1 } -1 ++++ -1 +++if -1 +++(date.getTime() -1 +++< -1 +++0) -1 +++{ -1 // -1 handle -1 years -1 in -1 era -1 BC -1 ++++ -1 +++GregorianCalendar -1 +++cal -1 +++= -1 +++new -1 +++GregorianCalendar(); -1 ++++ -1 +++cal.setTime(date); -1 ++++ -1 +++return -1 +++fromCalendarFields(cal); -1 ++++ -1 +++} -1 return -1 new -1 LocalDateTime( -1 date.getYear() -1 + -1 1900, -1 date.getMonth() -1 + -1 1, -1 -2
static -1 Chronology -1 cLenientISO; -1 ---- -1 ---static -1 ---ThreadLocal<Boolean> -1 ---cVerbose -1 ---= -1 ---new -1 ---ThreadLocal<Boolean>(); -1 ---- -1 ---static -1 ---{ -1 ---- -1 ---cVerbose.set(Boolean.FALSE); -1 ---- -1 ---} -1 ++++ -1 +++static -1 +++ThreadLocal<Boolean> -1 +++cVerbose -1 +++= -1 +++new -1 +++ThreadLocal<Boolean>() -1 +++{ -1 ++++ -1 +++protected -1 +++Boolean -1 +++initialValue() -1 +++{ -1 ++++ -1 +++return -1 +++Boolean.FALSE; -1 ++++ -1 +++} -1 ++++ -1 +++}; -1 /** -1 * -1 Gets -1 a -1 flag -1 indicating -1 that -1 verbose -1 logging -1 is -1 required. -1 -2
public -1 long -1 add(long -1 instant, -1 long -1 months) -1 { -1 if -1 (valueToAdd -1 == -1 0) -1 { -1 return -1 values; -1 } -1 ++++ -1 +++if -1 +++(partial.size() -1 +++> -1 +++0 -1 +++&& -1 +++partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) -1 +++&& -1 +++fieldIndex -1 +++== -1 +++0) -1 +++{ -1 // -1 month -1 is -1 largest -1 field -1 and -1 being -1 added -1 to, -1 such -1 as -1 month-day -1 ++++ -1 +++int -1 +++curMonth0 -1 +++= -1 +++partial.getValue(0) -1 +++- -1 +++1; -1 ++++ -1 +++int -1 +++newMonth -1 +++= -1 +++((curMonth0 -1 ++++ -1 +++(valueToAdd -1 +++% -1 +++12) -1 ++++ -1 +++12) -1 +++% -1 +++12) -1 ++++ -1 +++1; -1 ++++ -1 +++return -1 +++set(partial, -1 +++0, -1 +++values, -1 +++newMonth); -1 ++++ -1 +++} -1 if -1 (DateTimeUtils.isContiguous(partial)) -1 { -1 long -1 instant -1 = -1 0L; -1 for -1 (int -1 i -1 = -1 0, -1 isize -1 = -1 partial.size(); -1 i -1 < -1 isize; -1 i++) -1 { -1 -2
public -1 int -1 calculatePrintedLength(ReadablePeriod -1 period, -1 Locale -1 locale) -1 { -1 if -1 (iFieldType -1 >= -1 SECONDS_MILLIS) -1 { -1 // -1 valueLong -1 contains -1 the -1 seconds -1 and -1 millis -1 fields -1 // -1 the -1 minimum -1 output -1 is -1 0.000, -1 which -1 is -1 4 -1 or -1 5 -1 digits -1 with -1 a -1 negative -1 ---- -1 ---sum -1 ---= -1 ---Math.max(sum, -1 ---4); -1 ++++ -1 +++sum -1 +++= -1 +++(valueLong -1 +++< -1 +++0 -1 +++? -1 +++Math.max(sum, -1 +++5) -1 +++: -1 +++Math.max(sum, -1 +++4)); -1 // -1 plus -1 one -1 for -1 the -1 decimal -1 point -1 sum++; -1 if -1 (iFieldType -1 == -1 SECONDS_OPTIONAL_MILLIS -1 && -1 @@ -1 -1130,6 -1 +1130,7 -1 @@ -1 public -1 void -1 printTo(StringBuffer -1 buf, -1 ReadablePeriod -1 period, -1 Locale -1 locale) -1 { -1 if -1 (iPrefix -1 != -1 null) -1 { -1 iPrefix.printTo(buf, -1 value); -1 } -1 ++++ -1 +++int -1 +++bufLen -1 +++= -1 +++buf.length(); -1 int -1 minDigits -1 = -1 iMinPrintedDigits; -1 if -1 (minDigits -1 <= -1 1) -1 { -1 FormatUtils.appendUnpaddedInteger(buf, -1 value); -1 @@ -1 -1139,6 -1 +1140,9 -1 @@ -1 public -1 void -1 printTo(StringBuffer -1 buf, -1 ReadablePeriod -1 period, -1 Locale -1 locale) -1 { -1 if -1 (iFieldType -1 >= -1 SECONDS_MILLIS) -1 { -1 int -1 dp -1 = -1 (int) -1 (Math.abs(valueLong) -1 % -1 DateTimeConstants.MILLIS_PER_SECOND); -1 if -1 (iFieldType -1 == -1 SECONDS_MILLIS -1 || -1 dp -1 > -1 0) -1 { -1 ++++ -1 +++if -1 +++(valueLong -1 +++< -1 +++0 -1 +++&& -1 +++valueLong -1 +++> -1 +++-DateTimeConstants.MILLIS_PER_SECOND) -1 +++{ -1 ++++ -1 +++buf.insert(bufLen, -1 +++'-'); -1 ++++ -1 +++} -1 buf.append('.'); -1 FormatUtils.appendPaddedInteger(buf, -1 dp, -1 3); -1 } -1 -2
public -1 static -1 int -1 safeMultiply(int -1 val1, -1 int -1 val2) -1 { -1 public -1 static -1 long -1 safeMultiply(long -1 val1, -1 int -1 val2) -1 { -1 switch -1 (val2) -1 { -1 case -1 -1: -1 ++++ -1 +++if -1 +++(val1 -1 +++== -1 +++Long.MIN_VALUE) -1 +++{ -1 ++++ -1 +++throw -1 +++new -1 +++ArithmeticException("Multiplication -1 +++overflows -1 +++a -1 +++long: -1 +++" -1 ++++ -1 +++val1 -1 ++++ -1 +++" -1 +++* -1 +++" -1 ++++ -1 +++val2); -1 ++++ -1 +++} -1 return -1 -val1; -1 case -1 0: -1 return -1 0L; -1 -2
public -1 long -1 adjustOffset(long -1 instant, -1 boolean -1 earlierOrLater) -1 { -1 // -1 a -1 bit -1 messy, -1 but -1 will -1 work -1 in -1 all -1 non-pathological -1 cases -1 // -1 evaluate -1 3 -1 hours -1 before -1 and -1 after -1 to -1 work -1 out -1 if -1 anything -1 is -1 happening -1 ---- -1 ---long -1 ---instantBefore -1 ---= -1 ---convertUTCToLocal(instant -1 ---- -1 ---3 -1 ---* -1 ---DateTimeConstants.MILLIS_PER_HOUR); -1 ---- -1 ---long -1 ---instantAfter -1 ---= -1 ---convertUTCToLocal(instant -1 ---+ -1 ---3 -1 ---* -1 ---DateTimeConstants.MILLIS_PER_HOUR); -1 ---- -1 ---if -1 ---(instantBefore -1 ---== -1 ---instantAfter) -1 ---{ -1 ++++ -1 +++long -1 +++instantBefore -1 +++= -1 +++instant -1 +++- -1 +++3 -1 +++* -1 +++DateTimeConstants.MILLIS_PER_HOUR; -1 ++++ -1 +++long -1 +++instantAfter -1 +++= -1 +++instant -1 ++++ -1 +++3 -1 +++* -1 +++DateTimeConstants.MILLIS_PER_HOUR; -1 ++++ -1 +++long -1 +++offsetBefore -1 +++= -1 +++getOffset(instantBefore); -1 ++++ -1 +++long -1 +++offsetAfter -1 +++= -1 +++getOffset(instantAfter); -1 ++++ -1 +++if -1 +++(offsetBefore -1 +++<= -1 +++offsetAfter) -1 +++{ -1 return -1 instant; -1 // -1 not -1 an -1 overlap -1 (less -1 than -1 is -1 a -1 gap, -1 equal -1 is -1 normal -1 case) -1 } -1 // -1 work -1 out -1 range -1 of -1 instants -1 that -1 have -1 duplicate -1 local -1 times -1 ---- -1 ---long -1 ---local -1 ---= -1 ---convertUTCToLocal(instant); -1 ---- -1 ---return -1 ---convertLocalToUTC(local, -1 ---false, -1 ---earlierOrLater -1 ---? -1 ---instantAfter -1 ---: -1 ---instantBefore); -1 ++++ -1 +++long -1 +++diff -1 +++= -1 +++offsetBefore -1 +++- -1 +++offsetAfter; -1 ++++ -1 +++long -1 +++transition -1 +++= -1 +++nextTransition(instantBefore); -1 ++++ -1 +++long -1 +++overlapStart -1 +++= -1 +++transition -1 +++- -1 +++diff; -1 ++++ -1 +++long -1 +++overlapEnd -1 +++= -1 +++transition -1 ++++ -1 +++diff; -1 ++++ -1 +++if -1 +++(instant -1 +++< -1 +++overlapStart -1 +++|| -1 +++instant -1 +++>= -1 +++overlapEnd) -1 +++{ -1 ++++ -1 +++return -1 +++instant; -1 +++// -1 +++not -1 +++an -1 +++overlap -1 ++++ -1 +++} -1 // -1 calculate -1 result -1 ++++ -1 +++long -1 +++afterStart -1 +++= -1 +++instant -1 +++- -1 +++overlapStart; -1 ++++ -1 +++if -1 +++(afterStart -1 +++>= -1 +++diff) -1 +++{ -1 // -1 currently -1 in -1 later -1 offset -1 ++++ -1 +++return -1 +++earlierOrLater -1 +++? -1 +++instant -1 +++: -1 +++instant -1 +++- -1 +++diff; -1 ++++ -1 +++} -1 +++else -1 +++{ -1 // -1 currently -1 in -1 earlier -1 offset -1 ++++ -1 +++return -1 +++earlierOrLater -1 +++? -1 +++instant -1 ++++ -1 +++diff -1 +++: -1 +++instant; -1 ++++ -1 +++} -1 } -1 // -1 System.out.println(new -1 DateTime(transitionStart, -1 DateTimeZone.UTC) -1 + -1 " -1 " -1 + -1 new -1 DateTime(transitionStart, -1 this)); -1 -2
public -1 int -1 parseInto(ReadWritableInstant -1 instant, -1 String -1 text, -1 int -1 position) -1 { -1 chrono -1 = -1 selectChronology(chrono); -1 DateTimeParserBucket -1 bucket -1 = -1 new -1 DateTimeParserBucket( -1 ---- -1 ---instantLocal, -1 ---chrono, -1 ---iLocale, -1 ---iPivotYear, -1 ---iDefaultYear); -1 ++++ -1 +++instantLocal, -1 +++chrono, -1 +++iLocale, -1 +++iPivotYear, -1 +++chrono.year().get(instantLocal)); -1 int -1 newPos -1 = -1 parser.parseInto(bucket, -1 text, -1 position); -1 instant.setMillis(bucket.computeMillis(false, -1 text)); -1 if -1 (iOffsetParsed -1 && -1 bucket.getOffsetInteger() -1 != -1 null) -1 { -1 -2
public -1 int -1 estimateParsedLength() -1 { -1 public -1 int -1 parseInto(DateTimeParserBucket -1 bucket, -1 String -1 text, -1 int -1 position) -1 { -1 String -1 str -1 = -1 text.substring(position); -1 ++++ -1 +++String -1 +++best -1 +++= -1 +++null; -1 for -1 (String -1 id -1 : -1 ALL_IDS) -1 { -1 if -1 (str.startsWith(id)) -1 { -1 ---- -1 ---bucket.setZone(DateTimeZone.forID(id)); -1 ---- -1 ---return -1 ---position -1 ---+ -1 ---id.length(); -1 ++++ -1 +++if -1 +++(best -1 +++== -1 +++null -1 +++|| -1 +++id.length() -1 +++> -1 +++best.length()) -1 +++{ -1 ++++ -1 +++best -1 +++= -1 +++id; -1 ++++ -1 +++} -1 } -1 } -1 ++++ -1 +++if -1 +++(best -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++bucket.setZone(DateTimeZone.forID(best)); -1 ++++ -1 +++return -1 +++position -1 ++++ -1 +++best.length(); -1 ++++ -1 +++} -1 return -1 ~position; -1 } -1 } -1 -2
public -1 long -1 getDateTimeMillis(int -1 year, -1 int -1 monthOfYear, -1 int -1 dayOfMonth, -1 // -1 Assume -1 date -1 is -1 Gregorian. -1 long -1 instant; -1 ++++ -1 +++try -1 +++{ -1 instant -1 = -1 iGregorianChronology.getDateTimeMillis -1 (year, -1 monthOfYear, -1 dayOfMonth, -1 hourOfDay, -1 minuteOfHour, -1 secondOfMinute, -1 millisOfSecond); -1 ++++ -1 +++} -1 +++catch -1 +++(IllegalFieldValueException -1 +++ex) -1 +++{ -1 ++++ -1 +++if -1 +++(monthOfYear -1 +++!= -1 +++2 -1 +++|| -1 +++dayOfMonth -1 +++!= -1 +++29) -1 +++{ -1 ++++ -1 +++throw -1 +++ex; -1 ++++ -1 +++} -1 ++++ -1 +++instant -1 +++= -1 +++iGregorianChronology.getDateTimeMillis -1 ++++ -1 +++(year, -1 +++monthOfYear, -1 +++28, -1 ++++ -1 +++hourOfDay, -1 +++minuteOfHour, -1 +++secondOfMinute, -1 +++millisOfSecond); -1 ++++ -1 +++if -1 +++(instant -1 +++>= -1 +++iCutoverMillis) -1 +++{ -1 ++++ -1 +++throw -1 +++ex; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 if -1 (instant -1 < -1 iCutoverMillis) -1 { -1 // -1 Maybe -1 it's -1 Julian. -1 instant -1 = -1 iJulianChronology.getDateTimeMillis -1 -2
public -1 int -1 getOffsetFromLocal(long -1 instantLocal) -1 { -1 return -1 offsetLocal; -1 } -1 } -1 ---- -1 ---} -1 ---else -1 ---if -1 ---(offsetLocal -1 ---> -1 ---0) -1 ---{ -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(offsetLocal -1 +++>= -1 +++0) -1 +++{ -1 long -1 prev -1 = -1 previousTransition(instantAdjusted); -1 if -1 (prev -1 < -1 instantAdjusted) -1 { -1 int -1 offsetPrev -1 = -1 getOffset(prev); -1 -2
public -1 String -1 getName(Locale -1 locale, -1 String -1 id, -1 String -1 nameKey) -1 { -1 if -1 (byNameKeyCache -1 == -1 null) -1 { -1 byIdCache.put(id, -1 byNameKeyCache -1 = -1 createCache()); -1 ++++ -1 +++String[][] -1 +++zoneStringsEn -1 +++= -1 +++DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); -1 ++++ -1 +++String[] -1 +++setEn -1 +++= -1 +++null; -1 ++++ -1 +++for -1 +++(String[] -1 +++strings -1 +++: -1 +++zoneStringsEn) -1 +++{ -1 ++++ -1 +++if -1 +++(strings -1 +++!= -1 +++null -1 +++&& -1 +++strings.length -1 +++== -1 +++5 -1 +++&& -1 +++id.equals(strings[0])) -1 +++{ -1 ++++ -1 +++setEn -1 +++= -1 +++strings; -1 ++++ -1 +++break; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 String[][] -1 zoneStringsLoc -1 = -1 DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); -1 String[] -1 setLoc -1 = -1 null; -1 for -1 (String[] -1 strings -1 : -1 zoneStringsLoc) -1 { -1 if -1 (strings -1 != -1 null -1 && -1 strings.length -1 == -1 5 -1 && -1 id.equals(strings[0])) -1 { -1 setLoc -1 = -1 strings; -1 ++++ -1 +++break; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 ---- -1 ---byNameKeyCache.put(setLoc[2], -1 ---new -1 ---String[] -1 ---{setLoc[2], -1 ---setLoc[1]}); -1 ++++ -1 +++if -1 +++(setEn -1 +++!= -1 +++null -1 +++&& -1 +++setLoc -1 +++!= -1 +++null) -1 +++{ -1 ++++ -1 +++byNameKeyCache.put(setEn[2], -1 +++new -1 +++String[] -1 +++{setLoc[2], -1 +++setLoc[1]}); -1 // -1 need -1 to -1 handle -1 case -1 where -1 summer -1 and -1 winter -1 have -1 the -1 same -1 // -1 abbreviation, -1 such -1 as -1 EST -1 in -1 Australia -1 [1716305] -1 // -1 we -1 handle -1 this -1 by -1 appending -1 "-Summer", -1 cf -1 ZoneInfoCompiler -1 ---- -1 ---if -1 ---(setLoc[2].equals(setLoc[4])) -1 ---{ -1 ---- -1 ---byNameKeyCache.put(setLoc[4] -1 ---+ -1 ---"-Summer", -1 ---new -1 ---String[] -1 ---{setLoc[4], -1 ---setLoc[3]}); -1 ++++ -1 +++if -1 +++(setEn[2].equals(setEn[4])) -1 +++{ -1 ++++ -1 +++byNameKeyCache.put(setEn[4] -1 ++++ -1 +++"-Summer", -1 +++new -1 +++String[] -1 +++{setLoc[4], -1 +++setLoc[3]}); -1 } -1 else -1 { -1 ---- -1 ---byNameKeyCache.put(setLoc[4], -1 ---new -1 ---String[] -1 ---{setLoc[4], -1 ---setLoc[3]}); -1 ---- -1 ---} -1 ---- -1 ---break; -1 ++++ -1 +++byNameKeyCache.put(setEn[4], -1 +++new -1 +++String[] -1 +++{setLoc[4], -1 +++setLoc[3]}); -1 } -1 } -1 } -1 -2
protected -1 BasePeriod(ReadableDuration -1 duration, -1 ReadableInstant -1 endInstant, -1 Peri -1 * -1 @param -1 duration -1 the -1 duration, -1 in -1 milliseconds -1 */ -1 protected -1 BasePeriod(long -1 duration) -1 { -1 ---- -1 ---this(duration, -1 ---null, -1 ---null); -1 ++++ -1 +++super(); -1 // -1 bug -1 [3264409] -1 ++++ -1 +++iType -1 +++= -1 +++PeriodType.time(); -1 ++++ -1 +++int[] -1 +++values -1 +++= -1 +++ISOChronology.getInstanceUTC().get(this, -1 +++duration); -1 ++++ -1 +++iType -1 +++= -1 +++PeriodType.standard(); -1 ++++ -1 +++iValues -1 +++= -1 +++new -1 +++int[8]; -1 ++++ -1 +++System.arraycopy(values, -1 +++0, -1 +++iValues, -1 +++4, -1 +++4); -1 } -1 /** -1 -2
private -1 static -1 synchronized -1 String -1 getConvertedId(String -1 id) -1 { -1 // -1 Backwards -1 compatibility -1 with -1 TimeZone. -1 map -1 = -1 new -1 HashMap<String, -1 String>(); -1 map.put("GMT", -1 "UTC"); -1 ++++ -1 +++map.put("WET", -1 +++"WET"); -1 ++++ -1 +++map.put("CET", -1 +++"CET"); -1 ++++ -1 +++map.put("MET", -1 +++"CET"); -1 ++++ -1 +++map.put("ECT", -1 +++"CET"); -1 ++++ -1 +++map.put("EET", -1 +++"EET"); -1 map.put("MIT", -1 "Pacific/Apia"); -1 map.put("HST", -1 "Pacific/Honolulu"); -1 // -1 JDK -1 1.1 -1 compatible -1 map.put("AST", -1 "America/Anchorage"); -1 @@ -1 -569,23 -1 +574,19 -1 @@ -1 private -1 static -1 synchronized -1 String -1 getConvertedId(String -1 id) -1 { -1 map.put("PNT", -1 "America/Phoenix"); -1 map.put("CST", -1 "America/Chicago"); -1 map.put("EST", -1 "America/New_York"); -1 // -1 JDK -1 1.1 -1 compatible -1 ---- -1 ---map.put("IET", -1 ---"America/Indianapolis"); -1 ++++ -1 +++map.put("IET", -1 +++"America/Indiana/Indianapolis"); -1 map.put("PRT", -1 "America/Puerto_Rico"); -1 map.put("CNT", -1 "America/St_Johns"); -1 ---- -1 ---map.put("AGT", -1 ---"America/Buenos_Aires"); -1 ++++ -1 +++map.put("AGT", -1 +++"America/Argentina/Buenos_Aires"); -1 map.put("BET", -1 "America/Sao_Paulo"); -1 ---- -1 ---map.put("WET", -1 ---"Europe/London"); -1 ---- -1 ---map.put("ECT", -1 ---"Europe/Paris"); -1 map.put("ART", -1 "Africa/Cairo"); -1 map.put("CAT", -1 "Africa/Harare"); -1 ---- -1 ---map.put("EET", -1 ---"Europe/Bucharest"); -1 map.put("EAT", -1 "Africa/Addis_Ababa"); -1 ---- -1 ---map.put("MET", -1 ---"Asia/Tehran"); -1 map.put("NET", -1 "Asia/Yerevan"); -1 map.put("PLT", -1 "Asia/Karachi"); -1 ---- -1 ---map.put("IST", -1 ---"Asia/Calcutta"); -1 ++++ -1 +++map.put("IST", -1 +++"Asia/Kolkata"); -1 map.put("BST", -1 "Asia/Dhaka"); -1 ---- -1 ---map.put("VST", -1 ---"Asia/Saigon"); -1 ++++ -1 +++map.put("VST", -1 +++"Asia/Ho_Chi_Minh"); -1 map.put("CTT", -1 "Asia/Shanghai"); -1 map.put("JST", -1 "Asia/Tokyo"); -1 map.put("ACT", -1 "Australia/Darwin"); -1 -2
public -1 int -1 getOffsetFromLocal(long -1 instantLocal) -1 { -1 return -1 offsetLocal; -1 } -1 } -1 ++++ -1 +++} -1 +++else -1 +++if -1 +++(offsetLocal -1 +++> -1 +++0) -1 +++{ -1 ++++ -1 +++long -1 +++prev -1 +++= -1 +++previousTransition(instantAdjusted); -1 ++++ -1 +++if -1 +++(prev -1 +++< -1 +++instantAdjusted) -1 +++{ -1 ++++ -1 +++int -1 +++offsetPrev -1 +++= -1 +++getOffset(prev); -1 ++++ -1 +++int -1 +++diff -1 +++= -1 +++offsetPrev -1 +++- -1 +++offsetLocal; -1 ++++ -1 +++if -1 +++(instantAdjusted -1 +++- -1 +++prev -1 +++<= -1 +++diff) -1 +++{ -1 ++++ -1 +++return -1 +++offsetPrev; -1 ++++ -1 +++} -1 ++++ -1 +++} -1 } -1 return -1 offsetAdjusted; -1 } -1 -2
public -1 long -1 add(long -1 instant, -1 int -1 value) -1 { -1 } -1 else -1 { -1 long -1 localInstant -1 = -1 iZone.convertUTCToLocal(instant); -1 localInstant -1 = -1 iField.add(localInstant, -1 value); -1 ---- -1 ---return -1 ---iZone.convertLocalToUTC(localInstant, -1 ---false); -1 ++++ -1 +++return -1 +++iZone.convertLocalToUTC(localInstant, -1 +++false, -1 +++instant); -1 } -1 } -1 @@ -1 -445,7 -1 +445,7 -1 @@ -1 public -1 long -1 add(long -1 instant, -1 long -1 value) -1 { -1 } -1 else -1 { -1 long -1 localInstant -1 = -1 iZone.convertUTCToLocal(instant); -1 localInstant -1 = -1 iField.add(localInstant, -1 value); -1 ---- -1 ---return -1 ---iZone.convertLocalToUTC(localInstant, -1 ---false); -1 ++++ -1 +++return -1 +++iZone.convertLocalToUTC(localInstant, -1 +++false, -1 +++instant); -1 } -1 } -1 @@ -1 -457,14 -1 +457,14 -1 @@ -1 public -1 long -1 addWrapField(long -1 instant, -1 int -1 value) -1 { -1 } -1 else -1 { -1 long -1 localInstant -1 = -1 iZone.convertUTCToLocal(instant); -1 localInstant -1 = -1 iField.addWrapField(localInstant, -1 value); -1 ---- -1 ---return -1 ---iZone.convertLocalToUTC(localInstant, -1 ---false); -1 ++++ -1 +++return -1 +++iZone.convertLocalToUTC(localInstant, -1 +++false, -1 +++instant); -1 } -1 } -1 public -1 long -1 set(long -1 instant, -1 int -1 value) -1 { -1 long -1 localInstant -1 = -1 iZone.convertUTCToLocal(instant); -1 localInstant -1 = -1 iField.set(localInstant, -1 value); -1 ---- -1 ---long -1 ---result -1 ---= -1 ---iZone.convertLocalToUTC(localInstant, -1 ---false); -1 ++++ -1 +++long -1 +++result -1 +++= -1 +++iZone.convertLocalToUTC(localInstant, -1 +++false, -1 +++instant); -1 if -1 (get(result) -1 != -1 value) -1 { -1 throw -1 new -1 IllegalFieldValueException(iField.getType(), -1 new -1 Integer(value), -1 "Illegal -1 instant -1 due -1 to -1 time -1 zone -1 offset -1 transition: -1 " -1 + -1 @@ -1 -478,7 -1 +478,7 -1 @@ -1 public -1 long -1 set(long -1 instant, -1 String -1 text, -1 Locale -1 locale) -1 { -1 // -1 cannot -1 verify -1 that -1 new -1 value -1 stuck -1 because -1 set -1 may -1 be -1 lenient -1 long -1 localInstant -1 = -1 iZone.convertUTCToLocal(instant); -1 localInstant -1 = -1 iField.set(localInstant, -1 text, -1 locale); -1 ---- -1 ---return -1 ---iZone.convertLocalToUTC(localInstant, -1 ---false); -1 ++++ -1 +++return -1 +++iZone.convertLocalToUTC(localInstant, -1 +++false, -1 +++instant); -1 } -1 public -1 int -1 getDifference(long -1 minuendInstant, -1 long -1 subtrahendInstant) -1 { -1 @@ -1 -525,7 -1 +525,7 -1 @@ -1 public -1 long -1 roundFloor(long -1 instant) -1 { -1 } -1 else -1 { -1 long -1 localInstant -1 = -1 iZone.convertUTCToLocal(instant); -1 localInstant -1 = -1 iField.roundFloor(localInstant); -1 ---- -1 ---return -1 ---iZone.convertLocalToUTC(localInstant, -1 ---false); -1 ++++ -1 +++return -1 +++iZone.convertLocalToUTC(localInstant, -1 +++false, -1 +++instant); -1 } -1 } -1 @@ -1 -537,7 -1 +537,7 -1 @@ -1 public -1 long -1 roundCeiling(long -1 instant) -1 { -1 } -1 else -1 { -1 long -1 localInstant -1 = -1 iZone.convertUTCToLocal(instant); -1 localInstant -1 = -1 iField.roundCeiling(localInstant); -1 ---- -1 ---return -1 ---iZone.convertLocalToUTC(localInstant, -1 ---false); -1 ++++ -1 +++return -1 +++iZone.convertLocalToUTC(localInstant, -1 +++false, -1 +++instant); -1 } -1 } -1 -2
public -1 long -1 computeMillis(boolean -1 resetFields, -1 String -1 text) -1 { -1 for -1 (int -1 i -1 = -1 0; -1 i -1 < -1 count; -1 i++) -1 { -1 millis -1 = -1 savedFields[i].set(millis, -1 resetFields); -1 } -1 ++++ -1 +++if -1 +++(resetFields) -1 +++{ -1 ++++ -1 +++for -1 +++(int -1 +++i -1 +++= -1 +++0; -1 +++i -1 +++< -1 +++count; -1 +++i++) -1 +++{ -1 ++++ -1 +++millis -1 +++= -1 +++savedFields[i].set(millis, -1 +++i -1 +++== -1 +++(count -1 +++- -1 +++1)); -1 ++++ -1 +++} -1 ++++ -1 +++} -1 } -1 catch -1 (IllegalFieldValueException -1 e) -1 { -1 if -1 (text -1 != -1 null) -1 { -1 e.prependMessage("Cannot -1 parse -1 \"" -1 + -1 text -1 + -1 '"'); -1 -2
private -1 static -1 PeriodFormatter -1 toFormatter(List<Object> -1 elementPairs, -1 boolean -1 no -1 int -1 size -1 = -1 elementPairs.size(); -1 if -1 (size -1 >= -1 2 -1 && -1 elementPairs.get(0) -1 instanceof -1 Separator) -1 { -1 Separator -1 sep -1 = -1 (Separator) -1 elementPairs.get(0); -1 ++++ -1 +++if -1 +++(sep.iAfterParser -1 +++== -1 +++null -1 +++&& -1 +++sep.iAfterPrinter -1 +++== -1 +++null) -1 +++{ -1 PeriodFormatter -1 f -1 = -1 toFormatter(elementPairs.subList(2, -1 size), -1 notPrinter, -1 notParser); -1 sep -1 = -1 sep.finish(f.getPrinter(), -1 f.getParser()); -1 return -1 new -1 PeriodFormatter(sep, -1 sep); -1 ++++ -1 +++} -1 } -1 Object[] -1 comp -1 = -1 createComposite(elementPairs); -1 if -1 (notPrinter) -1 { -1 -2
